---
layout: post
title: Spring
categories: study
tags : java
toc: true
---
# Spring
## Spring概述
>Spring 是最受欢迎的企业级 Java 应用程序开发框架，数以百万的来自世界各地的开发人员使用
>Spring 框架来创建性能好、易于测试、可重用的代码。
>Spring 框架是一个开源的 Java 平台，它最初是由 Rod Johnson 编写的，并且于 2003 年 6 月首次在 Apache 2.0 许可下发布。
>Spring 是轻量级的框架，其基础版本只有 2 MB 左右的大小。
>Spring 框架的核心特性是可以用于开发任何 Java 应用程序，但是在 Java EE 平台上构建 web 应
>用程序是需要扩展的。 Spring 框架的目标是使 J2EE 开发变得更容易使用，通过启用基于 POJO编程模型来促进良好的编程实践

## Spring家族
[Spring 家族](https://spring.io/projects)
## Spring Framework
Spring 基础框架，可以视为 Spring 基础设施，基本上任何其他 Spring 项目都是以Spring Framework为基础的
### Spring Framework特性
- 非侵入式：使用 Spring Framework 开发应用程序时，Spring 对应用程序本身的结构影响非常小。对领域模型可以做到零污染；对功能性组件也只需要使用几个简单的注解进行标记，完全不会破坏原有结构，反而能将组件结构进一步简化。这就使得基于 Spring Framework 开发应用程序时结构清晰、简洁优雅。
- 控制反转：IOC——Inversion of Control，翻转资源获取方向。把自己创建资源、向环境索取资源变成环境将资源准备好，我们享受资源注入。
- 面向切面编程：AOP——Aspect Oriented Programming，在不修改源代码的基础上增强代码功能。
- 容器：Spring IOC 是一个容器，因为它包含并且管理组件对象的生命周期。组件享受到容器化的管理，替程序员屏蔽了组件创建过程中的大量细节，极大的降低了使用门槛，大幅度提高了开发效率。
- 组件化：Spring 实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用 XML和 Java 注解组合这些对象。这使得我们可以基于一个个功能明确、边界清晰的组件有条不紊的搭建超大型复杂应用系统。
- 声明式：很多以前需要编写代码才能实现的功能，现在只需要声明需求即可由框架代为实现。
- 一站式：在 IOC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库。
  
而且Spring 旗下的项目已经覆盖了广泛领域，很多方面的功能性需求可以在 Spring Framework 的基础上全部使用 Spring 来实现。
### Spring Framework五大功能模块
|功能模块 |功能介绍|
|----|----|
|Core Container |核心容器，在 Spring 环境下使用任何功能都必须基于 IOC 容器。|
|AOP&Aspects |面向切面编程|
|Testing |提供了对 junit 或 TestNG 测试框架的整合。|
|Data Access/Integration| 提供了对数据访问/集成的功能。|
|Spring MVC |提供了面向Web应用程序的集成功能|

# IOC
## IOC容器
### IOC思想
>IOC：Inversion of Control，翻译过来是反转控制

①获取资源的传统方式

自己做饭：买菜、洗菜、择菜、改刀、炒菜，全过程参与，费时费力，必须清楚了解资源创建整个过程中的全部细节且熟练掌握。在应用程序中的组件需要获取资源时，传统的方式是组件主动的从容器中获取所需要的资源，在这样的模式下开发人员往往需要知道在具体容器中特定资源的获取方式，增加了学习成本，同时降低了开发效率。

②反转控制方式获取资源

点外卖：下单、等、吃，省时省力，不必关心资源创建过程的所有细节。
反转控制的思想完全颠覆了应用程序组件获取资源的传统方式：反转了资源的获取方向——改由容器主动的将资源推送给需要的组件，开发人员不需要知道容器是如何创建资源对象的，只需要提供接收资源的方式即可，极大的降低了学习成本，提高了开发的效率。这种行为也称为查找的被动形式。

③DI

DI：Dependency Injection，翻译过来是依赖注入。
DI 是 IOC 的另一种表述方式：即组件以一些预先定义好的方式（例如：setter 方法）接受来自于容器的资源注入。相对于IOC而言，这种表述更直接。所以结论是：IOC 就是一种反转控制的思想， 而 DI 是对 IOC 的一种具体实现。

### IOC容器在Spring中的实现
Spring 的 IOC 容器就是 IOC 思想的一个落地的产品实现。IOC 容器中管理的组件也叫做 bean。在创建bean 之前，首先需要创建 IOC 容器。Spring 提供了 IOC 容器的两种实现方式：

①`BeanFactory`

这是 IOC 容器的基本实现，是 Spring 内部使用的接口。面向 Spring 本身，不提供给开发人员使用。

②`ApplicationContext`

BeanFactory 的子接口，提供了更多高级特性。面向 Spring 的使用者，几乎所有场合都使用

`ApplicationContext` 而不是底层的 `BeanFactory`。

③`ApplicationContext`的主要实现类

- 方式一：`BeanFactory` ，IOC容器的基本实现，是Spring内部使用的接口。面向Spring本身，不提供给开发人员使用。
- 方式二：`ApplicationContext`，BeanFactory的子接口，提供了更多高级的特性。面向Spring的使用者的，几乎所有场合都使用ApplicationContext，而不是底层的BeanFactory。子类 `ClassPathXmlApplicationContext` 使用的是最多的。

|类型名 |简介|
|----|----|
|ClassPathXmlApplicationContext |通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象|
|FileSystemXmlApplicationContext |通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象|
|ConfigurableApplicationContext|`ApplicationContext`的子接口，包含一些扩展方法`refresh()` 和 `close()` ，让 `ApplicationContext` 具有启动、关闭和刷新上下文的能力。|
|WebApplicationContext| 专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。|

## 基于XML管理bean
### 实验一：入门案例

①创建Maven Module

②引入依赖
```xml
<dependencies>
<!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 -->
<dependency>
<groupId>org.springframework</groupId>
<artifactId>spring-context</artifactId>
<version>5.3.1</version>
</dependency>
<!-- junit测试 -->
<dependency>
<groupId>junit</groupId>
<artifactId>junit</artifactId>
<version>4.12</version>
<scope>test</scope>
</dependency>
</dependencies>

```

创建类HelloWorld
```java
public class HelloWorld {
    public void sayHello(){
    System.out.println("helloworld");
    }
}
```

④创建Spring的配置文件

⑤在Spring的配置文件中配置bean

```xml
<!--
配置HelloWorld所对应的bean，即将HelloWorld的对象交给Spring的IOC容器管理
通过bean标签配置IOC容器所管理的bean
属性：
id：设置bean的唯一标识
class：设置bean所对应类型的全类名
-->
<bean id="helloworld" class="com.andy.spring.bean.HelloWorld"></bean>

```

⑥创建测试类测试
```java
@Test
public void testHelloWorld(){
ApplicationContext ac = new
ClassPathXmlApplicationContext("applicationContext.xml");
HelloWorld helloworld = (HelloWorld) ac.getBean("helloworld");
helloworld.sayHello();
}

```

⑦思路

⑧注意

Spring 底层默认通过反射技术调用组件类的无参构造器来创建组件对象，这一点需要注意。如果在需要无参构造器时，没有无参构造器，则会抛出下面的异常：
```shell
org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'helloworld' defined in class path resource [applicationContext.xml]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.atguigu.spring.bean.HelloWorld]: No default constructor found; nested exception is java.lang.NoSuchMethodException: com.atguigu.spring.bean.HelloWorld.<init> ()
```

### 注册bean
一般的 bean 使用 <bean> 标签注册即可，看上方搭建项目里面即可
#### 注册集合bean

```xml
<!-- 配置一个集合类型的bean -->
<util:list id="studentList" >
    <ref bean="studentOne"></ref>
    <ref bean="studentTwo"></ref>
</util:list>
```
### 获取Bean的三种方式
根据 id，类型，id + 类型获取的三种方式

根据类型获取注意点：当容器当中有多个相同类型的Bean的时候就GG了。 → NoUniqueBeanDefinitionException ( 这个最常用，就用这个 )

id + 类型的方式：id 和 类型组合起来唯一就行啦。

组件实现了接口，同样可以使用接口的类型获得组件，但前提是Bean唯一。
```java
// Student implements Person
// <bean id="student" class="com.atguigu.spring.pojo.Student"></bean>
Person person = ioc.getBean(Person.class);
```

## 依赖注入详解
为类中属性赋值的过程

首先简单介绍分两类，其次介绍各种类型数据如何注入。
### setter 注入（用的最多）
setter 注入 和 set方法有关，跟成员变量没有关系

```xml
<bean id="studentOne" class="com.atguigu.spring.pojo.Student">
    <!-- setter 注入 和 set方法有关，跟成员变量没有关系-->
    <property name="sname" value="张三"></property>
</bean>
```
###  构造器注入

> 根据 <constructor-arg> 标签的顺序来决定调用那个构造参数，name 属性不要省（虽然可以省），name指定匹配的草参数避免有类似类型参数混淆
```xml
<!-- public Student(Integer sid, String sname, Integer age, String gender) -->
<bean id="studentTwo" class="com.andy.spring.pojo.Student">
    <constructor-arg name="sid" value="1"></constructor-arg>
    <constructor-arg name="sname" value="张三"></constructor-arg>
    <constructor-arg name="age" value="20"></constructor-arg>
    <constructor-arg name="gender" value="男"></constructor-arg>
</bean>
```
###  各种类型如何注入

#### A. 字面量注入

> 字面量包含 基本数据类型、String、包装类型

> **String 赋值 null**

```XML
<property name="sname">
    <null></null>
</property>
```



> 特殊字符，可以使用转义，xml实体或 CDATA区

`<`  `&lt;`
`>`  `&gt;`

```XML
<property name="sname">
    <value><![CDATA[ a>b ]]</value>
</property>
```

CDATA是一种特殊的标签



#### B. 为类/接口类型的属性复制

> **ref方式**：如下：Student类含有一个Course成员，且提供了setter.

```XML
<bean id="courseOne" class="com.andy.spring.pojo.Course">
    <!-- 注入省略 -->
</bean>

<bean id="studentOne" class="com.andy.spring.pojo.Student">
    <!-- void setCourse(Course course) -->
    <property name="course" ref="courseOne"></property>
</bean>

```

> 级联属性赋值

```xml
<bean id="studentFour" class="com.atguigu.spring.bean.Student">
    <property name="id" value="1004"></property>
    <property name="name" value="赵六"></property>
    <property name="age" value="26"></property>
    <property name="sex" value="女"></property>
    <!-- 一定先引用某个bean为属性赋值，才可以使用级联方式更新属性 -->
    <property name="clazz" ref="clazzOne"></property>
    <property name="clazz.clazzId" value="3333"></property>
    <property name="clazz.clazzName" value="最强王者班"></property>
</bean>
```

> **内部bean的方式**：但是IOC不能获取到内部Bean了。

```XML
<bean id="studentOne" class="com.andy.spring.pojo.Student">
    <!-- void setCourse(Course course) -->
    <property name="course">
        <!-- 在一个bean中再声明一个bean就是内部bean -->
        <!-- 内部bean只能用于给属性赋值，不能在外部通过IOC容器获取，因此可以省略id属性 -->
       <bean id="courseOne" class="com.andy.spring.pojo.Course">
         <property name="cid" value="2222"></property>
         <property name="cname" value="远大前程班"></property>
      </bean>
    </property>
</bean>
```



#### C. 数组

> 如果是字面量类型则用 value，如果是类类型则用 ref

```XML
<bean id="studentOne" class="com.atguigu.spring.pojo.Student">
    <!-- String[] hobby; -->
    <property name="hobby">
        <array>
            <value>抽烟</value>
            <value>喝酒</value>
            <value>烫头</value>
            
            <!-- 类类型用 -->
            <!-- <ref bean="id"></ref> -->
        </array>
    </property>
</bean>
```



#### D. List集合（两种方式）

> **方式一**：Property标签内部设置，字面量类型用 value，类类型用 ref

```XML
<bean id="course" class="com.atguigu.spring.pojo.Course">
    <!-- List<Student> students -->
    <property name="students">
       <list>
           <ref bean="studentOne"></ref>
           <ref bean="studentTwo"></ref>
           <ref bean="studentThree"></ref>
       </list>
    </property>
</bean>
```

若为Set集合类型属性赋值，只需要将其中的list标签改为set标签即可

> **方式二**：或者从List类型的bean 注入

```XML
<bean id="course" class="com.atguigu.spring.pojo.Course">
    <!-- List<Student> students -->
    <property name="students" ref="studentList"></property>
</bean>

<!-- 配置一个集合类型的bean -->
<util:list id="studentList" >
    <ref bean="studentOne"></ref>
    <ref bean="studentTwo"></ref>
</util:list>

```



#### E. Map 集合（两种方式）

> **方式一**：Property标签内部设置
键是字面量类型则用 key 属性，类类型则用 key-ref

```XML
<bean id="teacherOne" class="com.atguigu.spring.pojo.Teacher"></bean>
<bean id="teacherTwo" class="com.atguigu.spring.pojo.Teacher"></bean>

<bean id="studentOne" class="com.atguigu.spring.pojo.Student">
    <!-- Map<String, Teacher> teacherMap; -->
    <property name="teacherMap">
        <map>
            <entry key="teacherOne" value-ref="teacherOne"></entry>
            <entry key="teacherTwo" value-ref="teacherTwo"></entry>
        </map>
    </property>
</bean>
```



> 方式二：或者从Map类型的bean 注入

```XML
<util:map id="teacherMap">
    <entry key="teacherOne" value-ref="TeacherOne"></entry>
    <entry key="teacherTwo" value-ref="teacherTwo"></entry>
</util:map>


<bean id="studentOne" class="com.atguigu.spring.pojo.Student">
    <!-- Map<String, Teacher> teacherMap; -->
    <property name="teacherMap" ref="teacherMap"></property>
</bean>
```
