---
layout: post
title: react基础
categories: study
tags : Javascript
toc: true

---

## 引入

```javascript
<!-- 引入react核心库-->
<script type="text/javascript" src="../js/react.development.js"> </script>
<!-- 引入react.dom库用于支持react操纵dom-->
<script type="text/javascript" src="..js/react-dom.development.js"> </script>
<!-- 引入babel,用于翻译jsx到js-->
<script type="text/javascript" src="..js/babel.min.js"> </script>
```

### 在线引入
```react
 <script src="https://cdn.staticfile.org/react/16.4.0/umd/react.development.js"></script>
<script src="https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js"></script>
  <!-- 生产环境中不建议使用 -->
<script src="https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js">
```
```react
<script type="text/babel">
const vdom= <h1>hello react</h1>
ReactDom.render(vdom,document.getElementById("test"))
</script>
```

## 断点

```javascript
debugger;
```

虚拟dom属性少，轻

## jsx 规则

- 根节点只有一个
- 值类型的用{}包起来
- 虚拟dom定义不用加引号
- `class->className,style={{background:"red",fontSize:"20px"}}`
- 标签必须闭合
- 小写字母代表html同名标签，大写代表自定义组件

## 组件

### 函数式组件

```react
function Demo(){
    return <h2>test React</h2>
}

const vdom=<Demo/>
```

标签必须闭合,函数名即组件名



### 类式组件

- 必须继承 `React.Component`

- 必须有`render()`且有返回值

- 组件中`render()`方法的this为组件实例对象

- 组件自定义方法中的this为 undefined

	- 解决方法
		- 回调函数在构造函数中使用 `bind` 方法绑定函数
		- 或者使用箭头函数写在外面


## state 属性

必须使用


```javascript
setState({:})
```

## props属性

- 不可修改
- 函数参数可选
- `defaultProps`和`propsTypes`限制props的属性选值
- `<demo{...person}>`

## refs 属性

- 标签唯一标志,key
- 字符串型 `ref="person"`

```react
class Demo extends React.Component{
			//展示左侧输入框的数据
			showData = ()=>{
				const {input1} = this.refs
				alert(input1.value)
			}
			//展示右侧输入框的数据
			showData2 = ()=>{
				const {input2} = this.refs
				alert(input2.value)
			}
			render(){
				return(
					<div>
						<input ref="input1" type="text" placeholder="点击按钮提示数据"/>&nbsp;
						<button onClick={this.showData}>点我提示左侧的数据</button>&nbsp;
						<input ref="input2" onBlur={this.showData2} type="text" placeholder="失去焦点提示数据"/>
					</div>
				)
			}
		}
		//渲染组件到页面
		ReactDOM.render(<Demo a="1" b="2"/>,document.getElementById('test'))
```




- `createRef()`

```javascript
class Demo extends React.Component{
    /* 
	React.createRef调用后可以返回一个容器，该容器可以存储被ref所标识的节点,该容器是“专人专用”的
	*/
    myRef = React.createRef()
    myRef2 = React.createRef()
    //展示左侧输入框的数据
    showData = ()=>{
        alert(this.myRef.current.value);
    }
    //展示右侧输入框的数据
    showData2 = ()=>{
        alert(this.myRef2.current.value);
    }
    render(){
        return(
            <div>
            <input ref={this.myRef} type="text" placeholder="点击按钮提示数据"/>&nbsp;
    <button onClick={this.showData}>点我提示左侧的数据</button>&nbsp;
<input onBlur={this.showData2} ref={this.myRef2} type="text" placeholder="失去焦点提示数据"/>&nbsp;
</div>
)
}
}
```




- 调用`this.refs`获取节点实例
- 回调式型 


```react
class Demo extends React.Component{
			//展示左侧输入框的数据
    showData = ()=>{
        const {input1} = this
        alert(input1.value)
    }
    //展示右侧输入框的数据
    showData2 = ()=>{
        const {input2} = this
        alert(input2.value)
    }
    render(){
        return(
            <div>
                <input ref={c => this.input1 = c } type="text" placeholder="点击按钮提示数据"/>&nbsp;
                <button onClick={this.showData}>点我提示左侧的数据</button>&nbsp;
                <input onBlur={this.showData2} ref={c => this.input2 = c } type="text" placeholder="失去焦点提示数据"/>&nbsp;
            </div>
        	)
		}
}
```



## 组件

### 受控组件

一有变化就更新

```react
class Login extends React.Component{
	handleSubmit=(event)=>{
        event.preventDefault()
        const{username,password}=this
        alert(username.value,password.value)
}
saveData=(dataType)=>{
        return (event)=>{
        console.log([dataType]:event.target.value)
	}
}
render(){
        return (
            <from action="localhost" onSubmit={this.handleSubmit}>
            用户名:<input onChange={this.saveData("username")} type="text" name="username"/>
            密码: <input onChange={this.saveData("password")} type="password" name="password"/>
            <button>登录</button>
            </from>
        )
        }
}
ReactDom.render(<login/>,document.getElementById("test"))
````

  

### 非受控组件

随用随取

```react
class Login extends React.Component{
    handleSubmit=(event)=>{
        event.preventDefault()
        const{username,password}=this
        alert(username.value,password.value)
	}
    render(){
    return (
        <from action="localhost" onSubmit={this.handleSubmit}>
            用户名:<input ref={c=>this.username=c} type="text" name="username"/>
            密码: <input ref={c=>this.password=c} type="password" name="password"/>
            <button>登录</button>
        </from>
    )
}
}
ReactDom.render(<login/>,document.getElementById("test"))
```

  

## 函数柯里化

高阶函数

# 生命周期

## 旧生命周期

```react
componentWillMount()
componentDidMount()

shouldComponentUpdate()

componentWillUpdate()
forceUpdate()

componentDidUpdate()

componentWillUnmount()
```

## 新生命周期钩子

```react
construcrtor()
static getDerivedStateFromProps(props){//横跨挂载和更新
	return props;//派生的状态,state值任何状态都取决于props
//必须返回null或者对象
}
render()

getSnapshotBeforeUpdate(){//更新时，必须返回值
	return this.refs.value//更新之前获取快照
}

//更新
componentDidUpdate(preProps,preState,snapshotValue){

}

componentWillUnmount
```

# react 脚手架

```powershell
npm install create-react-app -g
create-react-app my-app
cd my-app
npm start

```

### 文件详解

- package.json



- node_modules 引入的包

- public 
  - manifest.json  ios安卓加壳配置文件
  - index.html 主文件
- src
  - index.js引入文件
    - `<React.ScriptMode>`检查代码瑕疵
  - setupTests.js 模块测试，整体测试
  - reportWebVitual.js  页面性能分析
  - App.js App组件
  - 

```react
export default React;//默认暴露
export Component;//分别暴露
import React ,{Component} from ..
```

### 样式的模块化

```react
import hello from "index.m"
```

## 解决跨域问题

### 配置解决

1、`package.json`中

```json
"proxy":"http://localhost:5000"
```

2、src/setupProxy.js

```javascript
const proxy = require('http-proxy-middleware')

module.exports = function(app) {
  app.use(
    proxy('/api1', {  //api1是需要转发的请求(所有带有/api1前缀的请求都会转发给5000)
      target: 'http://localhost:5000', //配置转发目标地址(能返回数据的服务器地址)
      changeOrigin: true, //控制服务器接收到的请求头中host字段的值
      /*
      	changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000
      	changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:3000
      	changeOrigin默认值为false，但我们一般将changeOrigin值设为true
      */
      pathRewrite: {'^/api1': ''} //去除请求前缀，保证交给后台服务器的是正常请求地址(必须配置)
    }),
    proxy('/api2', { 
      target: 'http://localhost:5001',
      changeOrigin: true,
      pathRewrite: {'^/api2': ''}
    })
  )
}
```

```react
getStudentData=()=>{
    axios.get("http://localhost:3000/api1/students".then(reponse=>{//有3000找3000没有找转发代理
        concole.log("success",reponse.data,
        error=>{
            console.log("error")
        }
        )
    }))
}
```

说明：

1. 优点：可以配置多个代理，可以灵活的控制请求是否走代理。
2. 缺点：配置繁琐，前端请求资源时必须加前缀。.



# 消息订阅与发布

适用于任意组件之间通信 `pubsub.js`

```dash
npm install pubsub-js
```

```javascript
import PubSub from 'pubsub-js'
const PubSub =require('PubSub-js');
```

```js
var mySubscriber=function(msg,data){//消息发布后的回调函数
    concole.log(msg,data)
}

var token=PubSub.subscribe("my topic",mySubscriber);//订阅消息
PubSub.publish("my topic","helloworld ")//f发布消息
PubSub.unsubscribe(token);//取消订阅
```

# fetch

- 基于promise

- 关注分离思想

- 原生函数不用下载，内置

- 老版本浏览器可能不支持

- `axios` 与`jQuery`都是对`xhr`的封装（XMLHttpRequest）

- `fetch`与`xhr`并列

```javascript
fetch("url").then(response=>{
    console.log("联系服务器成功",reponse);
    return response.json()
}, error=>{
    console.log("联系服务器失败了",error);
    return new Promise(()=>{})
}).then(
response=>{  console.log("获取数据成功",reponse);};
error=>{  console.log("获取服务失败",error);}    
)


fetch("url").then(response=>{
    console.log("联系服务器成功",reponse);
    return response.json()
}    ).then(
response=>{  console.log("获取数据成功",reponse);};
).catch(
error=>{console.log("请求出错",error)}
)

search = async()=>{
		//获取用户的输入(连续解构赋值+重命名)
		const {keyWordElement:{value:keyWord}} = this
		//发送请求前通知List更新状态
		PubSub.publish('changeState',{isFirst:false,isLoading:true})
		//#region 发送网络请求---使用axios发送
		/* axios.get(`/api1/search/users2?q=${keyWord}`).then(
			response => {
				//请求成功后通知List更新状态
				PubSub.publish('changeState',{isLoading:false,users:response.data.items})
			},
			error => {
				//请求失败后通知App更新状态
				PubSub.publish('changeState',{isLoading:false,err:error.message})
			}
		) */
		//#endregion
			
		//发送网络请求---使用fetch发送（未优化）
		/* fetch(`/api1/search/users2?q=${keyWord}`).then(
			response => {
				console.log('联系服务器成功了');
				return response.json()
			},
			error => {
				console.log('联系服务器失败了',error);
				return new Promise(()=>{})
			}
		).then(
			response => {console.log('获取数据成功了',response);},
			error => {console.log('获取数据失败了',error);}
		) */

		//发送网络请求---使用fetch发送（优化）
		try {
			const response= await fetch(`/api1/search/users2?q=${keyWord}`)
			const data = await response.json()
			console.log(data);
			PubSub.publish('changeState',{isLoading:false,users:data.items})
		} catch (error) {
			console.log('请求出错',error);
			PubSub.publish('changeState',{isLoading:false,err:error.message})
		}
}
```

# react 路由

spa 单页面应用
```bash
npm install react-route-dom
```

必须包裹进来，<BrowserRouter>或者<HashRouter>
```javascript
ReactDOM.render(
	<BrowserRouter>
		<App/>
	</BrowserRouter>,
	document.getElementById('root')
)


```


```javascript
import { Link, BrowserRouter, Route,Routes } from 'react-router-dom'
```

导航区的 a 标签改为` Link `标签
同时我们需要用 `Route` 标签，来进行路径的匹配，从而实现不同路径的组件切换
```javascript
<Link className="list-group-item" to="/about">About</Link>

 <Routes>
    <Route path="/about" element={<About/>}/>
    <Route path="/home" element={<Home/>}/>
 </Routes> 

```
## `<Switch>`
switch 避免匹配到多个路由，节约资源
v6替换`<Switch>`为`<Routes>`

## 多级路由样式丢失问题

解决方法1
```react
<link rel="stylesheet" href="./css/bootstrap.css">
```

解决方法2
```react
<link rel="stylesheet" href="%PUBLIC_URL%/css/bootstrap.css">
```

解决方案3
`<BrowserRouter>` 换成`<HashRouter>`
默认找不到的文件返还index.html
默认在localhost:3000 即在public下找

## 页面的模糊匹配与严格匹配

模糊匹配`/home/a/b`->`/home`若最开始匹配不上就失败，开头必须匹配的上
精准匹配 必须一模一样
```javascript
<Route exact ={true} path="/home"  element={<Home/>}>
<Route exact  path="/about"  element={<About/>}>


```
## redire重定向
都匹配不上的时候采用的路由
```javascript
<Link className="list-group-item" to="/about">About</Link>

 <Routes>
    <Route path="/about" element={<About/>}/>
    <Route path="/home" element={<Home/>}/>
    <Redirect to="/about"/>
 </Routes> 

```
v6移除了`<Redirect>`改为
```javascript
<Route path="*" element={<Navigate to="/login" />} />
```
## 嵌套路由、多级路由

App.jsx
```javascript
<Routes>
    <Route path="/about" element={<About/>}/>
    <Route path="/home/*" element={<Home/>}>
        <Route path = "news" element={<News/>} />
        <Route path = "message" element={<Message/>} />
         <Route path="" element={<Navigate to="/home/message"/>}/>
         {/* 二级路由默认匹配 */]}
    </Route>
    <Route path="*" element={<Navigate to="/home"/>}/>
     {/*  <Route path={"*"} element={<Navigate to="/home"/>}/>  也可以*/}
</Routes> 
```
Home.jsx
to的路径第一个不加/
```javascript
<ul className="nav nav-tabs">
    <li>
        <NavLink className="list-group-item " to="home/news">news</NavLink>
    </li>
    <li>
        <NavLink className="list-group-item" to="home/message">message</NavLink>
    </li>
</ul> 
<Outlet />
```
`<Outlet/>`为子组件的一个占位符

注意上面的第三点，嵌套的 parent route 的 path 不用加*。但如果不是嵌套，而是分散在子组件中，就需要尾部加上*
## 传递参数
### 传递params
我们将消息列表的 id 和 title 写在了路由地址后面

这里我们需要注意的是：需要采用模板字符串以及 $ 符的方式来进行数据的获取
在注册路由时，我们可以通过 :数据名 来接收数据
```javascript

 <Link to={`/home/message/detail/${msgObj.id}/${msgObj.title}`}>{msgObj.title}</Link>
 
{/* 也可以*/}
<Link to={`detail/${msgObj.id}/${msgObj.title}`}>{msgObj.title}</Link>
<Routes>
    {/* <Route path="detail/:id/:title" element={<Detail/>}/> */}
    <Route path="detail/:id/:title" element={<Detail />}></Route>
</Routes>
```
我们可以发现，我们传递的数据被接收到了对象的 match 属性下的 params 中

因此我们可以在 Detail 组件中获取到又 Message 组件中传递来的 params 数据

并通过 params 数据中的 id 值，在详细内容的数据集中查找出指定 id 的详细内容
```javascript
//const { id, title } = this.props.match.params
const findResult = DetailData.find((detailObj) => {
    return detailObj.id === id
})
```
在Detail中可以采用useParams,Detail必须使用函数式组件
```javascript
import {useParams} from 'react-router-dom'
const Detail =()=> {
    const params = useParams();
    console.log(params);
    const findResult=detailData.find((detailObj)=>{
        console.log(detailData.id,params.id);
      return detailObj.id===params.id
    })
   
      return (
        <div>
            detailes
        <ul>
          <li>ID:{findResult.id}</li>
          <li>TITLE:{findResult.title}</li>
          <li>CONTENT:{findResult.content}</li>
        </ul>
      </div>
        );
    
}
```
### 传递search参数
参数不需要接受
```javascript
 <Route path="detail" element={<Detail/>}/>

   const { search } = useLocation()//?id=01&title=%E6%B6%88%E6%81%AF1
const res=qs.parse(search.slice(1))//{id:"01",title:"%E6%B6%88%E6%81%AF1"}


```

### 传递state参数

参数不需要接受
```javascript

 <Link to={`detail`}   state={{ id: 999, title: "i love merlin",content:"svd" }} >{msgObj.title}</Link> 
 <Route path="detail" element={<Detail/>}/>

   const { state } = useLocation()//{id:"01",title:"%E6%B6%88%E6%81%AF1"}


```

## push和replace
push 压栈
replace 替换栈内
```javascript

 <Link to={`detail`}  replace={true} >{msgObj.title}</Link> 
 <Link to={`detail`}  replace >{msgObj.title}</Link> 

```