---

title: 操作系统问题
categories: study
tags : 考研复习
toc: true

---

# linux
## 基本命令
### grep
grep 命令。强大的文本搜索命令，grep(Global Regular Expression Print) 全局正则表达式搜索。

grep 的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。
```bash
grep -i "http" ./a.log
cat ./a.log |grep "http"
```
-i 忽略大小写

### linux开机自动执行命令如何实现？
- 方法 #1 - 使用 cron 任务

除了常用格式（分 / 时 / 日 / 月 / 周）外，cron 调度器还支持 @reboot 指令。这个指令后面的参数是脚本（启动时要执行的那个脚本）的绝对路径。

然而，这种方法需要注意两点：

a) cron 守护进程必须处于运行状态（通常情况下都会运行），同时

b) 脚本或 crontab 文件必须包含需要的环境变量。

- 方法 #2 - 使用 /etc/rc.d/rc.local

这个方法对于 systemd-based 发行版 Linux 同样有效。不过，使用这个方法，需要授予 /etc/rc.d/rc.local 文件执行权限：
```bash
# chmod +x /etc/rc.d/rc.local
```
然后在这个文件底部添加脚本。

### 查看内存
查看内存使用情况
```bash
free -m
```
-m表示以MB为单位，类似-b Byte -k以KB

top命令

top命令。显示当前系统正在执行的进程的相关信息，包括进程 ID、内存占用率、CPU 占用率等

要查看负载情况一般使用 uptime 命令（w 命令和 top 命令也行）

iostat 命令可以查看系统分区的 IO 使用情况

iotop 命令类似于 top 命令，但是显示的是各个进程的 I/O 情况，对于定位 I/O 操作较重的进程有比较大的作用。

使用 sar 命令查看当天 CPU 使用：

sysstat 工具

很多时候当检测到或者知道历史的高负载状况时，可能需要回放历史监控数据，这时 sar 命令就派上用场了，sar 命令同样来自 sysstat 工具包，可以记录系统的 CPU 负载、I/O 状况和内存使用记录，便于历史数据的回放。

sysstat 的配置文件在 /etc/sysconfig/sysstat 文件，历史日志的存放位置为 /var/log/sa\
统计信息都是每 10 分钟记录一次，每天的 23:59 会分割统计文件，这些操作的频率都在 /etc/cron.d/sysstat 文件配置。


### 查看进程、端口  
>Linux中，如何通过端口查进程，如何通过进程查端口？

linux下通过进程名查看其占用端口： 

（1）先查看进程pid

`ps -ef | grep 进程名`

（2）通过pid查看占用端口

`netstat -nap | grep 进程pid`

linux通过端口查看进程：

`netstat -nap | grep 端口号`

# 协程
>什么是协程？

协程：协程是微线程，在子程序内部执行，可在子程序内部中断，转而执行别的子程序，在适当的时候再返回来接着执行。


>线程与协程的区别：

（1）协程执行效率极高。协程直接操作栈基本没有内核切换的开销，所以上下文的切换非常快，切换开销比线程更小。

（2）协程不需要多线程的锁机制，因为多个协程从属于一个线程，不存在同时写变量冲突，效率比线程高。

（3）一个线程可以有多个协程。

协程的优势：

（1）协程调用跟切换比线程效率高：协程执行效率极高。协程不需要多线程的锁机制，可以不加锁的访问全局变量，所以上下文的切换非常快。

（2）协程占用内存少：执行协程只需要极少的栈内存（大概是4～5KB），而默认情况下，线程栈的大小为1MB。

（3）切换开销更少：协程直接操作栈基本没有内核切换的开销，所以切换开销比线程少。
# 进程

- 每个进程包含独立的地址空间
- 线程没有独立的地址空间，共享所属进程的地址空间
- 操作系统对并发进程的管理是通过对pcb的管理
- C语言程序分为
  - 正文段 代码，赋值数据段，
  - 数据堆段  动态分配的存储区
  - 数据栈段  临时变量


> 进程与线程的区别

1）一个线程从属于一个进程；一个进程可以包含多个线程。

（2）一个线程挂掉，对应的进程挂掉；一个进程挂掉，不会影响其他进程。

（3）进程是系统资源调度的最小单位；线程CPU调度的最小单位。

（4）进程系统开销显著大于线程开销；线程需要的系统资源更少。

（5）进程在执行时拥有独立的内存单元，多个线程共享进程的内存，如代码段、数据段、扩展段；但每个线程拥有自己的栈段和寄存器组。

（6）进程切换时需要刷新TLB并获取新的地址空间，然后切换硬件上下文和内核栈，线程切换时只需要切换硬件上下文和内核栈。

（7）通信方式不一样。

（8）进程适应于多核、多机分布；线程适用于多核
## 进程调度

- 进程的状态
  - 三状态： 就绪态，阻塞态，运行态
  - 五状态： 三 + 新建态和终止态
  - 七状态： 五+ 就绪挂起+阻塞挂起
- sjf算法默认是非抢占式的。
- sjf算法的平均等待时间，平均周转时间最少，前提
  - 所有进程几乎同时到达
  - 所有进程同时可运行
- SRTN最短时间优先算法（抢占式）
- 死锁定理用于检查死锁是否发生

# 内存管理

- 形成逻辑地址是在链接阶段
- 程序在进行io操作时不能撤出主存，有系统缓冲区是可以
- 覆盖和交换是为进了解决内存不足的问题，节省内存空间
- 分区分配内存的主要保护措施是界地址保护
- 分段管理有利于程序的动态链接
- 分区存储管理的代价最小
- 重定位是逻辑地址到物理地址
- 分段是二维地址结构，分页是一维
- 每个进程都有一个属于自己的页表

## 虚拟存储

- 缺页中断之后应该执行的是被中断的那一条指令

- 虚拟存储器的容量是由计算机的地址结构决定的

- 所有置换策略都有可能引起抖动

- lru算法（最近未使用）算法耗费高的原因是需要对所有的页进行排序

- 工作集的窗口时某时刻之前的


# 文件管理

- 对用户来说文件系统是为了实现对文件的按名索取
- 打开文件的主要工作就是把文件的目录复制到内存指定的区域
- 在unix中输入输出设备属于特殊文件
- 多级目录结构解决了命名冲突
- 文件被进程首次打开时，系统首先要将文件控制块读到内存中。

## 磁盘管理

- 直接存取即随机存取，连续分配和索引分配都适合，链接分配不适合
- 散列法不适合顺序查找和枚举文件，线性检索适合常用
- 磁带一般只能顺序检索，顺序存储，除非说是能倒带

- 只有先来先服务绝不会导致磁臂黏着

# 设备管理

- 设备映射表dmt是用来管理逻辑设备和物理设备之间的映射关系的。
- 分配共享设备不会引起死锁
- 共享设备必须是可寻址的和可随机访问的。
- 逻辑设备可以把一个物理设备转化为多个逻辑设备
- 字节多路通道用于来连接大量的低速和中速i/o设备
- 设备分配时一般不考虑及时性问题
- 系统为设备的统一编号称为绝对号
- 键盘是中断方式工作外设
- 计算磁盘号，磁头号，扇区号是由磁盘驱动程序完成的。
- 多个并发进程共享可以使用缓冲池技术
- 缓冲池管理最重要的问题是实现进程访问缓冲区的同步
- 图形用户页面下，鼠标可以使用缓冲技术
- 虚拟设备是靠spooling技术实现的
- spooling技术的主要目的是为了提高设备的占有率
- spooling技术的基本条件是要有大容量高速度的外存作为输入井和输出井
- spooling技术将一个独占设备虚拟成一个共享设备供多个进程使用

