---
layout: post
title: 2023-4-12-java琐碎知识点记录
categories: study
tags: java
toc: true
---
# Java基础
## 运算
- `<<`  左移，向左移若干位，高位丢弃，低位补零
- `>>` 带符号左移，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1
- `>>>` 无符号右移，忽略符号位，空位都以 0 补齐。

只针对int long类型的数据，对于short byte char是默认转化为int类型之后在进行操作

int 类型左移/右移位数大于等于 32 位操作时，会先求余（%）后再进行左移/右移操作。也就是说左移/右移 32 位相当于不进行移位操作（32%32=0），左移/右移 42 位相当于左移/右移 10 位（42%32=10）
 
## 变量
被 final 修饰的成员变量也必须显式地赋值

基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 static 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中
 
## 方法
### 方法重写

方法的重写要遵循“两同两小一大”（以下内容摘录自《疯狂 Java 讲义》
- “两同”即方法名相同、形参列表相同；
- “两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；
- “一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等

遇到可变长度参数，有限匹配定厂的函数

## float
BigDecimal 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 `BigDecimal`

## 接口和抽象类
接口和抽象类有什么共同点和区别？
- 共同点 ：
  - 都不能被实例化。
  - 都可以包含抽象方法。
  - 都可以有默认实现的方法（Java 8 可以用 default 关键字在接口中定义默认方法）。
- 区别 ：
  - 接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。一个类只能继承一个类，但是可以实现多个接口。
  - 接口中的成员变量只能是 `public static final` 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 `default`，可在子类中被重新定义，也可被重新赋值

## hashcode
Object 的 hashCode() 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回

## String
### String为什么是不可变的
- 保存字符串的数组被 final 修饰且为私有的，并且String 类没有提供/暴露修改这个字符串的方法。 
- String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变。

### 底部编码

Java 9 为何要将 String 的底层实现由 `char[]` 改成了 `byte[]` ?新版的 String 其实支持两个编码方案： Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下，byte 占一个字节(8 位)，char 占用 2 个字节（16），byte 相较 char 节省一半的内存空间。JDK 官方就说了绝大部分字符串对象只包含 Latin-1 可表示的字符。
 
### `+`
Java 语言本身并不支持运算符重载，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。

字符串对象通过“+”的字符串拼接方式，实际上是通过 StringBuilder 调用 append() 方法实现的，拼接完成之后调用 toString() 得到一个 String 对象

用 “+” 进行字符串拼接会产生大量的临时对象的问题在 JDK9 中得到了解决。在 JDK9 当中，字符串相加 “+” 改为了用动态方法 makeConcatWithConstants() 来实现，而不是大量的 StringBuilder 了。这个改进是 JDK9 的 JEP 280open in new window 提出的，这也意味着 JDK 9 之后，你可以放心使用“+” 进行字符串拼接了
 

## 迭代器

### fail-fast

字面意思是“快速失败”。当我们在遍历集合元素的时候，经常会使用迭代器，但在迭代器遍历元素的过程中，如果集合的结构被改变的话，就会抛出异常，防止继续遍历。这就是所谓的快速失败机制

- ArrayList
- HashMap

### fail-safe（安全失败）
fail-safe的容器——CopyOnWriteArrayList,读写分离

## 语法糖

编译器有一步desuger，jvm不支持语法糖，是编译器支持的语法糖

Java 中最常用的语法糖主要有泛型、自动拆装箱、变长参数、枚举、内部类、增强 for 循环、try-with-resources 语法、lambda 表达式

## 序列化
transient 和 static 的规则
临时变量在序列化过程中将被忽略。
static 变量不会参与序列化。
如果在声明本身期间对值进行了初始化，则静态变量将被序列化。
如果一个变量同时包含 transient 和 static 关键字，并且该值在声明期间被初始化，则它将被序列化。因为在这里 transient 修饰符会被忽略，而 static 修饰符将执行操作。
final 变量将被序列化。
如果一个变量同时包含 final 和 transient 关键字，那么它就会被序列化。因为在这里 transient 修饰符会被忽略，而 final 修饰符将执行操作




# 数据库

type字段


- system：系统表，少量数据，往往不需要进行磁盘IO
- const：常量连接
- eq_ref：主键索引(primary key)或者非空唯一索引(unique not null)等值扫描
- ref：非主键非唯一索引等值扫描
- range：范围扫描
- index：索引树扫描
- ALL：全表扫描(full table scan)
 
由快到慢 `system > const > eq_ref > ref > range > index > ALL`




