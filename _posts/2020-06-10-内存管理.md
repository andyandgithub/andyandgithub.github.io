---
title: 内存管理
categories: study
tags : 操作系统复习
toc: true
---
# 存储器的层次管理
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200610222339879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MzQxOTE0,size_16,color_FFFFFF,t_70)
# 局部性原理
程序在执行时呈现出局部性规律，即在一较短的时间内，程序的执行仅局限于某个部分，相应地，它所访问的存储空间也局限于某个区域。程序在执行时，除了少部分的转移和过程调用指令以外，在大多数情况下是顺序执行的。过程调用将会使程序的执行轨迹由一部分内存区域转到另一部分内存区域。但研究表明，在大多数情况下，过程调用的深度都不超过5，这就是说，程序将会在一段时间内，局限在这些过程的范围内运行
程序中存在很多循环结构，它们虽然由少数指令构成，但多次执行
- 空间局部性 如果程序中的某条指令一旦执行，则不久后该指令可能再次执行，如果某个数据结构被访问，不久以后该数据结构可能再次被访问
- 时间局部性 一旦程序访问了某个单元，在不久之后，其附近的存储单元也将被访问
# 程序的装入和链接
## 程序的装入
### 绝对装入方式  
--单道批系统
### 可重定位装入方式 (静态重定位)
在程序**装入**时对目标程序中的指令和数据地址的修改过程称为*重定位*。
  1、编译程序使目标模块的起始地址从0开始。
  2、程序装入时，装入程序根据内存的使用情况将装入 
     模块装入到内存的某个位置，并对模块进行重定位。
  物理地址=有效逻辑地址+程序在内存中的起始地址。
### 动态运行时装入
cpu访存时进行即程序执行时进行逻辑地址→物理地址的转换 。(因为程序在活动过程中，在物理内存中的位置会发生变化，比如在具有对换功能的系统中）。
# 程序的链接
将编译后的目标模块装配成一个可执行的程序
## 静态链接 (static Linking)
 在程序运行前，用链接程序将目标模块链接成一个完整的装入模块 。
-  对相对地址进行修改：
- 变换外部调用符号：将每个模块中所用的外部调用符号，都变换为相对地址 
### 特点
1、存储开销大
2、程序开发不方便
3、程序运行快（相对于动态链接）

## 运行时动态链接 (Run-time Dynamic Linking)
### 特点
1、节省内存和外存空间；
2、方便程序开发；
3、程序运行时的速度慢了。
# 连续分配存储管理方式
## 单一连续分配
单用户，单任务的OS。把内存分为系统区和用户区。系统区仅供OS使用，用户区供用户使用。
用户程序+os内核
## 分区式分配
### 固定分区
1、管理简单
2、内存利用率低
- 分区大小相等
- 分区大小不等
固定分区分配表数据结构---结构体

### 动态分区
使用固定分区不利于提高内存利用率，故使用动态分区，根据进程的具体情况分配内存
#### 动态分区分配
数据结构
 - 空闲分区表 分区大小和起始地址
 - 空闲分区链   大小，起始地址，向前向后指针
#### 动态分区算法
#####  首次适应算法FF 
从链首开始，第一个大于需要的。
1、高地址部分大空闲区较多；
2、低地址部分容易留下小分区；
3、查找从低地址开始，查找开销较大。

##### 循环首次适应算法
该算法是由首次适应算法演变而形成的。在为进程分配内存空间时，不再每次从链首开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找，直至找到第一个能满足要求的空闲分区，并从中划出一块与请求的大小相等的内存空间分配给作业。为实现该算法，应设置一起始查找指针，以指示下一次起始查找的空闲分区，并采用循环查找方式
1、空闲区分布均匀
2、查找开销较小
3、容易使系统缺乏大空闲区

##### 最佳适应算法
该算法每次为作业分配内存，总是把既能满足要求、又是最小的空闲分区分配给作业，避免了“大材小用”。为了加速寻找，该算法要求将所有的空闲区，按其大小以**递增**的顺序形成一空闲区。这样，第一次找到的满足要求的空闲区，必然是最优的

1、避免大材小用，提高内存利用率；
2、容易留下难以利用的小空闲区。
### 分区分配操作
#### 内存回收流程 
   （1）释放内存
   （2）合并空闲区
仅回收区的前（后）面有相邻的空闲分区，把回收区与空闲分区R1合并成一个空闲分区，把空闲链表中与 R1对应的结点的分区起始（结尾）地址作为新空闲区的起始地址，将该结点的分区大小字段修改为空闲分区R1与回收区大小之和。
回收区的前、后都有相邻的空闲分区。要删除一个结点
前后都不相邻
#### 紧凑
把多个分散的小分区拼接成大分区的方法，被称为“拼接”或“紧凑” 

> 物理地址=逻辑地址+重定位寄存器中的地址 
# 不连续的内存分配
## 基本分页存储管理方式
### 基本概念
  1、页：将一个进程的逻辑地址空间（虚地址空间）分成若干个大小相等的片，称为页面或页。
  2、物理块：将内存空间分成与页相同大小的若干个存储块，称为物理块或页框或帧。
  3、分页存储：在为进程分配内存时，以物理块为单位将进 程中的若干页分别装入多个可以不相邻接的物理块中。
  4、页内碎片：进程的最后一页一般装不满一块，而形成不可利用的碎片，称为“页内碎片” 
### 地址结构
页号P、页内偏移量W。若用m位表示逻辑地址，页大小为2的n次幂，则用低n位表示页内偏移量w；用高m-n位表示页号P

指令逻辑地址 在pc中 
数据逻辑地址 指令的操作数部分
|  P(m-n)位 20位页号| W(n)位  12位页内偏移|
|--|--|
|  31——12|11——0|
以32位地址为例:可用0~11位表示页内偏移量n=12(页内212个单元=物理块大小=4KB);12-31位(20位)表示页号，共可有2^20个页面(1M个页)这种地址结构可以表示4G的逻辑地址空间

### 页表
页号到物理块号的映射，在内存中
页表起始地址与页表长度放在页表寄存器中

|页号|块号|
|--|--|
|0|2|

 块号*块大小+偏移
 *需要**两次**访存*
### 页大小的选择
1、在分页系统中页的大小是由机器的体系结构所决定的,亦即由硬件决定。（如：分页单元把低12位逻辑地址解释为页内偏移地址，则页大小就是4KB).
2、影响页大小设计的因素
管理内存的开销：
页太小，就会导致进程所需页多，页表过长，占用大量内存空间；同时，降低页换入换出效率。 
内存的利用率:
页小有利于提高内存的利用率，但存在(1)所述缺点，页大，可克服(1)的缺点，但页内碎片大，空间利用率降低。
页的大小
(1)、页大小是2的幂。
(2)、页大小在512B~1GB
(3)、现在硬件可以支持多种不同的页大小。页大小4KB 16KB 2MB 4MB 8MB 16MB等等
#### 地址变换过程
  1、进程执行，PCB块中页表起始地址送页表寄存器。
  2、CPU访问逻辑单元a。
  3、由分页地址变换机构自动将 a  分为页号和页内地址两部分
  4、由硬件检索机构搜索页表，得到物理块号（页框号）。
   搜索原理：页号对应的页表项地址=页表起始地址+页表项长度*页号。(页表项中存有物理块号)。
  5、生成物理地址。物理地址=物理块号*块大小+块内偏移地址

### 多级分页
需要很大的连续空间来存放页表，为了实现页表的离散存放，我们引入了两级或多级页表，将当前所需要的页表和外层页表放在内存中，其余页表放在外存，当所需页表不在内存时，产生中断，将请求的页表调入内存。
- 对页表所需的内存空间，采用离散分配方式,来解决难以找到一块连续的大内存空间以及页表的离散存放的问题。
- 只将当前需要的页表调入内存，其余的页表可以驻留在外存中
#### 二级分页
将页表再进行分页，使每个页表分页的大小与内存物理块的大小相同，并为它们编号。将这些页表分页分别放入不同的、不一定相邻的物理块中，为离散分配的页表分页再建立一张页表，称为外层页表（也叫页目录），在外层页表中的每个表项中记录了页表分页的物理块号

|p1| p2 |p3|
|--|--|--|
|外层页号|内层页号|页内偏移量|
|--|--|--|
1、对于给定的逻辑地址A,由p1，从外层页表中找到页 表分页所在的物理块号。
2、由p2，从页表分页中找到进程页所在的物理块号。
3、由A所在的进程页的物理块号*块大小+页内偏移得到A对应的物理地址。

### 快表

> 快表（转换后援缓冲TLB-Translation LookasideBuffer）,是为了提高CPU访存速度而采用的专用缓存，用来存放最近被访问过的页表项

CPU读写一个数据，需两次访问内存。第1次访存取物理块号，第2次取指令或数据。
为了提高访存速度引入快表，快表用于存放最近使用过的页表项，快表命中只需访存一次
- 每个cpu一个快表
- 是共享的
- 进程切换时要被刷新
- 最近被访问过的页表项
- 访问，替换是由硬件完成的
- 
### 反置页表
用反置页表，为每一个物理块设一个表项，表项中放进程号和页号，系统只维护一张反置页表。由于物理存储空间小于逻辑存储空间，所以使用反置页表减少了页表占用的内存空间。

	页的共享==代码共享 
## 分段存储管理
 作业的地址空间被划分成若干个段，每个段定义了一组逻辑信息，每个段的大小由相应的逻辑信息组的长度确定，段的大小不一样,每段的逻辑地址从0开始。
### 分段的逻辑地址
段的逻辑地址=段号+段内偏移地址
### 段表
代码段的起始地址放在段的地址寄存器里
1、系统为每个段分配一个连续存储区，各个段可以离散地放入内存不同的区域。
2、系统为每个进程建立一张段表，段表的每一个表项记录信息：段号、段长、该段的基址(起始地址)。
### 分段分页区别
  1、页是按物理单位划分的,段是按逻辑单位划分的。
  2、页的大小是固定的，段的大小不固定。
  3、分页的地址空间是一维的，分段的地址空间是二维的。

## 段页式存储管理 
将用户进程空间先划分成若干个段，每个段划分成若干个页，每个进程有一个段表，每个段都有一个页表。已知地址为段号和段内偏移。段页式存储管理的逻辑地址形式由段号、段内页号和页内地址三部分组成。每一段表项存放某个段的页表始址和页表长度
1、利用段号，找到某段的段表项，得到该段页表的首地址。
2、利用段内页号和由1得到的页表始址得到页表项。
3、由页表项得到页所在的物理块号。
4、 物理块号与页内地址得到某逻辑地址的物理
      地址。
# linux的伙伴系统
1、把所有的空闲页框分组为11个块链表，每个块链表分  别包含大小为1, 2, 4, 8, 16, 32, 64, 128, 256，512和1024个连续的页框 。
2、每个块的第一个页框的物理地址是该块大小的整数倍 。

内核试图把大小为b的一对空闲伙伴块合并为一个大小为2b的单独块。满足以下条件的两个块称为伙伴：
两个块具有相同的大小，记作b。
它们的物理地址是连续的。
      第一块的第一个页框的物理地址是2b块大小的倍数。该算法是迭代的，如果它成功合并所释放的块，它会试图合并2b的块来形成更大的块。

