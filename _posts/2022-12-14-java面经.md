---
layout: post
title: java面经
categories: study
tags : java
toc: true
---

# java基础
### equals与HashCode

> hashcode方法的作用

1.hashcode特性体现主要在它的查找快捷性，在Set和Map这种使用哈希表结构存储数据的集合中。HashCode方法的就大大体现了它的价值，主要用于在这些集合中确定对象在整个哈希表中存储的区域。
2.如果两个对象相同，则着两个对象的equals方法返回的值一定为true，两个对象的HashCode方法返回的值也一定相同。
3.如果两个对象返回的HashCode的值相同，但不能够说明这两个对象的equals方法返回的值就一定为true，只能说明这两个对象在存储在哈希表中的一个桶中

> 如果一个对象equals方法被重写，那么该对象的HashCode方法也应该被重写

在java中equals方法用于判断两个对象是否相等，而HashCode方法在java中主要由于哈希算法中的寻域的功能（也就是寻找数据应该存储的区域的）。在类似于set和map集合的结构中，java为了提高在集合中查询匹配元素的效率问题，引入了哈希算法，通过某种算法及我们的HashCode方法得到对象的hash码，再通过hash码推算出数据应该存储的位置。然后再进行equals操作进行匹配，减少了比较次数，提高了效率。在集合做了优化之后进行判断元素相等的过程是这样的，首先判断两个对象的HashCode方法返回的值是否相等，如果相等然后再判断两个对象的equals方法，如果HashCode方法返回的值不相等，则直接会认为两个对象不相等，不进行equals方法的判断。有这样一个场景有两个Student对象，equals方法认为如果两个对象的学号相同则认为这两个对象相同。可是如果没有重写HashCode方法只重写了equals方法，此刻并不能实现我们的要求，它首先会判断HashCode方法返回的值是否相等，由于我们没有重写HashCode方法，此时返回的值是不同的，因此不会去判断我们重写的equals方法。而如果重写HashCode方法不重写equals方法也是同样的效果，不重写equals方法实际是调用Object方法中的equals方法，判断的是两个对象的堆内地址。而我们重写的HashCode方法认为相等的两个对象在equals方法处并不相等。因此重写equals方法时一定也要重写HashCode方法，重写HashCode方法时也应该重写equals方法

> 为什么equals方法不相等而HashCode方法返回的值却有可能相同呢？

A：HashCode方法实际上是通过一种算法得到一个对象的hash码，这个hash码是用来确定该对象在哈希表中具体的存储区域的。返回的hash码是int类型的所以它的数值范围为[-2147483648-+2147483647]之间的，而超过这个范围，实际会产生溢出，溢出之后的值实际在计算机中存的也是这个范围的。比如最大值2147483647+1之后并不是在计算机中不存储了，它实际在计算机中存储的是-2147483648。在java中对象可以有很多很多通过new关键字来产生。而hash码也是通过特定算法得到的，所以很难或者说几乎没有什么算法在这个范围内在这个情况下不会不产生相同的hash码的。也就是说在上述情况下肯定是会发生哈希碰撞的，因此不同对象可能有相同的HashCode的返回值。也有人说Object方法中的HashCode方法是通过内存地址得来的，是唯一的。可是HashCode方法是共有的，也就意味着它是可以被程序员重写的。因此不同环境下实现HashCode的算法可能不同。因此equals方法返回结果不相等，而HashCode方法返回的值却有可能相同！

### HashMap的线程安全问题
>HashMap是线程不安全的

多个相同key的同时插入，多个线程同时检测到需要扩容，HashMap 在并发执行 put 操作时会引起死循环，导致 CPU 利用率接近100%。因为多线程会导致 HashMap 的 Node 链表形成环形数据结构，一旦形成环形数据结构，Node 的 next 节点永远不为空，就会在获取 Node 时产生死循环

> 如何在线程安全的时候使用

换用线程安全的HasHMap
Hashtable
ConcurrentHashMap
Synchronized Map

### HashMap的链表和红黑树转化问题
>HashMap 链表和红黑树的转换

红黑树的平均查找长度是log(n)，长度为8，查找长度为log(8)=3，链表的平均查找长度为n/2，当长度为8时，平均查找长度为8/2=4，这才有转换成树的必要；链表长度如果是小于等于6，6/2=3，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。

还有选择6和8的原因是：

中间有个差值7可以防止链表和树之间频繁的转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个`HashMap`不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低下.

链表转换为红黑树的最终目的，是为了解决在map中元素过多，hash冲突较大，而导致的读写效率降低的问题。在源码的putVal方法中，有关红黑树结构化的分支为：

>HashMap的底层

HashMap 的底层实现是数组+链表+红黑树的形式的，同时它的数组的默认初始容量是 16、***扩容因子***为 0.75，每次采用 2 倍的扩容。

在 JDK1.7 以及前是在头结点插入的，在 JDK1.8 之后是在尾节点插入的
### HashTable与ConcurrentHashMap
>效率低下的HashTable容器

`HashTable`容器使用`synchronized`来保证线程安全，但在线程竞争激烈的情况下`HashTable`的效率非常低下。因为当一个线程访问`HashTable`的同步方法时，其他线程访问`HashTable`的同步方法时，可能会进入阻塞或轮询状态。如线程1使用`put`进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低

>ConcurrentHashMap的锁分段技术

`HashTable`容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问`HashTable`的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是`ConcurrentHashMap`所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。

`ConcurrentHashMap`是由`Segment`数组结构和`HashEntry`数组结构组成。`Segment`是一种可重入锁`ReentrantLock`，在`ConcurrentHashMap`里扮演锁的角色，`HashEntry`则用于存储键值对数据。一个`ConcurrentHashMap`里包含一个`Segment`数组，`Segment`的结构和HashMap类似，是一种数组和链表结构， 一个`Segment`里包含一个`HashEntry`数组，每个`HashEntry`是一个链表结构的元素， 每个Segment守护着一个`HashEntry`数组里的元素,当对`HashEntry`数组的数据进行修改时，必须首先获得它对应的Segment锁。


如何扩容。扩容的时候首先会创建一个两倍于原容量的数组，然后将原数组里的元素进行再hash后插入到新的数组里。为了高效`ConcurrentHashMap`不会对整个容器进行扩容，而只对某个`segment`进行扩容

如果我们要统计整个`ConcurrentHashMap`里元素的大小，就必须统计所有`Segment`里元素的大小后求和。`Segment`里的全局变量count是一个volatile变量，那么在多线程场景下，我们是不是直接把所有Segment的count相加就可以得到整个`ConcurrentHashMap`大小了呢？不是的，虽然相加时可以获取每个`Segment`的count的最新值，但是拿到之后可能累加前使用的count发生了变化，那么统计结果就不准了。所以最安全的做法，是在统计size的时候把所有`Segment`的put，remove和clean方法全部锁住，但是这种做法显然非常低效。

因为在累加count操作过程中，之前累加过的count发生变化的几率非常小，所以ConcurrentHashMap的做法是先尝试2次通过不锁住Segment的方式来统计各个Segment大小，如果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小。

那么`ConcurrentHashMap`是如何判断在统计的时候容器是否发生了变化呢？使用modCount变量，在put , remove和clean方法里操作元素前都会将变量modCount进行加1，那么在统计size前后比较modCount是否发生变化，从而得知容器的大小是否发生变化


# 数据库
## acis
原子性、一致性、隔离性、持久性。
# 框架
### 线程池的参数和创建线程的方式
> 线程池的参数

```java
public ThreadPoolExecutor(
    int corePoolSize,
    int maximumPoolSize,
    loog keepAliveTime,
    TimeUnit unit,
    BlockingQueue<Runnable> workQueue,
    ThreadFactory threadFacrory,
    RejectedExecutionHandler handler

)
```
线程池的构造函数有7个参数，分别是`corePoolSize`、`maximumPoolSize`、`keepAliveTime`、`unit`、`workQueue`、`threadFactory`、`handler`

- 一、`corePoolSize` 线程池核心线程大小

线程池中会维护一个最小的线程数量，即使这些线程处理空闲状态，他们也不会被销毁，除非设置了`allowCoreThreadTimeOut`。这里的最小线程数量即是corePoolSize。任务提交到线程池后，首先会检查当前线程数是否达到了`corePoolSize`，如果没有达到的话，则会创建一个新线程来处理这个任务。

- 二、`maximumPoolSize` 线程池最大线程数量

当前线程数达到corePoolSize后，如果继续有任务被提交到线程池，会将任务缓存到工作队列（后面会介绍）中。如果队列也已满，则会去创建一个新线程来出来这个处理。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即由maximunPoolSize指定。

- 三、`keepAliveTime` 空闲线程存活时间

一个线程如果处于空闲状态，并且当前的线程数量大于`corePoolSize`，那么在指定时间后，这个空闲线程会被销毁，这里的指定时间由keepAliveTime来设定

- 四、`unit` 空闲线程存活时间单位

`keepAliveTime`的计量单位

- 五、`workQueue` 工作队列

新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。jdk中提供了四种工作队列：

 - `①ArrayBlockingQueue`

基于数组的有界阻塞队列，按FIFO排序。新任务进来后，会放到该队列的队尾，有界的数组可以防止资源耗尽问题。当线程池中线程数量达到`corePoolSize`后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。如果队列已经是满的，则创建一个新线程，如果线程数量已经达到`maxPoolSize`，则会执行**拒绝策略**。

 - `②LinkedBlockingQuene`

基于链表的无界阻塞队列（其实最大容量为`Interger.MAX`），按照`FIFO`排序。由于该队列的近似无界性，当线程池中线程数量达到`corePoolSize`后，再有新任务进来，会一直存入该队列，而基本不会去创建新线程直到maxPoolSize（很难达到Interger.MAX这个数），因此使用该工作队列时，参数`maxPoolSize`其实是不起作用的。

 - `③SynchronousQuene`

一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，不会缓存，而是直接被调度执行该任务，如果没有可用线程，则创建新线程，如果线程数量达到maxPoolSize，则执行拒绝策略。

 - `④PriorityBlockingQueue`

具有优先级的无界阻塞队列，优先级通过参数Comparator实现。

- 六、`threadFactory` 线程工厂

创建一个新线程时使用的工厂，可以用来设定线程名、是否为`daemon`线程等等

- 七、`handler` 拒绝策略

当工作队列中的任务已到达最大限制，并且线程池中的线程数量也达到最大限制，这时如果有新任务提交进来，该如何处理呢。这里的拒绝策略，就是解决这个问题的，jdk中提供了4中拒绝策略：

 - `①CallerRunsPolicy`

该策略下，在调用者线程中直接执行被拒绝任务的run方法，除非线程池已经shutdown，则直接抛弃任务。

 - `②AbortPolicy`

该策略下，直接丢弃任务，并抛出RejectedExecutionException异常。

 - `③DiscardPolicy`

该策略下，直接丢弃任务，什么都不做。

 - `④DiscardOldestPolicy`

该策略下，抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列
> 创建线程的方式

- 继承`Thread`
  - 重写 `run` 方法。
  - 然后创建这个子类对象，并调用 `start` 方法启动线程
- `Runnable` ，并实现 `run` 方法，也可以创建一个线程。
  - 首先定义一个类实现 `Runnable` 接口，并实现 `run` 方法。
  - 然后创建 `Runnable` 实现类对象，并把它作为 `target` 传入 `Thread` 的构造函数中
  - 最后调用 `start` 方法启动线程。
- 实现 `Callable` 接口，并结合 `Future` 实现
  - 首先定义一个 `Callable` 的实现类，并实现 `call` 方法。call 方法是带返回值的。
  - 然后通过 `FutureTask` 的构造方法，把这个 `Callable` 实现类传进去。
  - 把 `FutureTask` 作为 `Thread` 类的 `target` ，创建 `Thread` 线程对象。
  - 通过 `FutureTask` 的 `get`方法获取线程的执行结果。
- 通过线程池创建线程
  - 此处用 JDK 自带的 `Executors` 来创建线程池对象。
  - 首先，定一个 `Runnable` 的实现类，重写 `run` 方法。
  - 然后创建一个拥有固定线程数的线程池。
  - 最后通过 `ExecutorService` 对象的 `execute` 方法传入线程对象


# 服务器
# 网络
### tcp 三次握手
> TCP三次握手过程

TCP(Transmission Control Protocol)　传输控制协议

tcp的6种标志位的分别代表：
- `SYN`(synchronous建立联机)
- `ACK`(acknowledgement 确认)
- `PSH`(push传送)
- `FIN`(finish结束)
- `RST`(reset重置)
- `URG`(urgent紧急)
- `Sequence number`(顺序号码)
- `Acknowledge number`(确认号码)

客户端TCP状态迁移：
- `CLOSED`->`SYN_SENT`->`ESTABLISHED`->`FIN_WAIT_1`->`FIN_WAIT_2`->`TIME_WAIT`->`CLOSED`

服务器TCP状态迁移：
- `CLOSED`->`LISTEN`->`SYN`收到->`ESTABLISHED`->`CLOSE_WAIT`->`LAST_AC`K->`CLOSED`

- `LISTEN` - 侦听来自远方TCP端口的连接请求；
- `SYN-SENT` -在发送连接请求后等待匹配的连接请求；
- `SYN-RECEIVED` - 在收到和发送一个连接请求后等待对连接请求的确认；
- `ESTABLISHED`- 代表一个打开的连接，数据可以传送给用户；
- `FIN-WAIT-1` - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；
- `FIN-WAIT-2` - 从远程TCP等待连接中断请求；
- `CLOSE-WAIT` - 等待从本地用户发来的连接中断请求；
- `CLOSING` -等待远程TCP对连接中断的确认；
- `LAST-ACK` - 等待原来发向远程TCP的连接中断请求的确认；
- `TIME-WAIT` -等待足够的时间以确保远程TCP接收到连接中断请求的确认；
- `CLOSED` - 没有任何连接状态；

（1）第一次握手：建立连接时，客户端A发送SYN包（SYN=j）到服务器B，并进入SYN_SEND状态，等待服务器B确认。

（2）第二次握手：服务器B收到SYN包，必须确认客户A的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器B进入SYN_RECV状态。

（3）第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK（ACK=k+1），此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。

完成三次握手，客户端与服务器开始传送数据。

确认号：其数值等于发送方的发送序号 +1(即接收方期望接收的下一个序列号)。


>TCP发数据过程中必须按顺序接收吗

有序号，是没必要按顺序接受的

>四次挥手，关闭连接

由于TCP连接是***全双工***的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

CP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。

（1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。

（2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。

（3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A。

（4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。

一个TCP连接存在双向的读写通道。

简单说来是 “先关读，后关写”，一共需要四个阶段。以客户机发起关闭连接为例：
- 1.服务器读通道关闭
- 2.客户机写通道关闭
- 3.客户机读通道关闭
- 4.服务器写通道关闭

# linux
# 算法


# 其他知识


框架-》模板-》背景

测试用例，自己写测试考虑测试用例，考虑代码质量，覆盖率   通过测试用例提升自己的代码质量

代码上线，部署到分布式服务器或者云上服务器 需要有一个前端展示界面

做压力测试，比如能够承载多少访问量


难点 
注入fgc的bug

并发的问题