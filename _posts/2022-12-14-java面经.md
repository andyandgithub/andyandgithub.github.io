---
layout: post
title: java面经
categories: study
tags : java
toc: true
---

# java基础
### equals与HashCode

> hashcode方法的作用

hashcode特性体现主要在它的查找快捷性，在Set和Map这种使用哈希表结构存储数据的集合中。HashCode方法的就大大体现了它的价值，主要用于在这些集合中确定对象在整个哈希表中存储的区域。
2.如果两个对象相同，则着两个对象的equals方法返回的值一定为true，两个对象的HashCode方法返回的值也一定相同。
3.如果两个对象返回的HashCode的值相同，但不能够说明这两个对象的equals方法返回的值就一定为true，只能说明这两个对象在存储在哈希表中的一个桶中

> 如果一个对象equals方法被重写，那么该对象的HashCode方法也应该被重写

在java中equals方法用于判断两个对象是否相等，而HashCode方法在java中主要由于哈希算法中的寻域的功能（也就是寻找数据应该存储的区域的）。在类似于set和map集合的结构中，java为了提高在集合中查询匹配元素的效率问题，引入了哈希算法，通过某种算法及我们的HashCode方法得到对象的hash码，再通过hash码推算出数据应该存储的位置。然后再进行equals操作进行匹配，减少了比较次数，提高了效率。在集合做了优化之后进行判断元素相等的过程是这样的，首先判断两个对象的HashCode方法返回的值是否相等，如果相等然后再判断两个对象的equals方法，如果HashCode方法返回的值不相等，则直接会认为两个对象不相等，不进行equals方法的判断。有这样一个场景有两个Student对象，equals方法认为如果两个对象的学号相同则认为这两个对象相同。可是如果没有重写HashCode方法只重写了equals方法，此刻并不能实现我们的要求，它首先会判断HashCode方法返回的值是否相等，由于我们没有重写HashCode方法，此时返回的值是不同的，因此不会去判断我们重写的equals方法。而如果重写HashCode方法不重写equals方法也是同样的效果，不重写equals方法实际是调用Object方法中的equals方法，判断的是两个对象的堆内地址。而我们重写的HashCode方法认为相等的两个对象在equals方法处并不相等。因此重写equals方法时一定也要重写HashCode方法，重写HashCOde方法时也应该重写equals方法

> 为什么equals方法不相等而HashCode方法返回的值却有可能相同呢？

A：HashCode方法实际上是通过一种算法得到一个对象的hash码，这个hash码是用来确定该对象在哈希表中具体的存储区域的。返回的hash码是int类型的所以它的数值范围为[-2147483648-+2147483647]之间的，而超过这个范围，实际会产生溢出，溢出之后的值实际在计算机中存的也是这个范围的。比如最大值2147483647+1之后并不是在计算机中不存储了，它实际在计算机中存储的是-2147483648。在java中对象可以有很多很多通过new关键字来产生。而hash码也是通过特定算法得到的，所以很难或者说几乎没有什么算法在这个范围内在这个情况下不会不产生相同的hash码的。也就是说在上述情况下肯定是会发生哈希碰撞的，因此不同对象可能有相同的HashCode的返回值。也有人说Object方法中的HashCode方法是通过内存地址得来的，是唯一的。可是HashCode方法是共有的，也就意味着它是可以被程序员重写的。因此不同环境下实现HashCode的算法可能不同。因此equals方法返回结果不相等，而HashCode方法返回的值却有可能相同！

### HashMap的线程安全问题
>HashMap是线程不安全的

多个相同key的同时插入，多个线程同时检测到需要扩容，HashMap 在并发执行 put 操作时会引起死循环，导致 CPU 利用率接近100%。因为多线程会导致 HashMap 的 Node 链表形成环形数据结构，一旦形成环形数据结构，Node 的 next 节点永远不为空，就会在获取 Node 时产生死循环

> 如何在线程安全的时候使用

换用线程安全的HasMap
Hashtable
ConcurrentHashMap
Synchronized Map


# 数据库
## acis
原子性、一致性、隔离性、持久性。
# 框架
# 服务器
# 网络
### tcp 三次握手
> TCP三次握手过程

TCP(Transmission Control Protocol)　传输控制协议

tcp的6种标志位的分别代表：
- `SYN`(synchronous建立联机)
- `ACK`(acknowledgement 确认)
- `PSH`(push传送)
- `FIN`(finish结束)
- `RST`(reset重置)
- `URG`(urgent紧急)
- `Sequence number`(顺序号码)
- `Acknowledge number`(确认号码)

客户端TCP状态迁移：
- `CLOSED`->`SYN_SENT`->`ESTABLISHED`->`FIN_WAIT_1`->`FIN_WAIT_2`->`TIME_WAIT`->`CLOSED`

服务器TCP状态迁移：
- `CLOSED`->`LISTEN`->`SYN`收到->`ESTABLISHED`->`CLOSE_WAIT`->`LAST_AC`K->`CLOSED`

- `LISTEN` - 侦听来自远方TCP端口的连接请求；
- `SYN-SENT` -在发送连接请求后等待匹配的连接请求；
- `SYN-RECEIVED` - 在收到和发送一个连接请求后等待对连接请求的确认；
- `ESTABLISHED`- 代表一个打开的连接，数据可以传送给用户；
- `FIN-WAIT-1` - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；
- `FIN-WAIT-2` - 从远程TCP等待连接中断请求；
- `CLOSE-WAIT` - 等待从本地用户发来的连接中断请求；
- `CLOSING` -等待远程TCP对连接中断的确认；
- `LAST-ACK` - 等待原来发向远程TCP的连接中断请求的确认；
- `TIME-WAIT` -等待足够的时间以确保远程TCP接收到连接中断请求的确认；
- `CLOSED` - 没有任何连接状态；

（1）第一次握手：建立连接时，客户端A发送SYN包（SYN=j）到服务器B，并进入SYN_SEND状态，等待服务器B确认。

（2）第二次握手：服务器B收到SYN包，必须确认客户A的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器B进入SYN_RECV状态。

（3）第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK（ACK=k+1），此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。

完成三次握手，客户端与服务器开始传送数据。

确认号：其数值等于发送方的发送序号 +1(即接收方期望接收的下一个序列号)。


>TCP发数据过程中必须按顺序接收吗

有序号，是没必要按顺序接受的

>四次挥手，关闭连接

由于TCP连接是***全双工***的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

CP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。

（1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。

（2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。

（3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A。

（4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。

一个TCP连接存在双向的读写通道。

简单说来是 “先关读，后关写”，一共需要四个阶段。以客户机发起关闭连接为例：
- 1.服务器读通道关闭
- 2.客户机写通道关闭
- 3.客户机读通道关闭
- 4.服务器写通道关闭

# linux
# 算法


# 其他知识


框架-》模板-》背景

测试用例，自己写测试考虑测试用例，考虑代码质量，覆盖率   通过测试用例提升自己的代码质量

代码上线，部署到分布式服务器或者云上服务器 需要有一个前端展示界面

做压力测试，比如能够承载多少访问量


难点 
注入fgc的bug

并发的问题