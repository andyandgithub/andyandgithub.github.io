---
layout: post
title: 面试笔试记录
categories: study
tags : java
toc: true
---

# 笔试
## 某小厂
1. 冒泡
## 3-18美团笔试

1. 一道题目表示在一个矩形中有若干个点，使用一个小矩形（给出长宽，位置不定），看能够使用这个小矩形能够框住最多多少点。
2. 一道移动窗口的题目，求子数组中的种类不超过k的最大长度
3. 回文串，最多两次更改，求将给定字串转化为最小字母序列回文字串的结果。
4. x元钱，y个打折券，n个商品，n个商品的原件以及打折价格，每个商品最多买一个，可不买，可使用一张打折券打折买，可原价卖，求买最多商品的情况下，最小花费
5. 图算法。每个节点对周围节点有辐射能量#美团#，给出每个节点的辐射范围，给出多个表示有边连接的[x,y]数组，每个边距离均为1
节点到本身的距离为0.求每个节点的能量数



# 面试
## 某厂
- valitile
## 东方通
### 3.22
- ***为什么使用druid***
- ***spring的自动配置***
- ***自我介绍***
## 罗科仕
### 3.23一面
- spring
  - spring介绍
  - spring mvc的流程 dispatcherservlet
  - 
- mysql
  - mysql的事务等级，异常
  - mysql的索引
    - 索引分类
  - 为什么使用b+树而不是二叉树
    - 二叉树数据量过大的时候查找效率会类似于链表
- redis
  - ***redis的数据类型***
  - ***压缩表和跳跃表***
### 3.23二面
- RuntimeException与其他exception的区别
  - RuntimeException是非检查异常。RuntimeException是可以不去做任何处理的，直接抛给JVM。也就是可以不用try,catch去处理，可以不用throw，在方法上不用throws声明，因为JAVA所有的方法都默认throws了RuntimeException。非RuntimeException必须被try，catch或者throw。
- Exception可以序列化吗
  - exception继承于throwable throwable实现了Serializable 接口

## 3.24阿里一面
- ConcurrentHashMap
  - 数据结构
  - 如何做到线程安全
    - cas（无锁算法）+synchronized
    - synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发
    - CAS：在判断数组中当前位置为null的时候，使用CAS来把这个新的Node写入数组中对应的位置
    - synchronized ：当数组中的指定位置不为空时，通过加锁来添加这个节点进入数组(链表<8)或者是红黑树（链表>=8）JVM对CAS的支持， 由于Java程序运行在JVM上，所以应对不同的硬件体系架构的处理则需要JVM来实现。在不支持CAS操作的硬件上，jvm将使用自旋锁来实现
- cas
  - cas为什么会比synchronized性能高
    - 硬件加持，现代大多数处理器都从硬件层面通过一些列指令实现CompareAndSwap(比较并交换)同步原语，进而使操作系统和JVM可以直接使用这些指令实现锁和并发的数据结构。我们可以简单认为，CAS是将比较和交换合成是一个原子操作。
  - ABA问题怎么解决
    - 添加版本号，jdk的一些原子类添加时间戳作为
  - cas的操作是原子性的
    - 是一种原子操作，通过使用硬件级别的支持来保证***原子性***。 当多个线程同时对同一个变量进行操作时，CAS操作可以保证在同一时刻只有一个线程能够实际执行操作，另外的线程则需要等待或者重试，从而保证了数据的一致性
    - 总线锁定和缓存锁定
- valitile
  - 为什么java会存在内存可见性的问题
    - 线程间的对于共享变量的可见性问题不是直接由多核引起的，而是由多缓存引起的。如果所有个核心都只用一个缓存，那么也就不存在内存可见性问题了。每个核心都会将自己需要的数据读到独占缓存中，数据修改后也是写入到缓存中，然后等待刷入到主存中。所以会导致有些核心读取的值是一个过期的值
    - valitile的作用
      - 禁止指令重排
- jvm的垃圾回收机制
  - 分代算法
    - 新生代中年龄超过某个阈值的进入到老年代
    - 大对象需要连续的内存空间，而新生代为了安放大对象可能需要多次进行GC，增加开销，新生代种伊甸园区和幸存者区常采用复制算法，需要经常复制对象到不同的区域，而大对象在复制时开销较大。因此大对象可以直接进入老年代
  - 逃逸分析
    - 逃逸分析是一种技术，Java Hotspot Server Compiler通过它可以分析新对象的使用范围，并决定是否在Java ***堆上*** 分配它。
    - 一种确定指针动态范围的静态分析，它可以分析在程序的哪些地方可以访问到指针。
    - 一种典型的对象逃逸就是：对象被复制给成员变量或者静态变量，可能被外部使用，此时变量就发生了逃逸。
    - JVM通过逃逸分析，能够分析出新对象的使用范围，从而决定新对象是否要在堆上进行分配。
    - 逃逸分析的优点总体上来说可以分为三个：对象可能分配在栈上、分离对象或标量替换、消除同步锁
    - Java中的对象不一定是在堆上分配的，因为JVM通过逃逸分析，能够分析出一个新对象的使用范围，并以此确定是否要将这个对象分配到堆上。
- 关系型数据库和非关系型数据库的区别
  - 关系型数据库的优点
    - 采用二维表结构非常贴近正常开发逻辑（关系型数据模型相对层次型数据模型和网状型数据模型等其他模型来说更容易理解）；
    - 支持通用的SQL（结构化查询语言）语句；
    - 丰富的完整性大大减少了数据冗余和数据不一致的问题。并且全部由表结构组成，文件格式一致；
    - 可以用SQL句子多个表之间做非常繁杂的查询；
    - 关系型数据库提供对事务的支持，能保证系统中事务的正确执行，同时提供事务的恢复、回滚、并发控制和死锁问题的解决。
    - 数据存储在磁盘中，安全可靠
  - 关系型数据库的缺点
    - 高并发读写能力差：网站类用户的并发性访问非常高，而一台数据库的最大连接数有限，且硬盘 I/O 有限，不能满足很多人同时连接。
    - 海量数据情况下读写效率低：对大数据量的表进行读写操作时，需要等待较长的时间等待响应。
    - 可扩展性不足：不像web server和app server那样简单的添加硬件和服务节点来拓展性能和负荷工作能力。
    - 数据模型灵活度低：关系型数据库的数据模型定义严格，无法快速容纳新的数据类型（需要提前知道需要存储什么样类型的数据
  - 非关系型数据库的优点
    - 关系型数据库存储数据的格式可以是 key-value 形式、文档形式、图片形式等。使用灵活，应用场景广泛，而关系型数据库则只支持基础类型。
    - 速度快，效率高。 NoSQL 可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘。
    - 海量数据的维护和处理非常轻松，成本低。
    - 非关系型数据库具有扩展简单、高并发、高稳定性、成本低廉的优势。
    - 可以实现数据的分布式处理。
  - 非关系型数据库存在的不足:
    - 非关系型数据库暂时不提供 SQL 支持，学习和使用成本较高。
    - 非关系数据库没有事务处理，无法保证数据的完整性和安全性。适合处理海量数据，但是不一定安全。
    - 功能没有关系型数据库完善。
    - 复杂表关联查询不容易实现
- mysql语句的执行步骤
  1. 语法分析，分析语句的语法是否符合规范，衡量语句中各表达式的意义。
  2. 语义分析，检查语句中涉及的所有数据库对象是否存在，且用户有相应的权限。
  3. 视图转换，将涉及视图的查询语句转换为相应的对基表查询语句。
  4. 表达式转换， 将复杂的 SQL 表达式转换为较简单的等效连接表达式。
  5. 选择优化器，不同的优化器一般产生不同的“执行计划”
  6. 选择连接方式， ORACLE 有三种连接方式，对多表连接 ORACLE 可选择适当的连接方式。
  7. 选择连接顺序， 对多表连接 ORACLE 选择哪一对表先连接，选择这两表中哪个表做为源数据表。
  8. 选择数据的搜索路径，根据以上条件选择合适的数据搜索路径，如是选用全表搜索还是利用索引或是其他的方式。
  9. 运行“执行计划"
  10. 执行顺序 
    - FROM子句组装数据（包括通过ON进行连接）；
    - WHERE子句进行条件筛选；
    - GROUP BY分组 ；
    - 使用聚集函数进行计算；
    - HAVING筛选分组；
    - 计算所有的表达式；
    - SELECT 的字段；
    - ORDER BY排序；
    - LIMIT筛选。
-  分布式锁怎么实现
   -  基于redis
   -  基于数据库
      -  -  基于数据库的分布式锁, 常用的一种方式是使用表的唯一约束特性。当往数据库中成功插入一条数据时, 代表只获取到锁。将这条数据从数据库中删除，则释放送。
      -  没有失效时间。 解决方案:设置一个定时处理, 定期清理过期锁 。单点问题。 解决方案: 弄几个备份数据库，数据库之前双向同步，一旦挂掉快速切换到备库上
   -  基于zookeeper

- innodb的索引使用b+树
- b树和b+树的关系
  - 为什么索引使用b+树
- redis
  - redis和数据库的一致性操作
    - 延时双删
- 线程池的工作原理
  - Java线程池主要用于管理线程组及其运行状态，以便Java虚拟机更好的利用CPU资源。Java线程池的工作原理为：JVM先根据用户给定的参数创建一定数量的可运行的线程任务，并将其放入队列中，在线程创建后启动这些任务，如果正在运行的线程数量超过了最大线程数量(用户设置的线程池大小)，则超出数量的线程排队等候，在有任务执行完毕后，线程池调度器会发现有可用的线程，进而再次从队列中取出任务并执行。
  - 线程池的主要作用是线程复用、线程资源管理、控制操作系统的最大并发数，以保证系统高效（通过线程资源复用实现）且安全（通过控制最大线程并发数实现）地运行。
- 阻塞队列
  - 阻塞队列 (BlockingQueue)是Java util.concurrent包下重要的数据结构，BlockingQueue提供了线程安全的队列访问方式：当阻塞队列进行插入数据时，如果队列已满，线程将会阻塞等待直到队列非满；从阻塞队列取数据时，如果队列已空，线程将会阻塞等待直到队列非空。并发包下很多高级同步类的实现都是基于BlockingQueue实现的。
- 线程的阻塞和唤醒
  - 线程的自发阻塞
    - 线程睡眠：Thread.sleep (long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。
    - 线程等待：Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait() 一样。wait() 和 notify() 方法：两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 `notify()` 被调用.
    - 线程礼让，Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。yield() 使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程.
    - 线程自闭，join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。
    - suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。Thread中suspend()和resume()两个方法在JDK1.5中已经废除，不再介绍。因为有死锁倾向