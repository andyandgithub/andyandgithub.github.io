---
layout: post
title: Java常用以及数据结构
categories: study
tags : java
toc: true
---
# 常用
## `contains`函数
包含
`List.contains()`和`ArrayList.contains()`都是使用的`Object.equals(object)`
而`Object.equals()`使用的是`this==objecct`比较的而是地址不是值

在`Object`中`equals`和`==`没有任何的区别
`String`重写了`equals`的方法

```java
Person p1 = new Person(1, "张三", 20);
Person p2 = new Person(1, "张三", 20);
System.out.println("比较p1=p2  ：" + (p1==p2));//false
System.out.println("比较p1.equels(p2) :" + (p1.equals(p2)));//false

String s1 = "C博客";
String s2 = "C博客";//两个常量
System.out.println("比较s1=s2  ：" + (s1==s2));//true
System.out.println("比较s1.equels(s2) :" + (s1.equals(s2)));//true

String s3 = new String("C博客");
String s4 = new String("C博客");
System.out.println("比较s3=s4  ：" + (s3==s4));//false
System.out.println("比较s3.equels(s4) :" + (s3.equals(s4)));//true
```
字符串`String`会当作*常量*处理
对于s1,s2
String s1 = “C博客”;
1.JVM会首先去常量池中查找是否有”C博客”这个字符串常量，有的话就返回引用地址给s1，没有就将”C博客”字符串常量放入常量池，
2.再返回地址给s1，
3.s2也是”C博客”字符串常量，因此JVM会将常量池中的该字符串引用地址返回给s2，因此实际上s1和s2指向的是同一个字符串字面量，所以才会为true
对于s3,s4
1.JVM首先会去常量池中查找有没有一个叫“C博客”的字符串常量，如果有，就获取它的引用地址，没有就在常量池(jdk1.7好像常量池也在堆内)中创建一个再返回引用地址；
2.然后遇到了new，就会在堆内存中分配一块内存存储一个叫`new String()`的对象，该对象里就含有常量池中那个字符串的引用地址；
3.在栈内存中创建一个叫s3的变量，指向堆内存中的刚刚创建的对象；
4.对s4分配内存的时候，也会先去常量池中查找，因为s3已经在常量池中创建了”C博客”的字符串常量，因此就只会返回该字符串的引用地址；
5.在堆中又分配一块内存给一个叫`new String()`的对象，该对象里也有指向常量池中”C博客”字符串常量的地址；
6.在栈内存中创建一个叫s4的变量，指向堆内存中的刚刚创建的对象。
## 获取时间

```java
System.currentTimeMillis()
//1650093029236
```
## 文件操作

### 创建文件

```java
String path = "./a.properties";
File file = new File(path);
System.out.println(file.getParentFile());
if (!file.getParentFile().exists()) {
    boolean result = file.getParentFile().mkdirs();
    if (!result) {
        System.out.println("创建失败");
    }
}

```

### 打开文件

```java
try { // 防止文件建立或读取失败，用catch捕捉错误并打印，也可以throw
 
			/* 读入TXT文件 */
			String pathname = "./addressbook.txt"; // 绝对路径或相对路径都可以，这里是绝对路径，写入文件时演示相对路径
			File filename = new File(pathname); // 要读取以上路径的input。txt文件
			InputStreamReader reader = new InputStreamReader(
					new FileInputStream(filename)); // 建立一个输入流对象reader
			BufferedReader br = new BufferedReader(reader); // 建立一个对象，它把文件内容转成计算机能读懂的语言
			String line = "";
			line = br.readLine();
			while (line != null) {
				line = br.readLine(); // 一次读入一行数据
                System.out.println(line);
			}

 
		} catch (Exception e) {
            System.out.println(e);
			e.printStackTrace();
		}


```


### 写入文件

```java

try { // 防止文件建立或读取失败，用catch捕捉错误并打印，也可以throw
 
		
 
			/* 写入Txt文件 */
			File writename = new File("./addressbook.txt"); // 相对路径，如果没有则要建立一个新的output。txt文件
			writename.createNewFile(); // 创建新文件
			BufferedWriter out = new BufferedWriter(new FileWriter(writename));//覆写
			//BufferedWriter out = new BufferedWriter(new FileWriter(writename,true));//是否追加
			out.write("我会写入文件啦\r\n"); // \r\n即为换行
			out.flush(); // 把缓存区内容压入文件
			out.close(); // 最后记得关闭文件
 
		} catch (Exception e) {
            System.out.println(e);
			e.printStackTrace();
		}

```


## java读取屏幕输入


```java
import java.util.Scanner;
Scanner scanner = new Scanner(System.in); // 创建Scanner对象
System.out.print("Input your name: "); // 打印提示
String name = scanner.nextLine(); // 读取一行输入并获取字符串
System.out.print("Input your age: "); // 打印提示
int age = scanner.nextInt(); // 读取一行输入并获取整数
System.out.printf("Hi, %s, you are %d\n", name, age); // 格式化输出

```


## 数据结构比较
### 一.字符串


1.`equals()`：比较内容，值，推荐


```java
String a=new String("abc"); 
String b=new String("abc");

a.`equals(b)`;
```


2.`== `：比较地址

```java
String c="123";
String d="123";
System.out.println(c==d);  //true，在java中字符串的值是不可改变的，相同的字符串在内存中只会存一份，所以a和b指向的是同一个对象；
String a=new String("abc");
String b=new String("abc");
System.out.println(c==d); //false，此时a和b指向不同的对象。
```

`==`是比较内存地址的，内存地址相等，就返回true，地址相等，值肯定也一样，地址不相等，即使值相等也会返回false，

字符串是对象类型，所以不能用简单的“==”判断。

而用`equals（`）方法，String中重写了`equals`，不管地址是否相等，都只对值进行比较，值相等就返回true，不相等就返回false。两个String对象相等或内容相等都返回true

## 判断是否为数字，字母
### 字符char
```java
Character.isDigit(char c)　　//判断字符c是否是数字字符，如‘1’，‘2’，是则返回true，否则返回false  

Character.isLowerCase(char c)　|| Character.isUpperCase(char c)　　//判断c是否是字母字符，前面LowerCase是小写，后面UpperCase是大写，是返回True，否则返回False

Character.isLetterOrDigit(char c)　　//判断c是否是字母或数字字符，是返回true,否则返回false
Character.isLetter(char c)可以判断这些字符：

UPPERCASE_LETTER
LOWERCASE_LETTER
TITLECASE_LETTER
MODIFIER_LETTER
OTHER_LETTER
// 这些字符除了包含字母之外还包含其他字符
```

### 字符串String

```java
import java.util.regex.Pattern;
//使用正则表达式

public static boolean isInteger(String str){
    // Pattern pattern=Pattern.compile("^[-\\+]?[\\d]*$");
            Pattern pattern = Pattern.compile("[0-9]*");

    return pattern.matcher(str).matches();
}

/**
 * 判断是否是字母
 * @param str 传入字符串
 * @return 是字母返回true，否则返回false
 */
public boolean is_alpha(String str) {
    if(str==null) return false;
    return str.matches("[a-zA-Z]+");
}


/**
 * 判断是否是字母或者数字
 * @param str 传入字符串
 * @return 是字母返回true，否则返回false
 */
public  static boolean isLetterDigit(String str) {
    String regex = "^[a-z0-9A-Z]+$";
    return str.matches(regex);
}
```








## 基本类型数组
`set,list,map`等的`contains`判断只能判断地址
# java数据结构

- 基本数据类型8
  - 数值型
    - 整数 byte[1] short[2] int[4] long[8]
    - 浮点 float[4] double[8]
  - 字符型 char[2]
  - 布尔型 boolean[1]
- 引用数据类型
  - 类 class
  - 接口 interface
  - 数组 []

long类型之后需要加L或者l
浮点数默认为double类型
float类型之后需要加F或者f
```java
long a=2l;
long b=2L;

double c=1.1;
float d=1.2f;
double e=2.1f;
double f=.222;
```

浮点数=符号位+指数位+尾数位
尾数可能丢失，小数都是近似值
```java
Math.abs(num1-num2)<0.-000001//小数相比较

```


科学计数法
```java
5e10;//5乘以10的10次方
5e-10;//5乘以10的负数10次方

```

## 编码
ASCII表一共128个字符
unicode兼容ascII
utf-8，gbk变长编码
## 类型转换

###  基本数据类型转换
小到大会自动转换
大到小会报错
`char->int->long=>float->double`
`byte->short->int->long->float->double`


byte,short,char之间不会自动转换
byte,short,char 无论单独计算还是组合计算的时候会自动转化为int

复合运算符会进行类型转换
```java
byte a=1; T
a=a+1; F
a+=1;  T
a++;   T

```
赋值之前会判断所赋的值是否在改基本类型的范围内，不在则报错。
操作数转化为计算中最大的数据类型


### 基本类型与String

```java
int i = Integer.parseInt([String]); 
int i = Integer.parseInt([String],[int radix]);
int i = Integer.valueOf(my_str).intValue();

Integer x=new Integer("23"); 
boolean x=Boolean.parseBoolean(s);
byte b=Byte.parseByte(s);
short sh=Short.parseShort(s);
long l=Long.parseLong(s);
float f=Float.parseFloat(s);
double d=Double.parseDouble(s);


String s=i+"";

char c='a';
String s=c+"";

float x=2f;
String s=x+"";

double x=1.2;
String s=x+"";

String s = String.valueOf(i);
String s = Integer.toString(i);

```

## 运算
### 赋值

基本类型值为传递
引用类型为地址传递/引用传递

### 取余
a%b=a-a/b*b;
```java
10%3==1;
-10%3=-1;
10 % -3=1;
-10 %-3= -1；

```

### ++
```java
int x=2;
x=x++; // 1 temp=x; 2 x=x+1  3 x=temp;
//x=2;
int y=2;
y=++y;// 1 y=y+1 2 y=y
//y=3

```

### 逻辑运算

```java
& 逻辑与
&& 短路与
| 逻辑或
|| 短路或
! 取反
^ 逻辑异或
```


对于逻辑与`&`而言，第一个条件错误，第二个仍然会判断
对于短路与`&&`而言，第一个条件错误，第二个不再会去判断

对于逻辑或`|`而言，第一个条件正确，第二个仍然会判断
对于短路或`||`而言，第一个条件正确，第二个不再会去判断


### 位运算

- java都是有符号数
- 正数 原码，反码，补码都一样
- 负数 符号位不变洽其他位置取反
- 负数补码=反码+1
- 计算机运算使用补码


```java
& 按位与
| 按位或
^ 按位异或
~ 按位取反
<< 算术左移 符号位不变，低位补0
>> 算数右移 ,符号位不变，符号位补齐高位

>>> 逻辑右移 高位补0
无<<<

```

### 位操作
1. 利用或操作 `| `和**空格**将英文字符转换为小写
`('a' | ' ') = 'a'`
`('A' | ' ') = 'a'`

2. 利用与操作 `&` 和**下划线**将英文字符转换为大写
`('b' & '_') = 'B'`
`('B' & '_') = 'B'`

3. 利用异或操作 `^` 和**空格**进行英文字符大小写互换
`('d' ^ ' ') = 'D'`
`('D' ^ ' ') = 'd'`
以上操作能够产生奇特效果的原因在于 ASCII 编码。ASCII 字符其实就是数字，恰巧这些字符对应的数字通过位运算就能得到正确的结果

4. 判断两个数是否异号
   
```java
int x = -1, y = 2;
boolean f = ((x ^ y) < 0); // true

int x = 3, y = 2;
boolean f = ((x ^ y) < 0); // false
```


5. 不用临时变量交换两个数


```java
int a = 1, b = 2;
a ^= b;
b ^= a;
a ^= b;
```

6. 加一

```java
int n = 1;
n = -~n;
// 现在 n = 2
```

7. 减一

```java
int n = 2;
n = ~-n;
// 现在 n = 1
```

8. 消除1
`n & (n-1)`
这个操作是算法中常见的，作用是消除数字 n 的二进制表示中的最后一个 1。

9. 与自身**异或**为0
和 0 做异或运算的结果为它本身

```java
a ^ a = 0;
a ^ 0 = a;
```

10. 



## int
### java int最大值
```java
    int length=Integer.MAX_VALUE;
    //最小值
    int length=Integer.MIN_VALUE;
```
### 强制类型转换
```java
int a=(int)1.3;

```


### 随机数

```java
Random r = new Random();
double d1 = r.nextDouble(); // 生成[0,1.0]区间的小数
double d2 = r.nextDouble() * 7; // 生成[0,7.0]区间的小数
int i1 = r.nextInt(10); // 生成[0,10)区间的整数
int i2 = r.nextInt(18) - 3; // 生成[-3,15)区间的整数
long l1 = r.nextLong(); // 生成一个随机长整型值
boolean b1 = r.nextBoolean(); // 生成一个随机布尔型值
float f1 = r.nextFloat(); // 生成一个随机浮点型值
System.out.println("生成的[0,1.0]区间的小数是：" + d1);
System.out.println("生成的[0,7.0]区间的小数是：" + d2);
System.out.println("生成的[0,10]区间的整数是：" + i1);
System.out.println("生成的[-3,15]区间的整数是：" + i2);
System.out.println("生成一个随机长整型值：" + l1);
System.out.println("生成一个随机布尔型值：" + b1);
System.out.println("生成一个随机浮点型值：" + f1);


```


## 数组
> 数组属于引用类型，数组型数据为对象 Object


未初始化 默认值
数字 0
String null
boolean false
char \u0000
### 定义
```java

int []a={1,1,1};
int a[]={1,1,1};
int []b=new int[size];
int []c=new int[]{1,2,3};
```

### 数组长度

```java
a.length
```

### 打印数组

```java
System.out.println(Arrays.toString(array));
```

#### 打印二维数组
```java
System.out.println(Arrays.deepToString(numArray));
```
### int数组与Integer数组互转

### 数组复制



```java

 Integer[] integers = new Integer[10];
        int[] ints;
        for (int i = 0; i < integers.length; i++) {
            integers[i] = i;
        }
       ints= Arrays.stream(integers).mapToInt(Integer::valueOf).toArray();
```

### 数组截取
```java
results = Arrays.copyOfRange(results, 0, 5);
```

### 二维数组


二维数组的各个一维数组的长度可以不一致
```java
int []a[]=new int[2][2];
int a[][]=new int[2][2];

int [][]a=new int [3][];

for(int i=0;i<a.length;i++){
    a[i]=new int[i+1];
}

```


### 拷贝

- 基本类型，深拷贝和浅拷贝都是一样的，都是对原始数据的复制，修改原始数据，不会对复制数据产生影响。
- 两者的区别，在于对引用属性的复制。
  - 浅拷贝
    - 浅拷贝复制引用属性时，仅仅复制指针值，没有复制指向的对象。
  - 深拷贝
    - 深拷贝完整复制一份该属性指向的对象，


#### `System.arraycopy`（_浅拷贝_）

```java
  int[] array1 = new int[]{1,2,8,7,6};
  int[] array2 = new int[array1.length];
  System.arraycopy(array1, 0, array2, 0, array1.length);
```


#### `Arrays.copyOf`（_浅拷贝_）

```java
public static byte[] copyOfRange(byte[] original, int from, int to) 
```
> 实Arrays.copyOf()方法在底层是调用了 System.arraycopy() 方法来实现复制，即可以把Arrays.copyOf() 方法看作是 System.arraycopy() 方法的衍生方法，故它的执行机理与 System.arraycopy() 方法相同

#### 对象拷贝（ `Object.clone`）
对于**对象**而言，它是*深拷贝*，但是对于**数组**而言，它是*浅拷贝*
> 要调用这个方法，就需要我们写一个类，然后声明实现cloneable接口就好了
```java
@Override
public Object clone() throws CloneNotSupportedException {
    // TODO Auto-generated method stub
    return super.clone();
}

```
#### 数组拷贝
> 对于数组而言，它不是简单的将引用赋值为另外一个数组引用，而是创建一个新的数组。但是我们知道，对于数组本身而言，它它的元素是对象的时候，本来数组每个元素中保存的就是对象的引用，所以，拷贝过来的数组自然而言也是对象的引用，所以对于数组对象元素而言，它又是浅拷贝






### 排序
```java
Arrays.sort(arr, Collections.reverseOrder());//只能是对象类型数组
//二维数组排序
Arrays.sort(intervals, (a, b) -> {
            return a[0]==b[0]?b[1]-a[1]:a[0] - b[0];
        });
```










## 列表List
### 列表定义
```java
//引入List
import java.util.ArrayList;
import java.util.List;
//定义
List<String> list = new ArrayList<>();//接受null
List<String> list = new LinkedList<>();//接受null
List<Integer> list = sLit.of(1, 2, 5);//不接受null
```


```java
List list=new ArrayList();
List list1=new ArrayList();
list.add("jack");
list.add(10);//new Integer(10);
list.add(true);//
list.clear();//清空
list1.addAll(list);//添加多个

list1.containsAll(list);//true判断有无list
list1.removeAll(list);//删除list
```
### 添加元素
```java
list.add("apple"); // size=1
list.add("pear"); // size=2
```
### 获取长度
```java
int size=list.size();
```
### 获取元素
#### 根据位置
```java
String a=list.get(1);//t推荐arraylist
//遍历列表,迭代器
for (Iterator<String> it = list.iterator(); it.hasNext(); ) {
    String s = it.next();
    System.out.println(s);
}
for (String s : list) {
            System.out.println(s);
}
```
#### 与数组互转
```java
Integer[] array = list.toArray(new Integer[3]);
```
list打印
```java
Arrays.toString(list.toArray())
```

### 排序

1. 普通类型
```java
List<Integer>nums=new ArrayList<>();
nums.add(0);
nums.add(3);
nums.add(6);
Collectios.sort(nums);


```
2. 对象类型

```java
List<User>nums=new ArrayList<>();
nums.add(new User("李四"，78));
nums.add(new User("tom"，7));
nums.add(new User("jerry"，8));
Collectios.sort(nums);

```

```java


class User implements Comparable<User>{

　　private String name; //姓名
　　private int age; // 年龄

　　public User(String name, int age) {
　　　　this.name = name;
　　　　this.age = age;
　　}
　　// getter && setter
　　public String getName() {
　　　　return name;
　　}
　　public void setName(String name) {
　　　　this.name = name;
　　}
　　public int getAge() {
　　　　return age;
　　}
　　public void setAge(int age) {
　　this.age = age;
　　}
　　@Override
　　public String toString() {
　　　　return "User [name=" + name + ", age=" + age + "]";
　　}

　　@Override
　　public int compareTo(User user) {           
      // 重写Comparable接口的compareTo方法，根据年龄升序排列，降序修改相减顺序即可
　　　　return this.age - user.getAge();
　　}
}

```

3. 匿名内部类实现排序
```java
 Collections.sort(list, new Comparator<User>() {
　　　　    @Override
　　　　    public int compare(User u1, User u2) {
　　　　　　    int diff = u1.getAge() - u2.getAge();
　　　　　　    if (diff > 0) {
　　　　　　　　    return 1;
　　　　　　    }else if (diff < 0) {
　　　　　　　　    return -1;
　　　　　　    }
　　　　　　    return 0; //相等为0
　　　　    }
　　    }); // 按年龄排序

。

```

4. 简介方案
```java
list.sort(Comparator.comparing(User::getAge));
```


5. 降序
```java
//降序：
Collections.sort(list，Collections.reverseOrder())//list:8 7 6 5 4 2 1

```
6. 逆序
```java
//逆序；
Collections.reverse(list)//list：4 1 8 6 
```
## 字符串String
`length() `字符串的长度
`charAt()` 截取一个字符
`getChars()` 截取多个字符
`toCharArray() `转化为字符数组
`subString()` 取子字符串
```java


char chars[]={'a','b'.'c'};
String s=new String(chars);
int len=s.length();

char ch;
ch="abc".charAt(1); 返回'b'
```
### 字符串拼接
#### plus

```java
String a="";
int b=0xb;
String c=a+b;
```

#### concat

```java
//当两个量都为String类型且值不为null时，可以用concat方式。
String a="a";
String b="b";
String c= a.concat(b);
```

#### StringBuffer

```java

StringBuffer buf=new StringBuffer();
StringBuffer buf=new StringBuffer(a.length()+b.length()+c.length());//提供足够的空间
buf.append("a");
if(someCondition){
    buf.append("b");
}
buf.append("c");
String d=buf.toString();
```
#### StringBuilder的join()


## set集合
```java
import java.util.Set;

 Set<Integer> set = new HashSet<Integer>();
 add( )
//将对象添加到集合
	clear( )
// 从集合中移除所有对象
	contains( )
// 如果指定的对象是集合中的元素返回true
	isEmpty( )
// 如果集合不包含任何元素，则返回true
	iterator( )
// 返回一个Iterator对象，可用于检索对象的集合
	remove( )
// 从集合中删除指定的对象
	size( )
// 
set.toArray(myArray);
//转成Integer,String 数组无法转为int数组

//Union - 为了得到两个集合x和y的并集，我们可以使用
x.addAll(y)

// Intersection - 要获得两个集合x和y的交集，我们可以使用
x.retainAll(y)

// Subset - 要检查x是否是y的子集，我们可以使用
y.containsAll(x)

Set接口的实现
```

## map 
### 定义
```java
Map<Integer,Integer> map=new HashMap<>();
```
### 包含有某个元素
```java
map.containsKey();
```
### 获取，添加，替换元素

```java
map.get(target-nums[i]);
           
map.put(nums[i], i);
// 替换 hashMap 中是指定的 key 对应的 value。
hashmap.replace(K key, V newValue)

hashmap.replace(K key, V oldValue, V newValue)
map.getOrDefault(key,value)
```
### 常用方法
#### keyset
`keySet()`方法返回值是Map中key值的集合；entrySet()的返回值也是返回一个Set集合，此集合的类型为Map.Entry。
```java
for (String key : map.keySet()) {    
   System.out.println("key= "+ key + " and value= " + map.get(key));    
}  

```
#### Entry
`Map.Entry`是Map声明的一个内部接口，此接口为泛型，定义为Entry<K,V>。它表示Map中的一个实体（一个key-value对）。接口中有getKey(),getValue方法。
```java
Iterator<Map.Entry<String, String>> it = map.entrySet().iterator();    
while (it.hasNext()) {    
    Map.Entry<String, String> entry = it.next();    
    System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue());    
}    
//("通过Map.entrySet遍历key和value  
for (Map.Entry<String, String> entry : map.entrySet()) {    
    System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue());    
}       
  
```
#### values
```java
//通过Map.values()遍历所有的value，但不能遍历key 
for (String v : map.values()) {    
    System.out.println("value= " + v);    
}
```
### TreeMap
> 树图



## 栈 Stack
>后进先出

```java
Stack<Integer> st = new Stack<Integer>();
int a=7;
st.push(new Integer(a));
Integer b = (Integer) st.pop();

Object peek( )
// 查看堆栈顶部的对象，但不从堆栈 移除它。
boolean empty() 
// 测试堆栈是否为空。
int search(Object element)
// 返回对象在堆栈中的位置，以 1 为基数。
```

## 队列 Queue
> 先进先出

```java
Queue<String> queue = new LinkedList<String>();

offer()
// ：往队列添加元素。如果队列已满直接返回false，队列未满则直接插入并返回true；

add()
//：对offer()方法的简单封装。如果队列已满，抛出异常new IllegalStateException("Queue full")；

put()
// ：往队列里插入元素，如果队列已经满，则会一直等待直到队列为空插入新元素，或者线程被中断抛出异常.

remove()
// ：直接删除队头的元素；

peek()
// ：直接取出队头的元素，并不删除。

element()
// ：对peek方法进行简单封装，如果队头元素存在则取出并不删除，如果不存在抛出异常NoSuchElementException()；

pool()
// ：取出并删除队头的元素，当队列为空,返回null；

take()
// ：取出并删除队头的元素，当队列为空，则会一直等待直到队列有新元素可以取出，或者线程被中断抛出异常
```

### 双端队列Deque
#### 定义
```java
Deque<> deque = new LinkedList();
Deque<> que=new ArrayDeque();

```
`ArrayDeque` 大小可变的数组双端队列，不允许插入`null`。
### 常用方法

| 第一个元素 | (头部)          | 最后一个元素    | (尾部)         |
| ---------- | --------------- | --------------- | -------------- |
| 抛出异常   | 特殊值          | 抛出异常        | 特殊值         |
| 插入       | `addFirst(e)`   | `offerFirst(e)` | `addLast(e)`   | `offerLast(e)` |
| 删除       | `removeFirst()` | `pollFirst()`   | `removeLast()` | `pollLast()`   |
| 检查       | `getFirst()`    | `peekFirst()`   | `getLast()`    | `peekLast()`   |

###  PriorityQueue

> 优先级队列，同堆

#### 定义

```java
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Comparator;

Queue<String> q = new PriorityQueue<>();
//自定义比较函数
Queue<User> q = new PriorityQueue<>(new UserComparator());
class UserComparator implements Comparator<User> {
    public int compare(User u1, User u2) {
        if (u1.number.charAt(0) == u2.number.charAt(0)) {
            // 如果两人的号都是A开头或者都是V开头,比较号的大小:
            return u1.number.compareTo(u2.number);
        }
        if (u1.number.charAt(0) == 'V') {
            // u1的号码是V开头,优先级高:
            return -1;
        } else {
            return 1;
        }
    }
}

 PriorityQueue<int[]> q = new PriorityQueue<int[]>(new Comparator<int[]>() {
            public int compare(int[] m, int[] n) {
                return m[1] -n[1];
            }
        });

```

#### 插入元素

```java
q.offer("apple");
q.add("pear");
q.offer("banana");
     

```

`add(E e)`和`offer(E e)`的语义相同，都是向优先队列中插入元素
只是`Queue`接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回false。对于`PriorityQueue`这两个方法其实没什么差别。

#### 取出元素

`remove()`和`poll()`方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回null.

由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。

```java
System.out.println(q.poll()); // apple
System.out.println(q.poll()); // banana
System.out.println(q.poll()); // pear
System.out.println(q.poll()); 

```

#### 获取元素

`element()`和`peek()`的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素

二者唯一的区别是当方法失败时前者抛出异常，后者返回null。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，0下标处的那个元素既是堆顶元素。所以直接返回数组0下标处的那个元素即可。

#### 大小

```java
queue.size();
```

## pair配对

>配对提供了一种方便方式来处理简单的键值关联

```java
Pair<Integer, String> pair = new Pair<>(1, "One");
Integer key = pair.getKey();
String value = pair.getValue();
```

# Java基本知识
## java特性
- 解释性
- 跨平台
- 解释性语言
- 强类型
- 垃圾回收
- 面向对象
- 异常处理

jdk java开发环境集
jre jvm+java核心类库
jvm java运行虚拟机


`javap Dog.class` 反编译
### 常识
- 源文件包含有一个`public`类则文件名必须为该类名称。
- 一个类编译成为一个`.class`文件
- 可以在多个非`public`中写`main`方法
- 


\r回车 ，光标回到本行行首处

### 内存分配机制

- 栈，基本数据类型
- 堆，对象
- 方法区，常量池（常量，字符串等），类加载信息

执行到方法时，会开辟一片独立的栈空间。

#### 文档注释

`javadoc`
```java
/**
* @author andy
* @version 1.1
*/


```


```shell
javadoc  -d d:\\tamp -author -version Test.java

```


#### switch case
不加`break`会执行之后所有的语句直到有`break`

`switch`的表达式返回值必须是 `byte char string int short enum`
`case`中的语句必须是常量不能是变量



## 类与对象`oop`

- 对象的引用数据类型放在方法区域的常量区
- 基本数据类型，引用数据类型的地址放在堆里面。

属性可以不赋值，有默认值，局部变量必须赋值
```java
Car car;
car=new Car();
car.name="福田";
```

### 方法传参

- 基本类型传递值方法内值改变，外部不改变）
- 引用类型传递地址（方法内该边地址所含有的值改变，外部也改变）

### 方法重载
`Overload`
要求形参的类型或者个数不一致

### 可变参数

```java
public int sum(int... nums){
 int res=0;
 for(int i;i<nums.length;i++){
    res+=nums[i];
 }
 return res;
}
```

`...`表示可以接受多个参数 0或者任意个

- 可变参数的实参可以是数组
- 可变参数的本质是数组
- 可变参数之前可以有几个普通参数
- 只能有一个可变参数

### 构造方法
会默认一个无参构造方法
定义新的构造方法会覆盖，若再次想使用无参构造方法需要显式定义

1. 加载类信息，只会加载一次
2. 在堆中分配空间
3. 完成对象初始化
    1. 默认初始化（开辟空间，字段默认值）
    2. 显式初始化（类中赋予字段的值，基本数据类型赋值，引用数据类型null）
    3. 构造器初始化 （构造器中赋予字段的值，为引用数据类型开辟空间）
### this
```java
this.hashCode();//返回一个值，地址的映射
this("tom",23);//可以在构造器的第一句调用其他本类的构造器
```

### 包
>不同保存类的文件夹、目录
- 区分名字相同的类
- 管理类
- 控制访问范围
  
引用相同没拿工资不同包的类，第二个以及更多，类目必须包含包名
```java
package com.person;

java.lang.*;//默认引入，java基本包
java.util.*;//系统工具包
java.net.*;//系统网络包
java.awt.*;//页面开发，gui

```

### 访问修饰符

`public` 对外公开
`protected` 对子类和同一个包的类公开
*默认* 对同一个包的类公开
`private` 只有类本身可以访问，不对外公开

只有默认和public才可以修饰类
修饰和访问规则，方法和属性一致

非私有的属性可以有子类访问和使用

### 继承
子类构造器会默认调用父类的无参构造器，若是父类没有无参构造器，则必须指明调用的父类的构造器
```java
super();
```
`super()`只能在构造器其中使用，而且必须放在第一行。不能同时使用`super()`和`this()`.
`super`代表父类的引用

### 覆写

- 子类覆写父类的方法
- 方法名称和参数列表需要一致
- 子类的返回类型需要为父类返回类型一致或者是父类返回类型的子类
- 子类方法不能够缩小父类方法的访问权限，可以扩大

### 多态

```java
Animal animal-new Dog();//编译类型Animal,运行类型Dog
animal=new Dog();//编译类型Animal，运行类型Cat
```
- 编译类型不能改变
- 运行类型可以改变
- 运行时运行的是运行类型


#### 向上转型
父类的引用指向子类的对象
`父类 xxx=new 子类();`
可以调用父类的全部成员，按照访问规则
不可以调用子类的特有成员
调用依然是从子类开始向上寻找

#### 向下转型

`子类 xxx=（子类）父类引用；`
只能强转父类的引用，不能强转父类的对象
父类的引用必须指向当前目标类型的对象
可以调用子类类型中的所有成员



属性没有重修之说，属性看的是编译类型
`instanceOf`判断 对象是否为某类或者某类子类的对象，实例。 判断的是对象的**运行类型**

### 动态绑定机制

- 当调用对象*方法*的时候，该方法会和该对象的内存地址/运行类型绑定一致。每次在最底层子类开始寻找
- 当调用对象*属性*的时候没有动态绑定机制，那里声明，那里使用，每次从当前的编译类型的    对象类里面开始向上寻找

### static
#### 静态变量
```java
public static int count;//类静态变量 
```
可以通过对象访问，类访问，共用一个static 变量
在类加载的时候生成，存储位置不同jdk版本不同 Class实例的尾部
static变量也遵守修饰符的限定

#### 静态方法、类方法
```java
public static int sum(int []nums){
    ///
}

```

类方法中不允许使用this super
静态方法只能访问静态成员
非静态方法可以访问静态和非静态成员  


### main 方法

```shell
java Hello tom cat kack
```
```java
public void main( String []args){
    for(String s:args){
        System.out.print(s);
    }
}
//tomcatjack
```
### 代码块

初始化对象的时候隐式调用普通代码块
static修饰或者不要修饰，类代码块普通代码块
普通代码块调用优先于构造函数
类加载时调用static静态代码块

```java
class User{
    String name;
    String pwd;
    //每次带哦用每种构造方法之前调用代码块
    static{
        System.out.println("代码块");
    }
    User(){

    }
    User(String name){
        this.name=name;
    }
}
```

### 创建对象的调用顺序
优先级一致按照顺序执行
1. 父类静态代码和静态属性
2. 子类的静态代码和静态属性
3. 父类的普通代码和普通属性
4. 父类的构造方法
5. 子类的普通代码和普通属性
6. 子类的构造方法
### final
- 修饰类
  - 类不在被继承
- 修饰方法
    - 父类的方法不会被子类覆写
- 修饰属性
  - 类的属性不会被改变
- 修饰局部变量
  - 遍历不会被修改

`static`和`final`可怜和修饰属性，在使用时不会导致类加载
```java
public final static x=1;

System.out.println(new user.x);
```

### abstract
1. 抽象方法、就是没有方法体，没实现的方法
2. 一个类有抽象方法的时候，该类必须是抽象类
3. 抽象类不能被实例化
4. 抽象类可以没有抽象方法
5. 不能修饰属性
6. 一个类继承了抽象类，除非自己也是抽象类，否则必须实现抽象类的所有抽象方法
7. 抽象方法不能使用`pricate`，`static`，`final`修饰
```java
public abstract void cry();

```

### 接口 interface
```java
public interface Usb{
    abstract void start();
    default public void stop(){
        System.out.println("ok");
    } 
    public static void out(){
        System.out.println("out");
    }
}
class Phone implements Usb{
    @Override
    void start(){

    }

}

class Computer{
    public void work(Usb usb ){
        usb.start();
    }
    public static void main(String []args){
        Computer c=new Computer();
        c.work(new Phone());
    }
}
```
1. 类需要`implements`实现所有接口中的方法
2. 可以通过接口调用方法
3. jdk7.0之前接口都是抽象方法没有方法体，jdk8.0之后接口可以有静态方法，默认方法，可以有具体的方法实现
4. 在接口中，方法前的`abstract`可省略,所有方法都是`public`方法
5. 接口中存在方法体必须要有default修饰
6. 抽象类实现接口可以不用实现接口中的方法 
7. 一个类可以同时实现多个接口
8. 接口中可以有属性，默认是`public static final`
9. 接口不能继承类但是可以继承多个接口`extends
10. 接口的修饰符只能是默认或者`public`

#### 接口的多态
形参是接口，可用于接受实现了该接口的类的实例对象

可以使用接口板指向实现了该接口的类的实例对象
```java
Usb u=new Phone();

```

多态的传递性

```java
interface ih{}
interface ig extends ih()
class T implements ig{}
ih h=newT();//相当于T也实现了ih接口
ig g=newT();
```


### 内部类
类的五大成员 方法、属性、代码块、构造器、内部类
内部类的最大特点就是可以直接访问私有成员、


内部类的分类
根据定义位置
- 定义在外部类的局部位置上，比如方法中  
  - 局部内部类，有类名
  - 匿名内部类，无类名
- 定义在外部类的成员位置上
  - 成员内部类，没有`static`修饰
  - 静态内部类，有`static`修饰

#### 局部内部类


```java
class Outer{
    {
        class inner03{

        }
    }
    class Inner{

    }
    public void hi(){
        final class Inner01{

        }
    }

}

```

可以访问外部类的私用成员
不能添加访问修饰符们可以使用final，不能使用`static`
作用域仅限定义的方法或者类之内
外部不能访问
内外部成员重名时`Outer.this.m1;类名+this+属性名

#### 匿名内部类
没有名字，本质是类，内部类，同时是一个对象
创建匿名类之后立刻就创建了实例返还给接口，该内部类只是使用一次

可以基于类或者接口
不能添加修饰符
匿名局部类是一个局部变量
```java
interface A{}
A a=new A(){//编译类型接口A，运行类型匿名内部类
//系统给予他一个i那个字Outerxxx

}

class B{
    String name;
    B(String name){
        this.name=name;
    }
    void cry(){

    }
}
B b=new B("jack"){//编译类型B，运行类型匿名内部类，该匿名内部类继承于B
    @Override
    void cry(){

    }
};
```


匿名类当作实参传递

```java
interface A{
    void cry();
}

void fun1(A a){
    a.show();
}
public static void main(String []aargs){
    fun1(new A(){
        @Override
        void cry(){

        }
    });
}
```

#### 成员内部类

```java
class Outer{
    class Inner{
    }
   
}

```

外部其他类调用Inner类
```java
//1
Outer outer=new Outer();
Outer.Inner in=outer.new Inner();

//2
使用方法返回
Outer.Inner in=outer.getInner();


```

#### 静态内部类
```java
class Outer{
    static class Inner{

    }
}

```
可以访问外部类的所有静态成员，不能访问非静态成员
作为一个静态成员可用public等修饰
作用域为外部类
```java
//满足访问权限

Outer.Inner in=new Outer.Inner();
```

## jdk源码

### `equal`函数

`==`基本类型比较数值，引用类型比较地址
普通类默认继承`Object`的`equal`方法
`Object`的`equal`方法使用`==`比较

覆写父类的`equal`方法可以来比较内容的值

### `hashcode()`
提供对象的哈希码值提高系统提供的哈希表的性能

- 哈希值主要根据地址来的但不等于地址，返回不同的整数
- 相同对象(不同引用，相同对象)哈希值一致
- 不同对象哈希值原则上不同

### `toString`

sout时自动调用

###  `Finalize`
1. 对象被回收时候，系统自动调用，子类可重写实现一些**释放资源**的操作
2. 当某个对象没有任何引用的时候，vm就认为是可以回收的在回收之前调用
3. 系统来决定垃圾回收，也可以通过`System.gc()`来触发垃圾回收机制 

实际中不会使用

## 枚举类`enum`

```java
enum Season{
    SPRING("春天","温暖"),
    SUMMER("夏天","炎热"),
    WINTER("东天","寒冷"),
    FALL("秋天","凉爽")，
    WHAT;//需要写在最前面
    private String name;
    private String temp;
    Season(){

    }
    Season(String name,String temp){
        this.name=name;
        this.tamp=temp;
    }
    public void work(){

    }
}
System.out.println(Season.WINTER);

```
1. 默认继承`Enum`类
2. 无参构造器可以省略括号
3. 枚举对象必须放在首位
4. 默认属性都是`final static`的
5. 不能再继承其他类 

### 枚举类的方法
`name()`返回名字WINTER
`ordinal()`返回编号，按照定义的顺序
`toString()`返回当前对象名
`values`返回一个枚举类数组，包含所有的枚举类对象
`valueOf`字符串转化为枚举类对象，字符串必须为已存在的枚举类对象名称

## 注解`Annotation`
### 常见注解
```java
@Override 用于方法前，表示重写父类的方法
@Deprecated 代表已经方法，类弃用过时
@SuppressWarinings 抑制编译器警告


```

```java
@SuppressWarningd({"all"})//可适合类、方法、语句中
//all,所有警告，boxing抑制封装拆装作业相关的警告
//cast抑制强转型作业的警告。。。。

```

### 元注解
> 修饰注解的注解
```java
@Retention 指定注解的作用时间范围 SOURCE 编译器使用之后丢弃,CLASS 保留在class文件中jvm运行时不会保留,RUNTIME jvm保留注释可以通过反射获取该注释
@Tatget 指定注解的使用的范围
@Documented 指定该注解是否会在javadoc体现
@Inherited 子类会继承父类有的注解 
```

## 异常
```java
try{
    int x=10/0;
}
catch(Exception e){
    System.out.println(e.getMessage());
}

```
- `Throwable`
  - 错误 `error` 会崩溃
    - 栈溢出 `StackOverFlowError`
    - 内存不足 `OutOfMemoryError`
  - 异常 `exception`
    - 运行时异常 `RuntimeException`
      - 空指针异常 `NullPointerException`
      - 算术异常 `ArithmeticException`
      - 数组越界 `ArrayIndexOutOfBoundsException`
      - 类型转换异常 `ClassCastException`
      - 数字格式 `NumberFormatException`
      - ...
    - 编译时异常,一下统称编译异常,必须处理
    - 文件未找到异常 `FileNotFoundException`
    - `ClassNodeFoundException`
    - ...

### 异常处理
#### try catch finally

```java
try{

//代码可能有异常
}catch (Exception e){
    //有异常发生就需要执行
}finally{
    //不管有无异常发生始终需要执行代码
    //通常用于执行释放资源
}

```

可以多个catch捕捉异常，子类异常在前面父类异常在后面
finally里面的内容比强制执行，即使trycatch中有return的话return会执行但是不返回，执行finally语句之后返回
#### throws
抛出异常
遇到异常要么trycatch处理，要么抛出异常给上一级处理，可以接着向上传递异常，trycatch和throws二选一
直到main方法异常传给jvm
jvm会输出异常信息中止程序运行
系统默认是throws
```java
void fun() throws FileNotFoundException {

}

```

子类覆写父类方法抛出异常是父类的异常的子异常或者相同异常

对下一级抛出的编译异常必须处理或者抛出，而运行异常可以不做处理

`throws`和`throw`的区别
`throw`放在方法体内，用于抛出一个一个异常对象
`throws`在方法声明处，跟这个异常处理的类型

### 自定义异常


```java
class AgeException extends RuntimeException{
    public AgeException(String message){
        super(message);
    }
}


public static void main(String []args){
    int age=10;
    if(age<12){
        throw new Ageexception("太小了");
    }
}
```

## 常用类
### 包装类`Wrapper`
对八种基本类型包装成的引用类型 类
- `Serializable`,实现了`Comparable`接口
  - boolean Boolean
  - char Character
- `Serializable` -> `Number` （父类）,实现了`Comparable`接口
  - byte Byte
  - short Short
  - int Integer
  - long Long
  - float Float
  - double Double


#### 拆箱装箱
手动
```java
//装箱
int n=10;
Integer in=new Integer(n);
Integer in1=Integer.valueOf(n);

//拆箱
int x=in.intValue();

```

自动
```java
//装箱
int n=10;
Integer in=n;//底层依然是Integer.valueOf(n);
//拆箱
int m=in;//底层依然是in.intValue();
```

#### 比较
```java
Integer x=1;
Integer x=128;
//-128~127中会直接使用cache中存储,Integer的缓存机制
//超过则new Integer(128);
```

`==`比较的是地址不是值，若有基本类型就是在比对值


### String 类
1. 继承自`Object`接口，实现了`Comparable`（可以比较大小 ），`Serializable`（可以串行化，就可以在网络传输），`CharSequence`接口
2. 字符串的字符一个占零个字节，使用unicode编码
3. 不可被继承
4. 字符串最终被保留到`private final char value[]`字符数组中.value的地址不可修改，其中的部分字符可修改
构建方法
```java
String s1=new String();
String s1=new String(String original);
String s1=new String(char sc[]);
String s1=new String(char sc[],int startIndex,int count);
String s1=new String(byte bc[]);
String s1=new String(byte bc[],int startIndex,int count);
```
#### String 对象特性
```java
String s1="Tom";//字符串常量是"Tom",存放于常量池中
//new 是在堆中开辟空间，该空间指向常量池中的"Tom"
s.intern();//返回常量池中的地址
```


```java
String s="123"+"abc";//编译器优化直接生成123abc常量只有一个对象
```

```java
String a="123";
String b="abc";
String c=a+b;//一共三个对象
//1 StringBuilder sb=new StringBuilder();
//2 sb.append("123");
//3 sb.append("abc");
//4 return sb.toString();//   在堆中new 一个字符串对象指向常量池中的"123abc"
```

常量相加看池，变量相加看的是堆

#### String常用方法
```java
charAt(int x);
toCharArray();
toLowerCase();
toUpperCase();
concat(String );//连接
replace("_","=");//返回结果才是替换过的
String strs[]=s.split(" ");

s1.compareTo(String s2);//len1-len2,  return s1-s2;
//先比较字符，返回不同字符的差值。若共有长度部分的字符相同则返回长度差值
//0 两者值完全相等，>0,s1大于说s2，<0 s2大于s1

String s=String.format("我叫做%s,我的年龄是%d,我的体重是%d,我的性别是%c","tom",23,123,'f');
//占位符 ，%s.%d,%c,%.2f(保留两位小数，四舍五入)
```

#### StringBuffer
继承自`AbstactStringBuilder`,实现了`Serializable`接口即可以串行化
在父类中的`char value[]`中存放字符串内容，存放在堆中
StringBuffer为final类
```java
StringBuffer sb=new StringBuffer(int x);//默认为16,不足时候自动扩容，不用创建新对象
StringBuffer sb=new StringBuffer("hello");//"hello".length()+16
sb.append(String ,char, int);
sb.append(10).append('p').append(90.9).append(true);
sb.delete(start,end);//删除[start,end)的字符
sb.replace(start,end,String);//[start,end)替换为String
sb.indexOf(String);//第一次出现的位置
sb.insert(index,String);//在index之前插入String原index处及以后后移
sb.deleteCharAt();//删除某个位置的字符
sb.length();//sb中添加的字符总长度



String s=sb.toString();
String s=new String(sb);
```

若`append null`字符串会加入"null"字符串

#### StringBuilder
> 一个可变的字符序列，与StringBuffer兼容的Api。 被设计为StringBuffer的一个简易置换，
> 未作线程处理不是线程安全，在单线程时候可以替换，比StringBuffer要快



```java
StringBuilder sb=new StringBuilder("hello");//"hello".length()+16
sb.append(String ,char, int);
sb.delete(start,end);//删除[start,end)的字符
```




### Arrays

```java
int a[]={1,2,3,4};
System.out.println(Arrays.toString(a));//数组转字符串

Arrays.sort(a);//由小到大排序
//定制排序

Arrays.sort(a,new Comrator<Integer>(){//接口Comparator的匿名内部类
    @Override
    public int compare(Integer o1,Integer o2){
        return o2-o1;
    }
});


int index=Arrays.binarySearch(arr,3);//有序数组，可以二分查找，不存在返回-(low+1)low本该位于的位置

Integer narr[]=Arrays.copyOf(arr,arr.length);//拷贝的长度大于原数组的长度，添加多个null，负数抛出异常
boolean eauqls =Arrays.equals(arr1,arr2);//完全一样返回true
Arrays.asList(1,2,3,4,5);//转为一个List,编译类型List(接口)运行类型ArraysList


```

### System

```java
System.exit(0);//退出程序,0表示正常退出
Arrays.arrayCopy(src,0,dest,0,3);//复制数组元素  原数组 ，原数组开始拷贝索引，目标数组，目标数组接受的目的索引，拷贝的总长度
currentTimeMillens;//返回当前时间距离1970-1-1的毫秒数
System.gc();//垃圾回收机制
```

### 大数
`BigInteger`大整数
`BigDecimal`大浮点数,精度太高
```java
BigInteger bi=new NigInteger("234234242452453453");//传入字符串，不呢直接加减乘除
bi.add(new BigInteger("2342"));//+
bi.subtracet();//-
multiply();// *
divide();// /

BigDecimal bd=new BigDecimal("2342345.35635636758485");

bd.divide(new BigDecimal());//若结果i是无限循环小数会抛出异常，调用divide时候指定精度
bd.divide(new BigDecimal(),DigDecimal.ROUND_CEILING );//若结果i是无限循环小数会抛出异常，调用divide时候指定精度

```

### 日期类

#### `Date` 第一代，精确到毫秒，代表特定的是瞬间

```java
import java.util.Date;
Date d1=new Date();//获取当前系统时间默认国外格式 Thu Mar 04 17:19:58 CST 2021
Date d1=new Date();//获取指定毫秒数得到时间

SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 hh:mm:ss E");
String s1=sdf.format(d1);

Date d2=sdf.parse(s1);//格式化的字符串转为Date对象,s1需要和定义的sdf格式一致才能转换
```


#### `Calendar`
抽象类，构造器是private
不是线程安全的
不能处理闰秒
```java
Calendar c=Calendar.getInstance();//获取实例,将各种参数藏在字段里
System.out.println(c.get(Calendar.YEAR));//获取年
System.out.println(c.get(Calendar.MONTH)+1);//获取月
System.out.println(c.get(Calendar.DAY_OF_MONTH));//获取日
System.out.println(c.get(Calendar.HOUR));//获取小时
System.out.println(c.get(Calendar.HOUR_OF_DAY));//获取24小时进制
System.out.println(c.get(Calendar.MINUTE));//获取分钟
System.out.println(c.get(Calendar.SECOND));//获取秒


```

#### `LocalDate,LocalTime,LocalDateTime`
`LocalDate`(日期年月日)
`LocalTime`（时间时分秒）
`LocalDateTime`（日期时间年月日时分秒）
```java
LocalDateTime ldt=LocalDateTime.now();//返回表示当前日期时间的对象
ldt.getYear();
ldt.getMonth();//Marth
ldt.getMonthValue();//3
ldt.getDayOfMonth();//
ldt.getHour();//
ldt.getMinute();//
ldt.getSecond();//
LocalDate ld=LocalDate.now();
LocalTime ld=LocalTime.now();

DateTimeFormatter.ofPattern("yyyy年MM月dd日 hh:mm:ss");
```
#### Instant时间戳
```java
Instant now=Instant.now();
System.out.println(now);//

Date date=Date.from(now);

```

## 集合

- 集合  单列集合，双列集合
  - `Collection`(接口)，继承`Inteable`接口
    - `List`（接口）
      - `ArrayList`（类）
      - `LinkedList`（类）
      - `Vector`（类）
    - `Set`（接口）
      - `HashSet`（类
        - `LinkedHashSet`（类）
      - `TreeSet`（类）
  - `Map`
    - `HashMap`（类）
      - `LinkedHashMap`（类）
    - `HashTable`（类）
      - `Properties`（类）
    - `TreeMap`（类）
    
  - `Collections`

### 遍历
实现了`Inteable`接口的类可以使用 `Iterarot` 迭代器，用于遍历集合
```java
Collection col=new ArrayList();
//Iterator iterator=Collection.iterator();
Iterator iterator=col.iterator();
while(iterator.hasNext()){//判断还有没有若是没有继续向下会报错
    Object next=iterator.next();
    System.out.println(next);
}
//再次取值，需要重置迭代器iterator=col.iterator();

```
### `Collection`接口
```java
Collection col=new ArrayList();
col.add();
col.addAll(Collection);
col.remove();
col.removeAll();
col.contains();
col.containsAll();

```
### List接口
```java
List list=new ArrayList();
list.get(int index);
list.add(int index,Object o);在索引index处插入
list.indexOf(Object o);//返回首次出现的位置
list.lastIndexOf(Object o);//返回末次出现的位置
list.set(int index,Object element);//替换

List nlist=list.subList(int startIndex,int endIndex);//[startIndex,endIndex)
 
```

### `ArrayList`
可以加入多个null
使用数组存储
线程不安全，但是单线程下高效
`elemebtData[]` 数组存放

无参构造器默认容量为0
第一次添加容量为10，之后如果需要扩容就会按照当前容量的1.5倍扩容
构造器可传入指定容量，每次扩容按照容量的当前容量的1.5倍扩容。

### `Vector`
底层是一个对象数组
是线程安全的`synchornized`
可以添加null值

无参构造器默认容量10
满了之后按容量的两倍扩容

### `LinkedList`
双向链表和双端队列
可以添加任意元素，包括null
线程不安全
包含有`next`,`pre`,`item`三个属性
```java
```

改查多选ArrayList
删除增加多选LinkedList

### `Set`接口
最多添加一个null
可用迭代器
不能使用索引

### `HashSet`类
HashSet底层其实是HashMap
```java
set.add("jack");//返回true
set.add("jack");//返回false
```
- 扩容
  - 第一次加入扩容直接到16
  - 到了临界值16*.75=12，就会自动扩容
  - 底层数组链表--红黑树(元素多的时候转化，java8当一条链超过8个元素，table的大小超过64就自动转化)否则仍然会继续扩容
  - table表扩容按照两倍来扩容
  - 
- 添加元素
  - 添加元素的时候根据`hash()`得到一个索引值
  - 按照表的索引之下的链表进行对比，对比hash，==，equal对比，一致就退出不加入，不存在一致的项就加入
  - 底层比较元素调用添加对象的`equals`比较

### `LinkedHashSet`
继承于`HashSet`实现`Set`接口
底层是`LinkedHashMap`
底层维护了数组加双向链表
根据元素的 hashCode求得元素的存储位置（在数组的位置），用链表维护顺序
不允许添加 重复元素
第一次添加，数组table扩容到 16
数组table是`HashMap$Node []`类型，存放的元素类型是`LinkedHashMap$Entry`类
`LinkedHashMap$Entry`继承`HashMap$Node `,继承关系是在内部类完成


### `TreeSet`
可以排序
底层TreeMap
```java
TreeSet treeSet=new TreeSet();//无参创建仍然是无序的
treeSet.add("Jack");
```
`Comparator`接口的方法
`int compare(T o1,T o2);`//排序方法

### `Map`
key和value会封装到`HashMap$Node`对象中
`HashMap$Node node =new Node(hash,key,value,null);`
会创建EntrySet对象，而一个Entry对象就有一个key和value
`EntrySet<Entry<K,V>>  transient Set<Map.entry<K,V>> entrySet;`

`HashMap$Node`实现了`Map.Entry`接口

#### Map的遍历
1. keySet()
```java
Set  keys=map.keySet();
for(Object x :keys){
    System.out.println(x+"  "+  map.get(x));
}


Iterator iterator=keys.iterators();
while(iterator.hasNext()){
    Object value=iterator.next();
    System.out.println(key+"  "+map.get(value));
}
```
2. values()
```java
Collection values=map.values();
for(Object o :values){
     System.out.println(o);
}


Iterator iterator=values.iterators();
while(iterator.hasNext()){
    Object value=iterator.next();
    System.out.println(value);
}
```
3. EntrySet
```java
Set entrySet =map.entrySet();
for(Object entry: entrySet){
    Map.Entry m=(Map.Entry)entry;
    m.getKey()+"  "+m.getValue();
}
Iterator iterator=entrySet.iterator();
while(iterator.hasNext()){
    Object next=iterator.next();
    Map.Entry next1=(Map.Entry)next;
    next1.getKey();
    next1.getValue();
}
```
### `HashMap`
线程不安全的
### `HashTable`
线程安全的
键和值不能为null
使用方法和hashMap一致
底层为HashTabe$Entry内部类数组，初始化大小为11
临界值threshold为8=11*0.75
扩容机制old*2—+1=new
### `Properties`
Properties继承自于HashTable实现了MAp接口
使用键值对来保存数据
使用特点和HashTable类似
key和value不许为null
可以用于重xxx.properties文件中读取数据
.properties通常作为配置文件

```java
Properties proterties=new Properties();
properties.put("john",100);
properties.get("john");
properties.remove("john");1
properties.getProperty("john");


```
### `TreeMap`
```java
TreeMap tm=new TreeMap();//无参构造器，无序


tm.put("Jack",10);

TreeMap tm1=new TreeMap(new Comparator(){//Compartor的匿名内部类
    @Override
    public int compare(Object o1,Object o2){
        return (String)o1.compareTo((String)o2);//按照key的大小排序
    }
});
```


### `Collections`工具类
```java
List list=new LinedList();
list.add("John");
list.add("Jack");
list.add("Tom");
Collections.reverse(list);//反转列表
Collections.shuffle(list);//随机排序列表
Collections.sort(list);//排序，默认升序
Collections.sort(list,new Comparator(){
    @Override
    public int compare(Object o1,Object o2){
        return ----;
    }
});
Collections.swap(list,0,2);//索引0和2处的元素交换位置
Collections.max(list);//最大元素
Collections.max(list,new Compatrator(){//长度最大元素
    @Override
      public int compare(Object o1,Object o2){
        return ((String)o1).length()-((String)o2).length();
    }
});
//min()方法
Collections.frequency(list,"John");//某元素出现的频率

//拷贝
List dest=new LinkedList();
for(int i=0;i<list.size();i++){
    dest.add("");
}
//dest需要设置大小和list一致
Collections.copy(dest,list);
Collections.replaceAll(list,"Tom","John");//Tom ->John

```

## 泛型
> 参数化类型，声明或者实例化的时候指明具体的类型就可以
> 在编译的时候就确定是什么类型

保证编译的时候不发生的警告就不会发生 类型转换问题

1. 只能是引用类型，不能是基本数据类型

2. 传入泛型E的子类型也是可以的 
3. 没有明确的泛型E，默认是Object

自定义泛型，泛型属性不能初始化
静态方法和静态属性不能够使用泛型
可以自定义泛型类，自定义泛型接口

泛型不能继承即List<Object> x=new LinkedList<String>();// F
```java
class Person<E，T,M>{
    E s:
    T tt;
    M mm;
public E get(E s){
    return s;
}
}
public Car{
    //泛型方法
    public <T,R> void move( T t,T,r){
         
    }
}
new Car().move("plane",456);

```

```java
List<?>list;//指明任何类型都可以
<? extends A> 支持A类以及A类的子类规定上限
<? super A>支持A类以及A类的父类，规定下限

```


# 线程
线程是进程的一个实体
java中实现线程有两种方法
1. 继承`Thread`类重写`run`方法
2. 实现`Runnable`接口，重写`run`方法

## `Thread`
`Thread`实现了`Runnable`接口,`run`方法实际也是来自`Runnable`接口的
```java
class Threadtest{
    public static void main(Strig []args){
        Cat cat=new Cat();
        cat.start();//启动一个新线程执行run 方法，线程只是可以执行，处于可执行状态，是否执行具体取决于cpu
        //main线程启动一个子线程Thread-0，主线程不会阻塞会继续执行
    }
}
class Cat extends Thread{
    @Override
    public void run(){
        while(true){
            System.out.println("i am a cat");
            try{
                Thread.sleep(1000);//ms
            }catch (InterruptedException e){
                e.printStackTrace();
            }
        }
    }
} 

```
## `Runnable`


```java
class Threadtest{
    public static void main(Strig []args){
        Cat cat=new Cat();
        Thread thread=new Thread(cat);
        thread.start();//启动一个新线程执行run 方法，线程只是可以执行，处于可执行状态，是否执行具体取决于cpu
        //main线程启动一个子线程Thread-0，主线程不会阻塞会继续执行
    }
}
class Cat implements Runnable{
    @Override
    public void run(){
        while(true){
            System.out.println("i am a cat");
            try{
                Thread.sleep(1000);//ms
            }catch (InterruptedException e){
                e.printStackTrace();
            }
        }
    }
} 

```
## 线程终止
当线程完成后会自动退出
可以使用变量的方式来控制run方法停止线程即通知方式
```java
class Cat extends Thread{
    private int count=0;
    private boolean loop=true;//希望主线程控制子线程的话需要控制loop方法
    @Override
    public void run(){
        while(loop){
            System.out.println("i am a cat");
            try{
                Thread.sleep(1000);//ms
            }catch (InterruptedException e){
                e.printStackTrace();
            }
        }
    }
    public void setLoop(boolean loop){
        this.loop=loop;
    }
} 


```

## 线程常用函数
```java
setName();//设置线程名字
getName();//获取线程名字
start();//线程开始执行
run();//调用的线程的润方法
setPriority();//更改线程的优先级，1~10一般为5
getPriority();//得到线程的优先级
sleep();//在指定的毫秒数让正在执行的线程休眠即暂停执行
interrupt();//终端线程
```

1. `yield` 线程的礼让，让出cpu，但是礼让的时间不确定，所以也不一定礼让成功
2. `join` 线程的插队，插队的线程插队成功肯定先执行完插队的线程的所有的任务。
   


```java
class T2 extends Thread{
    //...
}
T2 t2=new T2();
t2.join();//t2线程先执行


Thread.yield();//礼让
```

```java
class DT extends Thread{

}
DT dt=new DT();
dt.setDaemon(true);//启动之前设置，主线程结束的话子线程也结束
dt.start();

```
## 线程的状态
6种或者7种状态
- new 创建
- runnanle可运行状态（内核态）
  - ready 可以运行
  - running正在运行
- timewaiting 超时等待
- waiting 等待
- blocked 块锁等等待
- terminated 终止

## 线程同步机制
> 保证一些敏感数据在任何同一时刻只能够有一个线程访问，保证数据的完整性

`synchronized`
```java
synchronized (this) { //同步代码块

}
synchronized (object) { //同步代码块

}
synchronized (Thread01.class) { //同步代码块

}

public void synchronized void fun(){}//同步方法


```
### 互斥锁
每个对象可以对应一个可以成为互斥锁的标记，用于保证某一时刻最多只有一个线程访问。
会导致运行效率比较低
同步方法是静态的锁为类本身，默认当前类XXX.class
非静态的锁为对象，带代码块上加锁，锁在对象上.可以是其他对象，但是必须得是同一个对象。默认当前对象this
### 死锁
互相占用资源，互不相让


# 文件
文件流
java程序<-输入流，输出流->内存c

`File`类实现了`Serializable`和`Comparable`接口

```java
new File(String pathname);//"d:\\a.txt"
new File(File parent,String child);//new File("d:\\"); "b.txt"
new File(String parent,String child);//

try{
  file.createNewFile();//创建新文件
}catch (IOException e){
    e.printStackTrace()
}


```

## 常用方法
文件操作
```java
File f=new File("d:\\a.txt");

f.getName();//得到名字a.txt
f.getAbsolutePath();//绝对目录
f.getParent();//父级目录d:\\
f.length();//文件大小0(Byte)
f.exists();//文件\目录是否存在
f.isFile();//是否为文件
f.isDirectory();//是否为目录
```

目录操作
```java
f.delete();//删除文件/目录 boolean
f.mkdir();//新建目录d:\\b 创建以及目录
f.mkdirs();//创建多级目录d:\\a\\b\\c

```

java的IO技术通过流的方式实现

流的分类
字节流（8bit)字符流（按字符）
输入流、输出流
四个抽象基类
`InputStream`、 `Reader`
`OutputStream` 、`Writer`
## 字节输入流常用子类
`FileInputStream extends InputStream`
`ObjectInputStream extends InputStream`
`BufferedInputStream extends FilterInputStream extends InputStream`

```java
FileInputStream fis=null;
try{
    fis=new FileInputStream("d:\\a.txt");
    int x= fis.read();//读取一个字节的数据。返回-1就是读取完毕
    while((x=fis.read())!=-1){
        System.out.println((char)(x));

    }
}catch (FileNotFoundException e){
    e.printStackTrace();
}finally{
    try{
         fis.close();
    }catch(IOException e){
        e.printStackTrace();
    }
   
}


```

```java
FileInputStream fis=null;
byte[]bs=new byte[8];
try{
    fis=new FileInputStream("d:\\a.txt");
    // int x= fis.read();//读取一个字符的数据。返回-1就是读取完毕
    //返回读取的字节数，一般为8，部位8 说明读取介绍
    while((len=fis.read(bs))!=-1){
        System.out.println(new String(bs,0,len));

    }
}catch (FileNotFoundException e){
    e.printStackTrace();
}finally{
    try{
         fis.close();
    }catch(IOException e){
        e.printStackTrace();
    }
   
}

```






## 字节输入流
`FileOututStream extends OutputStream`
```java

FileOutputStream fos=null;
byte[]bs=new byte[8];
try{
    fos=new FileOutputStream("d:\\a.txt"); //每次都是覆盖原文件
    //fos=new FileOutputStream("d:\\a.txt",true);//追加到文件末尾
   
   //写入一个字节
   fos.write('#');//
   //写入多个字符
   fos.write("hellowolrd".getBytes());
   fos.write(str.getNytes(),str.length())
   fos.write(byte data[],int off,int length);
    
}catch (FileNotFoundException e){
    e.printStackTrace();
}finally{
    try{
         fos.close();
    }catch(IOException e){
        e.printStackTrace();
    }
   
}
```
## 字符输入输出流  FileReader，FileWriter
`FileReader extends InputStreamReader extends Reader`
`FileWriter extends OutputStreamWriter extends Writer`

```java
new FileReader(String path);
fr.read();//每次读取单个字符，返回该字符，文件末尾返回-1
fr.read(char[]);//读取多个字符到数组中返回读取到的字符数，如果到文件末尾返回-1

new FileWriter(String path,boolean append);//true附加模式，false覆盖模式
fw.write(int );//写入字符
fw.write(char);
fw.write(char[]);//写入多个字符
fw.write(char [],int off,int len);//偏移，长度
fw.write(String);//写入整个字符串
//使用后必须关闭或者flush,否则写入不到文件中
fw.flush();
```

## 节点流
*节点流*可以从一个特定的数据源梳理数据。直接处理数据`FileReader`
*包装流* `BufferedReader extends Reader  BufferedWriter extends Writer`,可以封装一个节点流例如BufferedReader可以封装任意Reader的子类（不能操作二进制文件）
```java
BufferedReader br=new BufferedReader(new FileReader(Path1));
BufferedWriter bw=new BufferedWriter(new FileWriter(Path2));
while((str=br.readLine())!=null){
    System.out.println(str);
    bw.write(str);
    bw.newLine();//换行，插入一个和系统相关的换行
} 
br.close();
bw.close();

```
`BufferedInputStream`
`BufferedOutputStream`
### 序列化
> 保存数据的时候保存数据的类型和数据的值
反序列化
> 恢复数据的时候恢复数据的值和类型

序列化需要实现`Serializable`接口或者`Externalizable`接口
`Serizlizable`是一个标记接口，没有任何方法
`Externalizable`有方法需要实现

序列化后保存的文件不是纯文本 按照他的格式保存
```java
ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream("x.dat"));
oos.write(10);//int->Integer
oos.writeBoolean(true);//boolean ->Boolean
oos.writeChar('a');
oos.writeDouble(7.5);
oos.writeUTF("hellowolrd");//String
oos.writeObject(new Dog("god",45));//Object
oos.close();
```
谁了提高版本兼容性序列化的内容建议添加SerialVersionUID(对Object序列化)
序列化不会修改static或者transient属性方法
每个属性必须实现序列化
序列化可以继承，父类是实现了序列化则子类都实现了序列化
读取的数据要和保存的数据一致
```java
ObjectInputStream ois=new ObjectInputStream(new FileInputStream("x.dat"));
ois.readInt();
ois.readBoolean();
ois.readChar();
ois.readDouble();
ois.readUTF();
ois.readObject();
ois.close();
```

## 标准输入输出流
`System.in`编译类型`InputStream`运行类型`BufferInputStream`（标准输入，键盘）
`System.out`编译类型`PrintStream`运行类型`PrintStream`（标准输出，显示屏）


```java
System.in;

Scanner sc=new Scanner(System.in);
sc.next();
```
## 转换流/包装流

字节流->字符流
字节流可以指定编码格式，指定对应编码格式之后再转化为字符流

处理文本数据的时候建议使用字符流，可以有效解决中文编码问题（utf-8，贵宾卡，gb2312）
`InputStreamReader extends Reader`
`OutputStreamReader extends Writer`

```java
InputStreamReader isr=new InputStreamReader(new FileInputStream(path),"utf8");
OutputStreamReader osr=new OutputStreamReader(new FileOutputStream(path),"utf8");
```

## 打印流
`PrintStream extends FilterOutputStream extends OutPutStream`字节输出流
可以打印到文件或者屏幕中去
`PrintWriter extends Writer`字符输出流



System.out就是一个PrintStream对象,默认标准 屏幕

修改打印流输出的位置
```java
System.setOut(new PrintStream("e:\\a.txt"));
System.out.println("hwlloworld");
```

# 补充
## Junit测试类
java语言的单元测试框架
```java
public Dog{
    @Test//可以直接run和debug选择版本5
    public void cry(){

    }
} 

```



## 绘图

```java

import javax.swing.*;
import java.awt.*;

    public class Draw extends JFrame {
        MyJpanel mp;
        public static void main(String []args){
            new myTest.Draw().draw();
        }
        public void draw(){
            mp=new MyJpanel();
            this.add(mp);
            this.setSize(400,300);
            this.setVisible(true);//可以显示
            this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//当关闭窗口时提出程序
        }
}
class MyJpanel extends Panel {
    @Override
    public void paint(Graphics g){
        super.paint(g);
        g.drawOval(10,10,100,100);//椭圆或者圆 左上角x，左下角y，宽，高
        bombImg1=Toolkit.getDefaultToolkit().getImage(Panel.class.getResource("/bomb1.jpg"));//图片显示
         //图片放置在production之下，根目录之下
        g.drawImage(bombImg3,bomb.x,bomb.y,60,60,this);
        System.out.println("运行");
    }
}

```
系统在变化的时候自动调用paint函数，比如窗口大小改变


## 事件处理机制
KeyListener是监听器可以监听键盘事件

事件监听者是一个类实现了事件监听接口
```java
class MyPanel extends Panel implements KeyLisntener{
    @Override
    public void keyPressed(keyEveny e){
        char c=(char)e.getKeyCode();    //按下的按键字符

        if(e.getKeyCode()==KeyEnent.VK_DOWN){
            //..
        }
    }
    @Override
    public void keyTyped(keyEveny e){
        
    }
    @Override
    public void keyReleased(keyEveny e){
        
    }
}
```

# 设计模式
## 单例模式
一个运行程序中一个类最多只有一个实例对象

饿汉型

可能存在资源浪费
```java
class User{
    String name="jack";
    private final User user=new User();
    private User(){}
    public User getInstance(){
        return user;
    }
}


```


懒汉型

线程可能不安全
```java
class User{
    String name="jack";
    private final User user;//=new User();
    private User(){}
    public User getInstance(){
        if(user==null){
            user=new User();
        }
        return user;
    }
}

```

## 抽象模板模式
继承父类，覆写父类里面的抽象方法

多个子类的代码相同部分保留，不同部分抽象出来覆写
```java
class A{
    abstract job();
    public long gettime(){
        long start=System.currentTimeMillis();
        job();
        long end=System.currentTimeMillis();
        return end-start;

    }
}
class B extends A{
    void job(){
        for(int i=0;i<2000;i++){
            System.out.print(i);
        }
    }
}

```

## 代理模式

```java
class ThreadProxy implements Runable{
    private Runnable target =null;//runnable接口实例
    @Override
    public void run(){
        if(target!=null){
            target.run();
        }
    }
    ThreadProxy(Runnable target){
        this.target=target;
    }
    public void start(){
        start0();
    }
    public void start0(){
        run();
    }
}


```
## 修饰器模式
例如`FileReader`与`BufferedReader`

