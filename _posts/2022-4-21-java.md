---
layout: post
title: Java常用以及数据结构
categories: study
tags : java
toc: true
---
# 常用
## `contains`函数
包含
`List.contains()`和`ArrayList.contains()`都是使用的`Object.equals(object)`
而`Object.equals()`使用的是`this==objecct`比较的而是地址不是值

在`Object`中`equals`和`==`没有任何的区别
`String`重写了`equals`的方法

```java
Person p1 = new Person(1, "张三", 20);
Person p2 = new Person(1, "张三", 20);
System.out.println("比较p1=p2  ：" + (p1==p2));//false
System.out.println("比较p1.equels(p2) :" + (p1.equals(p2)));//false

String s1 = "C博客";
String s2 = "C博客";//两个常量
System.out.println("比较s1=s2  ：" + (s1==s2));//true
System.out.println("比较s1.equels(s2) :" + (s1.equals(s2)));//true

String s3 = new String("C博客");
String s4 = new String("C博客");
System.out.println("比较s3=s4  ：" + (s3==s4));//false
System.out.println("比较s3.equels(s4) :" + (s3.equals(s4)));//true
```
字符串`String`会当作*常量*处理
对于s1,s2
String s1 = “C博客”;
1.JVM会首先去常量池中查找是否有”C博客”这个字符串常量，有的话就返回引用地址给s1，没有就将”C博客”字符串常量放入常量池，
2.再返回地址给s1，
3.s2也是”C博客”字符串常量，因此JVM会将常量池中的该字符串引用地址返回给s2，因此实际上s1和s2指向的是同一个字符串字面量，所以才会为true
对于s3,s4
1.JVM首先会去常量池中查找有没有一个叫“C博客”的字符串常量，如果有，就获取它的引用地址，没有就在常量池(jdk1.7好像常量池也在堆内)中创建一个再返回引用地址；
2.然后遇到了new，就会在堆内存中分配一块内存存储一个叫`new String()`的对象，该对象里就含有常量池中那个字符串的引用地址；
3.在栈内存中创建一个叫s3的变量，指向堆内存中的刚刚创建的对象；
4.对s4分配内存的时候，也会先去常量池中查找，因为s3已经在常量池中创建了”C博客”的字符串常量，因此就只会返回该字符串的引用地址；
5.在堆中又分配一块内存给一个叫`new String()`的对象，该对象里也有指向常量池中”C博客”字符串常量的地址；
6.在栈内存中创建一个叫s4的变量，指向堆内存中的刚刚创建的对象。
## 获取时间

```java
System.currentTimeMillis()
//1650093029236
```
## 文件操作

### 创建文件

```java
String path = "./a.properties";
File file = new File(path);
System.out.println(file.getParentFile());
if (!file.getParentFile().exists()) {
    boolean result = file.getParentFile().mkdirs();
    if (!result) {
        System.out.println("创建失败");
    }
}

```

### 打开文件

```java
try { // 防止文件建立或读取失败，用catch捕捉错误并打印，也可以throw
 
			/* 读入TXT文件 */
			String pathname = "./addressbook.txt"; // 绝对路径或相对路径都可以，这里是绝对路径，写入文件时演示相对路径
			File filename = new File(pathname); // 要读取以上路径的input。txt文件
			InputStreamReader reader = new InputStreamReader(
					new FileInputStream(filename)); // 建立一个输入流对象reader
			BufferedReader br = new BufferedReader(reader); // 建立一个对象，它把文件内容转成计算机能读懂的语言
			String line = "";
			line = br.readLine();
			while (line != null) {
				line = br.readLine(); // 一次读入一行数据
                System.out.println(line);
			}

 
		} catch (Exception e) {
            System.out.println(e);
			e.printStackTrace();
		}


```


### 写入文件

```java

try { // 防止文件建立或读取失败，用catch捕捉错误并打印，也可以throw
 
		
 
			/* 写入Txt文件 */
			File writename = new File("./addressbook.txt"); // 相对路径，如果没有则要建立一个新的output。txt文件
			writename.createNewFile(); // 创建新文件
			BufferedWriter out = new BufferedWriter(new FileWriter(writename));//覆写
			//BufferedWriter out = new BufferedWriter(new FileWriter(writename,true));//是否追加
			out.write("我会写入文件啦\r\n"); // \r\n即为换行
			out.flush(); // 把缓存区内容压入文件
			out.close(); // 最后记得关闭文件
 
		} catch (Exception e) {
            System.out.println(e);
			e.printStackTrace();
		}

```


## java读取屏幕输入


```java
import java.util.Scanner;
Scanner scanner = new Scanner(System.in); // 创建Scanner对象
System.out.print("Input your name: "); // 打印提示
String name = scanner.nextLine(); // 读取一行输入并获取字符串
System.out.print("Input your age: "); // 打印提示
int age = scanner.nextInt(); // 读取一行输入并获取整数
System.out.printf("Hi, %s, you are %d\n", name, age); // 格式化输出

```


## 数据结构比较
### 一.字符串


1.`equals()`：比较内容，值，推荐


```java
String a=new String("abc"); 
String b=new String("abc");

a.`equals(b)`;
```


2.`== `：比较地址

```java
String c="123";
String d="123";
System.out.println(c==d);  //true，在java中字符串的值是不可改变的，相同的字符串在内存中只会存一份，所以a和b指向的是同一个对象；
String a=new String("abc");
String b=new String("abc");
System.out.println(c==d); //false，此时a和b指向不同的对象。
```

`==`是比较内存地址的，内存地址相等，就返回true，地址相等，值肯定也一样，地址不相等，即使值相等也会返回false，

字符串是对象类型，所以不能用简单的“==”判断。

而用`equals（`）方法，String中重写了`equals`，不管地址是否相等，都只对值进行比较，值相等就返回true，不相等就返回false。两个String对象相等或内容相等都返回true

## 判断是否为数字，字母
### 字符char
```java
Character.isDigit(char c)　　//判断字符c是否是数字字符，如‘1’，‘2’，是则返回true，否则返回false  

Character.isLowerCase(char c)　|| Character.isUpperCase(char c)　　//判断c是否是字母字符，前面LowerCase是小写，后面UpperCase是大写，是返回True，否则返回False

Character.isLetterOrDigit(char c)　　//判断c是否是字母或数字字符，是返回true,否则返回false
Character.isLetter(char c)可以判断这些字符：

UPPERCASE_LETTER
LOWERCASE_LETTER
TITLECASE_LETTER
MODIFIER_LETTER
OTHER_LETTER
// 这些字符除了包含字母之外还包含其他字符
```

### 字符串String

```java
import java.util.regex.Pattern;
//使用正则表达式

public static boolean isInteger(String str){
    // Pattern pattern=Pattern.compile("^[-\\+]?[\\d]*$");
            Pattern pattern = Pattern.compile("[0-9]*");

    return pattern.matcher(str).matches();
}

/**
 * 判断是否是字母
 * @param str 传入字符串
 * @return 是字母返回true，否则返回false
 */
public boolean is_alpha(String str) {
    if(str==null) return false;
    return str.matches("[a-zA-Z]+");
}


/**
 * 判断是否是字母或者数字
 * @param str 传入字符串
 * @return 是字母返回true，否则返回false
 */
public  static boolean isLetterDigit(String str) {
    String regex = "^[a-z0-9A-Z]+$";
    return str.matches(regex);
}
```








## 基本类型数组
`set,list,map`等的`contains`判断只能判断地址
# java数据结构

- 基本数据类型8
  - 数值型
    - 整数 byte[1] short[2] int[4] long[8]
    - 浮点 float[4] double[8]
  - 字符型 char[2]
  - 布尔型 boolean[1]
- 引用数据类型
  - 类 class
  - 接口 interface
  - 数组 []

long类型之后需要加L或者l
浮点数默认为double类型
float类型之后需要加F或者f
```java
long a=2l;
long b=2L;

double c=1.1;
float d=1.2f;
double e=2.1f;
double f=.222;
```

浮点数=符号位+指数位+尾数位
尾数可能丢失，小数都是近似值
```java
Math.abs(num1-num2)<0.-000001//小数相比较

```


科学计数法
```java
5e10;//5乘以10的10次方
5e-10;//5乘以10的负数10次方

```

## 编码
ASCII表一共128个字符
unicode兼容ascII
utf-8，gbk变长编码
## 类型转换

###  基本数据类型转换
小到大会自动转换
大到小会报错
`char->int->long=>float->double`
`byte->short->int->long->float->double`


byte,short,char之间不会自动转换
byte,short,char 无论单独计算还是组合计算的时候会自动转化为int

复合运算符会进行类型转换
```java
byte a=1; T
a=a+1; F
a+=1;  T
a++;   T

```
赋值之前会判断所赋的值是否在改基本类型的范围内，不在则报错。
操作数转化为计算中最大的数据类型


### 基本类型与String

```java
int i = Integer.parseInt([String]); 
int i = Integer.parseInt([String],[int radix]);
int i = Integer.valueOf(my_str).intValue();

Integer x=new Integer("23"); 
boolean x=Boolean.parseBoolean(s);
byte b=Byte.parseByte(s);
short sh=Short.parseShort(s);
long l=Long.parseLong(s);
float f=Float.parseFloat(s);
double d=Double.parseDouble(s);


String s=i+"";

char c='a';
String s=c+"";

float x=2f;
String s=x+"";

double x=1.2;
String s=x+"";

String s = String.valueOf(i);
String s = Integer.toString(i);

```

## 运算
### 赋值

基本类型值为传递
引用类型为地址传递/引用传递

### 取余
a%b=a-a/b*b;
```java
10%3==1;
-10%3=-1;
10 % -3=1;
-10 %-3= -1；

```

### ++
```java
int x=2;
x=x++; // 1 temp=x; 2 x=x+1  3 x=temp;
//x=2;
int y=2;
y=++y;// 1 y=y+1 2 y=y
//y=3

```

### 逻辑运算

```java
& 逻辑与
&& 短路与
| 逻辑或
|| 短路或
! 取反
^ 逻辑异或
```


对于逻辑与`&`而言，第一个条件错误，第二个仍然会判断
对于短路与`&&`而言，第一个条件错误，第二个不再会去判断

对于逻辑或`|`而言，第一个条件正确，第二个仍然会判断
对于短路或`||`而言，第一个条件正确，第二个不再会去判断


### 位运算

- java都是有符号数
- 正数 原码，反码，补码都一样
- 负数 符号位不变洽其他位置取反
- 负数补码=反码+1
- 计算机运算使用补码


```java
& 按位与
| 按位或
^ 按位异或
~ 按位取反
<< 算术左移 符号位不变，低位补0
>> 算数右移 ,符号位不变，符号位补齐高位

>>> 逻辑右移 高位补0
无<<<

```

### 位操作
1. 利用或操作 `| `和**空格**将英文字符转换为小写
`('a' | ' ') = 'a'`
`('A' | ' ') = 'a'`

2. 利用与操作 `&` 和**下划线**将英文字符转换为大写
`('b' & '_') = 'B'`
`('B' & '_') = 'B'`

3. 利用异或操作 `^` 和**空格**进行英文字符大小写互换
`('d' ^ ' ') = 'D'`
`('D' ^ ' ') = 'd'`
以上操作能够产生奇特效果的原因在于 ASCII 编码。ASCII 字符其实就是数字，恰巧这些字符对应的数字通过位运算就能得到正确的结果

4. 判断两个数是否异号
```java
int x = -1, y = 2;
boolean f = ((x ^ y) < 0); // true

int x = 3, y = 2;
boolean f = ((x ^ y) < 0); // false
```


5. 不用临时变量交换两个数


```java
int a = 1, b = 2;
a ^= b;
b ^= a;
a ^= b;
```

6. 加一

```java
int n = 1;
n = -~n;
// 现在 n = 2
```

7. 减一

```java
int n = 2;
n = ~-n;
// 现在 n = 1
```

8. 消除1
`n & (n-1)`
这个操作是算法中常见的，作用是消除数字 n 的二进制表示中的最后一个 1。

9. 与自身**异或**为0
和 0 做异或运算的结果为它本身

```java
a ^ a = 0;
a ^ 0 = a;
```

10. 



## int
### java int最大值
```java
    int length=Integer.MAX_VALUE;
    //最小值
    int length=Integer.MIN_VALUE;
```
### 强制类型转换
```java
int a=(int)1.3;

```


### 随机数

```java
Random r = new Random();
double d1 = r.nextDouble(); // 生成[0,1.0]区间的小数
double d2 = r.nextDouble() * 7; // 生成[0,7.0]区间的小数
int i1 = r.nextInt(10); // 生成[0,10)区间的整数
int i2 = r.nextInt(18) - 3; // 生成[-3,15)区间的整数
long l1 = r.nextLong(); // 生成一个随机长整型值
boolean b1 = r.nextBoolean(); // 生成一个随机布尔型值
float f1 = r.nextFloat(); // 生成一个随机浮点型值
System.out.println("生成的[0,1.0]区间的小数是：" + d1);
System.out.println("生成的[0,7.0]区间的小数是：" + d2);
System.out.println("生成的[0,10]区间的整数是：" + i1);
System.out.println("生成的[-3,15]区间的整数是：" + i2);
System.out.println("生成一个随机长整型值：" + l1);
System.out.println("生成一个随机布尔型值：" + b1);
System.out.println("生成一个随机浮点型值：" + f1);


```


## 数组
> 数组属于引用类型，数组型数据为对象 Object


未初始化 默认值
数字 0
String null
boolean false
char \u0000
### 定义
```java

int []a={1,1,1};
int a[]={1,1,1};
int []b=new int[size];
int []c=new int[]{1,2,3};
```

### 数组长度

```java
a.length
```

### 打印数组

```java
System.out.println(Arrays.toString(array));
```

#### 打印二维数组
```java
System.out.println(Arrays.deepToString(numArray));
```
### int数组与Integer数组互转

### 数组复制



```java

 Integer[] integers = new Integer[10];
        int[] ints;
        for (int i = 0; i < integers.length; i++) {
            integers[i] = i;
        }
       ints= Arrays.stream(integers).mapToInt(Integer::valueOf).toArray();
```

### 数组截取
```java
results = Arrays.copyOfRange(results, 0, 5);
```

### 二维数组


二维数组的各个一维数组的长度可以不一致
```java
int []a[]=new int[2][2];
int a[][]=new int[2][2];

int [][]a=new int [3][];

for(int i=0;i<a.length;i++){
    a[i]=new int[i+1];
}

```


### 拷贝

- 基本类型，深拷贝和浅拷贝都是一样的，都是对原始数据的复制，修改原始数据，不会对复制数据产生影响。
- 两者的区别，在于对引用属性的复制。
  - 浅拷贝
    - 浅拷贝复制引用属性时，仅仅复制指针值，没有复制指向的对象。
  - 深拷贝
    - 深拷贝完整复制一份该属性指向的对象，


#### `System.arraycopy`（_浅拷贝_）

```java
  int[] array1 = new int[]{1,2,8,7,6};
  int[] array2 = new int[array1.length];
  System.arraycopy(array1, 0, array2, 0, array1.length);
```


#### `Arrays.copyOf`（_浅拷贝_）

```java
public static byte[] copyOfRange(byte[] original, int from, int to) 
```
> 实Arrays.copyOf()方法在底层是调用了 System.arraycopy() 方法来实现复制，即可以把Arrays.copyOf() 方法看作是 System.arraycopy() 方法的衍生方法，故它的执行机理与 System.arraycopy() 方法相同

#### 对象拷贝（ `Object.clone`）
对于**对象**而言，它是*深拷贝*，但是对于**数组**而言，它是*浅拷贝*
> 要调用这个方法，就需要我们写一个类，然后声明实现cloneable接口就好了
```java
@Override
public Object clone() throws CloneNotSupportedException {
    // TODO Auto-generated method stub
    return super.clone();
}

```
#### 数组拷贝
> 对于数组而言，它不是简单的将引用赋值为另外一个数组引用，而是创建一个新的数组。但是我们知道，对于数组本身而言，它它的元素是对象的时候，本来数组每个元素中保存的就是对象的引用，所以，拷贝过来的数组自然而言也是对象的引用，所以对于数组对象元素而言，它又是浅拷贝






### 排序
```java
Arrays.sort(arr, Collections.reverseOrder());//只能是对象类型数组
//二维数组排序
Arrays.sort(intervals, (a, b) -> {
            return a[0]==b[0]?b[1]-a[1]:a[0] - b[0];
        });
```










## 列表List
### 列表定义
```java
//引入List
import java.util.ArrayList;
import java.util.List;
//定义
List<String> list = new ArrayList<>();//接受null
List<String> list = new LinkedList<>();//接受null
List<Integer> list = sLit.of(1, 2, 5);//不接受null
```

### 添加元素
```java
list.add("apple"); // size=1
list.add("pear"); // size=2
```
### 获取长度
```java
int size=list.size();
```
### 获取元素
#### 根据位置
```java
String a=list.get(1);//t推荐arraylist
//遍历列表,迭代器
for (Iterator<String> it = list.iterator(); it.hasNext(); ) {
    String s = it.next();
    System.out.println(s);
}
for (String s : list) {
            System.out.println(s);
}
```
#### 与数组互转
```java
Integer[] array = list.toArray(new Integer[3]);
```
list打印
```java
Arrays.toString(list.toArray())
```

### 排序

1. 普通类型
```java
List<Integer>nums=new ArrayList<>();
nums.add(0);
nums.add(3);
nums.add(6);
Collectios.sort(nums);


```
2. 对象类型

```java
List<User>nums=new ArrayList<>();
nums.add(new User("李四"，78));
nums.add(new User("tom"，7));
nums.add(new User("jerry"，8));
Collectios.sort(nums);

```

```java


class User implements Comparable<User>{

　　private String name; //姓名
　　private int age; // 年龄

　　public User(String name, int age) {
　　　　this.name = name;
　　　　this.age = age;
　　}
　　// getter && setter
　　public String getName() {
　　　　return name;
　　}
　　public void setName(String name) {
　　　　this.name = name;
　　}
　　public int getAge() {
　　　　return age;
　　}
　　public void setAge(int age) {
　　this.age = age;
　　}
　　@Override
　　public String toString() {
　　　　return "User [name=" + name + ", age=" + age + "]";
　　}

　　@Override
　　public int compareTo(User user) {           
      // 重写Comparable接口的compareTo方法，根据年龄升序排列，降序修改相减顺序即可
　　　　return this.age - user.getAge();
　　}
}

```

3. 匿名内部类实现排序
```java
 Collections.sort(list, new Comparator<User>() {
　　　　    @Override
　　　　    public int compare(User u1, User u2) {
　　　　　　    int diff = u1.getAge() - u2.getAge();
　　　　　　    if (diff > 0) {
　　　　　　　　    return 1;
　　　　　　    }else if (diff < 0) {
　　　　　　　　    return -1;
　　　　　　    }
　　　　　　    return 0; //相等为0
　　　　    }
　　    }); // 按年龄排序

。

```

4. 简介方案
```java
list.sort(Comparator.comparing(User::getAge));
```


5. 降序
```java
//降序：
Collections.sort(list，Collections.reverseOrder())//list:8 7 6 5 4 2 1

```
6. 逆序
```java
//逆序；
Collections.reverse(list)//list：4 1 8 6 
```
## 字符串String
`length() `字符串的长度
`charAt()` 截取一个字符
`getChars()` 截取多个字符
`toCharArray() `转化为字符数组
`subString()` 取子字符串
```java


char chars[]={'a','b'.'c'};
String s=new String(chars);
int len=s.length();

char ch;
ch="abc".charAt(1); 返回'b'
```
### 字符串拼接
#### plus

```java
String a="";
int b=0xb;
String c=a+b;
```

#### concat

```java
//当两个量都为String类型且值不为null时，可以用concat方式。
String a="a";
String b="b";
String c= a.concat(b);
```

#### StringBuffer

```java

StringBuffer buf=new StringBuffer();
StringBuffer buf=new StringBuffer(a.length()+b.length()+c.length());//提供足够的空间
buf.append("a");
if(someCondition){
    buf.append("b");
}
buf.append("c");
String d=buf.toString();
```
#### StringBuilder的join()


## set集合
```java
import java.util.Set;

 Set<Integer> set = new HashSet<Integer>();
 add( )
//将对象添加到集合
	clear( )
// 从集合中移除所有对象
	contains( )
// 如果指定的对象是集合中的元素返回true
	isEmpty( )
// 如果集合不包含任何元素，则返回true
	iterator( )
// 返回一个Iterator对象，可用于检索对象的集合
	remove( )
// 从集合中删除指定的对象
	size( )
// 
set.toArray(myArray);
//转成Integer,String 数组无法转为int数组

//Union - 为了得到两个集合x和y的并集，我们可以使用
x.addAll(y)

// Intersection - 要获得两个集合x和y的交集，我们可以使用
x.retainAll(y)

// Subset - 要检查x是否是y的子集，我们可以使用
y.containsAll(x)

Set接口的实现
```

## map 
### 定义
```java
Map<Integer,Integer> map=new HashMap<>();
```
### 包含有某个元素
```java
map.containsKey();
```
### 获取，添加，替换元素

```java
map.get(target-nums[i]);
           
map.put(nums[i], i);
// 替换 hashMap 中是指定的 key 对应的 value。
hashmap.replace(K key, V newValue)

hashmap.replace(K key, V oldValue, V newValue)
map.getOrDefault(key,value)
```
### 常用方法
#### keyset
`keySet()`方法返回值是Map中key值的集合；entrySet()的返回值也是返回一个Set集合，此集合的类型为Map.Entry。
```java
for (String key : map.keySet()) {    
   System.out.println("key= "+ key + " and value= " + map.get(key));    
}  

```
#### Entry
`Map.Entry`是Map声明的一个内部接口，此接口为泛型，定义为Entry<K,V>。它表示Map中的一个实体（一个key-value对）。接口中有getKey(),getValue方法。
```java
Iterator<Map.Entry<String, String>> it = map.entrySet().iterator();    
while (it.hasNext()) {    
    Map.Entry<String, String> entry = it.next();    
    System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue());    
}    
//("通过Map.entrySet遍历key和value  
for (Map.Entry<String, String> entry : map.entrySet()) {    
    System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue());    
}       
  
```
#### values
```java
//通过Map.values()遍历所有的value，但不能遍历key 
for (String v : map.values()) {    
    System.out.println("value= " + v);    
}
```
### TreeMap
> 树图



## 栈 Stack
>后进先出

```java
Stack<Integer> st = new Stack<Integer>();
int a=7;
st.push(new Integer(a));
Integer b = (Integer) st.pop();

Object peek( )
// 查看堆栈顶部的对象，但不从堆栈 移除它。
boolean empty() 
// 测试堆栈是否为空。
int search(Object element)
// 返回对象在堆栈中的位置，以 1 为基数。
```

## 队列 Queue
> 先进先出

```java
Queue<String> queue = new LinkedList<String>();

offer()
// ：往队列添加元素。如果队列已满直接返回false，队列未满则直接插入并返回true；

add()
//：对offer()方法的简单封装。如果队列已满，抛出异常new IllegalStateException("Queue full")；

put()
// ：往队列里插入元素，如果队列已经满，则会一直等待直到队列为空插入新元素，或者线程被中断抛出异常.

remove()
// ：直接删除队头的元素；

peek()
// ：直接取出队头的元素，并不删除。

element()
// ：对peek方法进行简单封装，如果队头元素存在则取出并不删除，如果不存在抛出异常NoSuchElementException()；

pool()
// ：取出并删除队头的元素，当队列为空,返回null；

take()
// ：取出并删除队头的元素，当队列为空，则会一直等待直到队列有新元素可以取出，或者线程被中断抛出异常
```

### 双端队列Deque
#### 定义
```java
Deque<> deque = new LinkedList();
Deque<> que=new ArrayDeque();

```
`ArrayDeque` 大小可变的数组双端队列，不允许插入`null`。
### 常用方法

| 第一个元素 | (头部)          | 最后一个元素    | (尾部)         |
| ---------- | --------------- | --------------- | -------------- |
| 抛出异常   | 特殊值          | 抛出异常        | 特殊值         |
| 插入       | `addFirst(e)`   | `offerFirst(e)` | `addLast(e)`   | `offerLast(e)` |
| 删除       | `removeFirst()` | `pollFirst()`   | `removeLast()` | `pollLast()`   |
| 检查       | `getFirst()`    | `peekFirst()`   | `getLast()`    | `peekLast()`   |

###  PriorityQueue

> 优先级队列，同堆

#### 定义

```java
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Comparator;

Queue<String> q = new PriorityQueue<>();
//自定义比较函数
Queue<User> q = new PriorityQueue<>(new UserComparator());
class UserComparator implements Comparator<User> {
    public int compare(User u1, User u2) {
        if (u1.number.charAt(0) == u2.number.charAt(0)) {
            // 如果两人的号都是A开头或者都是V开头,比较号的大小:
            return u1.number.compareTo(u2.number);
        }
        if (u1.number.charAt(0) == 'V') {
            // u1的号码是V开头,优先级高:
            return -1;
        } else {
            return 1;
        }
    }
}

 PriorityQueue<int[]> q = new PriorityQueue<int[]>(new Comparator<int[]>() {
            public int compare(int[] m, int[] n) {
                return m[1] -n[1];
            }
        });

```

#### 插入元素

```java
q.offer("apple");
q.add("pear");
q.offer("banana");
     

```

`add(E e)`和`offer(E e)`的语义相同，都是向优先队列中插入元素
只是`Queue`接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回false。对于`PriorityQueue`这两个方法其实没什么差别。

#### 取出元素

`remove()`和`poll()`方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回null.

由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。

```java
System.out.println(q.poll()); // apple
System.out.println(q.poll()); // banana
System.out.println(q.poll()); // pear
System.out.println(q.poll()); 

```

#### 获取元素

`element()`和`peek()`的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素

二者唯一的区别是当方法失败时前者抛出异常，后者返回null。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，0下标处的那个元素既是堆顶元素。所以直接返回数组0下标处的那个元素即可。

#### 大小

```java
queue.size();
```

## pair配对

>配对提供了一种方便方式来处理简单的键值关联

```java
Pair<Integer, String> pair = new Pair<>(1, "One");
Integer key = pair.getKey();
String value = pair.getValue();
```

# Java基本知识
## java特性
- 解释性
- 跨平台
- 解释性语言
- 强类型
- 垃圾回收
- 面向对象
- 异常处理

jdk java开发环境集
jre jvm+java核心类库
jvm java运行虚拟机


`javap Dog.class` 反编译
### 常识
- 源文件包含有一个`public`类则文件名必须为该类名称。
- 一个类编译成为一个`.class`文件
- 可以在多个非`public`中写`main`方法
- 


\r回车 ，光标回到本行行首处

### 内存分配机制

- 栈，基本数据类型
- 堆，对象
- 方法区，常量池（常量，字符串等），类加载信息

执行到方法时，会开辟一片独立的栈空间。

#### 文档注释

`javadoc`
```java
/**
* @author andy
* @version 1.1
*/


```


```shell
javadoc  -d d:\\tamp -author -version Test.java

```


#### switch case
不加`break`会执行之后所有的语句直到有`break`

`switch`的表达式返回值必须是 `byte char string int short enum`
`case`中的语句必须是常量不能是变量



## 类与对象`oop`

- 对象的引用数据类型放在方法区域的常量区
- 基本数据类型，引用数据类型的地址放在堆里面。

属性可以不赋值，有默认值，局部变量必须赋值
```java
Car car;
car=new Car();
car.name="福田";
```

### 方法传参

- 基本类型传递值方法内值改变，外部不改变）
- 引用类型传递地址（方法内该边地址所含有的值改变，外部也改变）

### 方法重载
`Overload`
要求形参的类型或者个数不一致

### 可变参数

```java
public int sum(int... nums){
 int res=0;
 for(int i;i<nums.length;i++){
    res+=nums[i];
 }
 return res;
}
```

`...`表示可以接受多个参数 0或者任意个

- 可变参数的实参可以是数组
- 可变参数的本质是数组
- 可变参数之前可以有几个普通参数
- 只能有一个可变参数

### 构造方法
会默认一个无参构造方法
定义新的构造方法会覆盖，若再次想使用无参构造方法需要显式定义

1. 加载类信息，只会加载一次
2. 在堆中分配空间
3. 完成对象初始化
    1. 默认初始化（开辟空间，字段默认值）
    2. 显式初始化（类中赋予字段的值，基本数据类型赋值，引用数据类型null）
    3. 构造器初始化 （构造器中赋予字段的值，为引用数据类型开辟空间）
### this
```java
this.hashCode();//返回一个值，地址的映射
this("tom",23);//可以在构造器的第一句调用其他本类的构造器
```

### 包
>不同保存类的文件夹、目录
- 区分名字相同的类
- 管理类
- 控制访问范围
  
引用相同没拿工资不同包的类，第二个以及更多，类目必须包含包名
```java
package com.person;

java.lang.*;//默认引入，java基本包
java.util.*;//系统工具包
java.net.*;//系统网络包
java.awt.*;//页面开发，gui

```

### 访问修饰符

`public` 对外公开
`protected` 对子类和同一个包的类公开
*默认* 对同一个包的类公开
`private` 只有类本身可以访问，不对外公开

只有默认和public才可以修饰类
修饰和访问规则，方法和属性一致

非私有的属性可以有子类访问和使用

### 继承
子类构造器会默认调用父类的无参构造器，若是父类没有无参构造器，则必须指明调用的父类的构造器
```java
super();
```
`super()`只能在构造器其中使用，而且必须放在第一行。不能同时使用`super()`和`this()`.
`super`代表父类的引用

### 覆写

- 子类覆写父类的方法
- 方法名称和参数列表需要一致
- 子类的返回类型需要为父类返回类型一致或者是父类返回类型的子类
- 子类方法不能够缩小父类方法的访问权限，可以扩大

### 多态

```java
Animal animal-new Dog();//编译类型Animal,运行类型Dog
animal=new Dog();//编译类型Animal，运行类型Cat
```
- 编译类型不能改变
- 运行类型可以改变
- 运行时运行的是运行类型


#### 向上转型
父类的引用指向子类的对象
`父类 xxx=new 子类();`
可以调用父类的全部成员，按照访问规则
不可以调用子类的特有成员
调用依然是从子类开始向上寻找

#### 向下转型

`子类 xxx=（子类）父类引用；`
只能强转父类的引用，不能强转父类的对象
父类的引用必须指向当前目标类型的对象
可以调用子类类型中的所有成员



属性没有重修之说，属性看的是编译类型
`instanceOf`判断 对象是否为某类或者某类子类的对象，实例。 判断的是对象的**运行类型**

### 动态绑定机制

- 当调用对象*方法*的时候，该方法会和该对象的内存地址/运行类型绑定一致。每次在最底层子类开始寻找
- 当调用对象*属性*的时候没有动态绑定机制，那里声明，那里使用，每次从当前的编译类型的    对象类里面开始向上寻找

### static
#### 静态变量
```java
public static int count;//类静态变量 
```
可以通过对象访问，类访问，共用一个static 变量
在类加载的时候生成，存储位置不同jdk版本不同 Class实例的尾部
static变量也遵守修饰符的限定

#### 静态方法、类方法
```java
public static int sum(int []nums){
    ///
}

```

类方法中不允许使用this super
静态方法只能访问静态成员
非静态方法可以访问静态和非静态成员  


### main 方法

```shell
java Hello tom cat kack
```
```java
public void main( String []args){
    for(String s:args){
        System.out.print(s);
    }
}
//tomcatjack
```
### 代码块

初始化对象的时候隐式调用普通代码块
static修饰或者不要修饰，类代码块普通代码块
普通代码块调用优先于构造函数
类加载时调用static静态代码块

```java
class User{
    String name;
    String pwd;
    //每次带哦用每种构造方法之前调用代码块
    static{
        System.out.println("代码块");
    }
    User(){

    }
    User(String name){
        this.name=name;
    }
}
```

### 创建对象的调用顺序
优先级一致按照顺序执行
1. 父类静态代码和静态属性
2. 子类的静态代码和静态属性
3. 父类的普通代码和普通属性
4. 父类的构造方法
5. 子类的普通代码和普通属性
6. 子类的构造方法
### final
- 修饰类
  - 类不在被继承
- 修饰方法
    - 父类的方法不会被子类覆写
- 修饰属性
  - 类的属性不会被改变
- 修饰局部变量
  - 遍历不会被修改

`static`和`final`可怜和修饰属性，在使用时不会导致类加载
```java
public final static x=1;

System.out.println(new user.x);
```

### abstract
1. 抽象方法、就是没有方法体，没实现的方法
2. 一个类有抽象方法的时候，该类必须是抽象类
3. 抽象类不能被实例化
4. 抽象类可以没有抽象方法
5. 不能修饰属性
6. 一个类继承了抽象类，除非自己也是抽象类，否则必须实现抽象类的所有抽象方法
7. 抽象方法不能使用`pricate`，`static`，`final`修饰
```java
public abstract void cry();

```

### 接口 interface
```java
public interface Usb{
    abstract void start();
    default public void stop(){
        System.out.println("ok");
    } 
    public static void out(){
        System.out.println("out");
    }
}
class Phone implements Usb{
    @Override
    void start(){

    }

}

class Computer{
    public void work(Usb usb ){
        usb.start();
    }
    public static void main(String []args){
        Computer c=new Computer();
        c.work(new Phone());
    }
}
```
1. 类需要`implements`实现所有接口中的方法
2. 可以通过接口调用方法
3. jdk7.0之前接口都是抽象方法没有方法体，jdk8.0之后接口可以有静态方法，默认方法，可以有具体的方法实现
4. 在接口中，方法前的`abstract`可省略,所有方法都是`public`方法
5. 接口中存在方法体必须要有default修饰
6. 抽象类实现接口可以不用实现接口中的方法 
7. 一个类可以同时实现多个接口
8. 接口中可以有属性，默认是`public static final`
9. 接口不能继承类但是可以继承多个接口`extends
10. 接口的修饰符只能是默认或者`public`

#### 接口的多态
形参是接口，可用于接受实现了该接口的类的实例对象

可以使用接口板指向实现了该接口的类的实例对象
```java
Usb u=new Phone();

```

多态的传递性

```java
interface ih{}
interface ig extends ih()
class T implements ig{}
ih h=newT();//相当于T也实现了ih接口
ig g=newT();
```


### 内部类
类的五大成员 方法、属性、代码块、构造器、内部类
内部类的最大特点就是可以直接访问私有成员、


内部类的分类
根据定义位置
- 定义在外部类的局部位置上，比如方法中  
  - 局部内部类，有类名
  - 匿名内部类，无类名
- 定义在外部类的成员位置上
  - 成员内部类，没有`static`修饰
  - 静态内部类，有`static`修饰

#### 局部内部类


```java
class Outer{
    {
        class inner03{

        }
    }
    class Inner{

    }
    public void hi(){
        final class Inner01{

        }
    }

}

```

可以访问外部类的私用成员
不能添加访问修饰符们可以使用final，不能使用`static`
作用域仅限定义的方法或者类之内
外部不能访问
内外部成员重名时`Outer.this.m1;类名+this+属性名

#### 匿名内部类
没有名字，本质是类，内部类，同时是一个对象
创建匿名类之后立刻就创建了实例返还给接口，该内部类只是使用一次

可以基于类或者接口
不能添加修饰符
匿名局部类是一个局部变量
```java
interface A{}
A a=new A(){//编译类型接口A，运行类型匿名内部类
//系统给予他一个i那个字Outerxxx

}

class B{
    String name;
    B(String name){
        this.name=name;
    }
    void cry(){

    }
}
B b=new B("jack"){//编译类型B，运行类型匿名内部类，该匿名内部类继承于B
    @Override
    void cry(){

    }
};
```


匿名类当作实参传递

```java
interface A{
    void cry();
}

void fun1(A a){
    a.show();
}
public static void main(String []aargs){
    fun1(new A(){
        @Override
        void cry(){

        }
    });
}
```

#### 成员内部类

```java
class Outer{
    class Inner{
    }
   
}

```

外部其他类调用Inner类
```java
//1
Outer outer=new Outer();
Outer.Inner in=outer.new Inner();

//2
使用方法返回
Outer.Inner in=outer.getInner();


```

#### 静态内部类
```java
class Outer{
    static class Inner{

    }
}

```
可以访问外部类的所有静态成员，不能访问非静态成员
作为一个静态成员可用public等修饰
作用域为外部类
```java
//满足访问权限

Outer.Inner in=new Outer.Inner();
```

## jdk源码

### `equal`函数

`==`基本类型比较数值，引用类型比较地址
普通类默认继承`Object`的`equal`方法
`Object`的`equal`方法使用`==`比较

覆写父类的`equal`方法可以来比较内容的值

### `hashcode()`
提供对象的哈希码值提高系统提供的哈希表的性能

- 哈希值主要根据地址来的但不等于地址，返回不同的整数
- 相同对象(不同引用，相同对象)哈希值一致
- 不同对象哈希值原则上不同

### `toString`

sout时自动调用

###  `Finalize`
1. 对象被回收时候，系统自动调用，子类可重写实现一些**释放资源**的操作
2. 当某个对象没有任何引用的时候，vm就认为是可以回收的在回收之前调用
3. 系统来决定垃圾回收，也可以通过`System.gc()`来触发垃圾回收机制 

实际中不会使用

## 枚举类`enum`

```java
enum Season{
    SPRING("春天","温暖"),
    SUMMER("夏天","炎热"),
    WINTER("东天","寒冷"),
    FALL("秋天","凉爽")，
    WHAT;//需要写在最前面
    private String name;
    private String temp;
    Season(){

    }
    Season(String name,String temp){
        this.name=name;
        this.tamp=temp;
    }
    public void work(){

    }
}
System.out.println(Season.WINTER);

```
1. 默认继承`Enum`类
2. 无参构造器可以省略括号
3. 枚举对象必须放在首位
4. 默认属性都是`final static`的
5. 不能再继承其他类 

### 枚举类的方法
`name()`返回名字WINTER
`ordinal()`返回编号，按照定义的顺序
`toString()`返回当前对象名
`values`返回一个枚举类数组，包含所有的枚举类对象
`valueOf`字符串转化为枚举类对象，字符串必须为已存在的枚举类对象名称

## 注解`Annotation`
### 常见注解
```java
@Override 用于方法前，表示重写父类的方法
@Deprecated 代表已经方法，类弃用过时
@SuppressWarinings 抑制编译器警告


```

```java
@SuppressWarningd({"all"})//可适合类、方法、语句中
//all,所有警告，boxing抑制封装拆装作业相关的警告
//cast抑制强转型作业的警告。。。。

```

### 元注解
> 修饰注解的注解
```java
@Retention 指定注解的作用时间范围 SOURCE 编译器使用之后丢弃,CLASS 保留在class文件中jvm运行时不会保留,RUNTIME jvm保留注释可以通过反射获取该注释
@Tatget 指定注解的使用的范围
@Documented 指定该注解是否会在javadoc体现
@Inherited 子类会继承父类有的注解 
```

## 异常
```java
try{
    int x=10/0;
}
catch(Exception e){
    System.out.println(e.getMessage());
}

```
- `Throwable`
  - 错误 `error` 会崩溃
    - 栈溢出 `StackOverFlowError`
    - 内存不足 `OutOfMemoryError`
  - 异常 `exception`
    - 运行时异常 `RuntimeException`
      - 空指针异常 `NullPointerException`
      - 算术异常 `ArithmeticException`
      - 数组越界 `ArrayIndexOutOfBoundsException`
      - 类型转换异常 `ClassCastException`
      - 数字格式 `NumberFormatException`
      - ...
    - 编译时异常,一下统称编译异常,必须处理
    - 文件未找到异常 `FileNotFoundException`
    - `ClassNodeFoundException`
    - ...

### 异常处理
#### try catch finally

```java
try{

//代码可能有异常
}catch (Exception e){
    //有异常发生就需要执行
}finally{
    //不管有无异常发生始终需要执行代码
    //通常用于执行释放资源
}

```

可以多个catch捕捉异常，子类异常在前面父类异常在后面
finally里面的内容比强制执行，即使trycatch中有return的话return会执行但是不返回，执行finally语句之后返回
#### throws
抛出异常
遇到异常要么trycatch处理，要么抛出异常给上一级处理，可以接着向上传递异常，trycatch和throws二选一
直到main方法异常传给jvm
jvm会输出异常信息中止程序运行
系统默认是throws
```java
void fun() throws FileNotFoundException {

}

```

子类覆写父类方法抛出异常是父类的异常的子异常或者相同异常

对下一级抛出的编译异常必须处理或者抛出，而运行异常可以不做处理

`throws`和`throw`的区别
`throw`放在方法体内，用于抛出一个一个异常对象
`throws`在方法声明处，跟这个异常处理的类型

### 自定义异常


```java
class AgeException extends RuntimeException{
    public AgeException(String message){
        super(message);
    }
}


public static void main(String []args){
    int age=10;
    if(age<12){
        throw new Ageexception("太小了");
    }
}
```
## 包装类`Wrapper`
对八种基本类型包装成的引用类型 类
- `Serializable`,实现了`Comparable`接口
  - boolean Boolean
  - char Character
- `Serializable` -> `Number` （父类）,实现了`Comparable`接口
  - byte Byte
  - short Short
  - int Integer
  - long Long
  - float Float
  - double Double


### 拆箱装箱
手动
```java
//装箱
int n=10;
Integer in=new Integer(n);
Integer in1=Integer.valueOf(n);

//拆箱
int x=in.intValue();

```

自动
```java
//装箱
int n=10;
Integer in=n;//底层依然是Integer.valueOf(n);
//拆箱
int m=in;//底层依然是in.intValue();
```

### 比较
```java
Integer x=1;
Integer x=128;
//-128~127中会直接使用cache中存储,Integer的缓存机制
//超过则new Integer(128);
```

`==`比较的是地址不是值，若有基本类型就是在比对值


## String 类
1. 继承自`Object`接口，实现了`Comparable`（可以比较大小 ），`Serializable`（可以串行化，就可以在网络传输），`CharSequence`接口
2. 字符串的字符一个占零个字节，使用unicode编码
3. 不可被继承
4. 字符串最终被保留到`private final char value[]`字符数组中.value的地址不可修改，其中的部分字符可修改
构建方法
```java
String s1=new String();
String s1=new String(String original);
String s1=new String(char sc[]);
String s1=new String(char sc[],int startIndex,int count);
String s1=new String(byte bc[]);
String s1=new String(byte bc[],int startIndex,int count);
```
### String 对象特性
```java
String s1="Tom";//字符串常量是"Tom",存放于常量池中
//new 是在堆中开辟空间，该空间指向常量池中的"Tom"
s.intern();//返回常量池中的地址
```


```java
String s="123"+"abc";//编译器优化直接生成123abc常量只有一个对象
```

```java
String a="123";
String b="abc";
String c=a+b;//一共三个对象
//1 StringBuilder sb=new StringBuilder();
//2 sb.append("123");
//3 sb.append("abc");
//4 return sb.toString();//   在堆中new 一个字符串对象指向常量池中的"123abc"
```

常量相加看池，变量相加看的是堆

### String常用方法
```java
charAt(int x);
toCharArray();
toLowerCase();
toUpperCase();
concat(String );//连接
replace("_","=");//返回结果才是替换过的
String strs[]=s.split(" ");

s1.compareTo(String s2);//len1-len2,  return s1-s2;
//先比较字符，返回不同字符的差值。若共有长度部分的字符相同则返回长度差值
//0 两者值完全相等，>0,s1大于说s2，<0 s2大于s1

String s=String.format("我叫做%s,我的年龄是%d,我的体重是%d,我的性别是%c","tom",23,123,'f');
//占位符 ，%s.%d,%c,%.2f(保留两位小数，四舍五入)
```

### StringBuffer
继承自`AbstactStringBuilder`,实现了`Serializable`接口即可以串行化
在父类中的`char value[]`中存放字符串内容，存放在堆中
StringBuffer为final类
```java
StringBuffer sb=new StringBuffer(int x);//默认为16,不足时候自动扩容，不用创建新对象
StringBuffer sb=new StringBuffer("hello");//"hello".length()+16
sb.append(String ,char, int);
sb.append(10).append('p').append(90.9).append(true);
sb.delete(start,end);//删除[start,end)的字符
sb.,replace(start,end,String);//[start,end)替换为String
sb.indexOf(String);//第一次出现的位置
sb.insert(index,String);//在index之前插入String原index处及以后后移




String s=sb.toString();
String s=new String(sb);
```

若`append null`字符串会加入"null"字符串

### StringBuilder
> 一个可变的字符序列，与StringBuffer兼容的Api。 被设计为StringBuffer的一个简易置换，
> 未作线程处理不是线程安全，在单线程时候可以替换，比StringBuffer要快



```java
StringBuilder sb=new StringBuilder("hello");//"hello".length()+16
sb.append(String ,char, int);
sb.delete(start,end);//删除[start,end)的字符
```


# 设计模式
## 单例模式
一个运行程序中一个类最多只有一个实例对象

饿汉型

可能存在资源浪费
```java
class User{
    String name="jack";
    private final User user=new User();
    private User(){}
    public User getInstance(){
        return user;
    }
}


```


懒汉型

线程可能不安全
```java
class User{
    String name="jack";
    private final User user;//=new User();
    private User(){}
    public User getInstance(){
        if(user==null){
            user=new User();
        }
        return user;
    }
}

```

## 抽象模板模式
继承父类，覆写父类里面的抽象方法

多个子类的代码相同部分保留，不同部分抽象出来覆写
```java
class A{
    abstract job();
    public long gettime(){
        long start=System.currentTimeMillis();
        job();
        long end=System.currentTimeMillis();
        return end-start;

    }
}
class B extends A{
    void job(){
        for(int i=0;i<2000;i++){
            System.out.print(i);
        }
    }
}

```




