---
layout: post
title: Java常用以及数据结构
categories: study
tags : java
toc: true
---
# 常用
## 获取时间

```java
System.currentTimeMillis()
//1650093029236
```
## 文件操作

### 创建文件

```java
String path = "./a.properties";
File file = new File(path);
System.out.println(file.getParentFile());
if (!file.getParentFile().exists()) {
    boolean result = file.getParentFile().mkdirs();
    if (!result) {
        System.out.println("创建失败");
    }
}

```

### 打开文件

```java
try { // 防止文件建立或读取失败，用catch捕捉错误并打印，也可以throw
 
			/* 读入TXT文件 */
			String pathname = "./addressbook.txt"; // 绝对路径或相对路径都可以，这里是绝对路径，写入文件时演示相对路径
			File filename = new File(pathname); // 要读取以上路径的input。txt文件
			InputStreamReader reader = new InputStreamReader(
					new FileInputStream(filename)); // 建立一个输入流对象reader
			BufferedReader br = new BufferedReader(reader); // 建立一个对象，它把文件内容转成计算机能读懂的语言
			String line = "";
			line = br.readLine();
			while (line != null) {
				line = br.readLine(); // 一次读入一行数据
                System.out.println(line);
			}

 
		} catch (Exception e) {
            System.out.println(e);
			e.printStackTrace();
		}


```


### 写入文件

```java

try { // 防止文件建立或读取失败，用catch捕捉错误并打印，也可以throw
 
		
 
			/* 写入Txt文件 */
			File writename = new File("./addressbook.txt"); // 相对路径，如果没有则要建立一个新的output。txt文件
			writename.createNewFile(); // 创建新文件
			BufferedWriter out = new BufferedWriter(new FileWriter(writename));//覆写
			//BufferedWriter out = new BufferedWriter(new FileWriter(writename,true));//是否追加
			out.write("我会写入文件啦\r\n"); // \r\n即为换行
			out.flush(); // 把缓存区内容压入文件
			out.close(); // 最后记得关闭文件
 
		} catch (Exception e) {
            System.out.println(e);
			e.printStackTrace();
		}

```


## java读取屏幕输入


```java
import java.util.Scanner;
Scanner scanner = new Scanner(System.in); // 创建Scanner对象
System.out.print("Input your name: "); // 打印提示
String name = scanner.nextLine(); // 读取一行输入并获取字符串
System.out.print("Input your age: "); // 打印提示
int age = scanner.nextInt(); // 读取一行输入并获取整数
System.out.printf("Hi, %s, you are %d\n", name, age); // 格式化输出

```


## 数据结构比较
### 一.字符串


1.`equals()`：比较内容，值，推荐


```java
String a=new String("abc"); 
String b=new String("abc");

a.`equals(b)`;
```


2.`== `：比较地址

```java
String c="123";
String d="123";
System.out.println(c==d);  //true，在java中字符串的值是不可改变的，相同的字符串在内存中只会存一份，所以a和b指向的是同一个对象；
String a=new String("abc");
String b=new String("abc");
System.out.println(c==d); //false，此时a和b指向不同的对象。
```

`==`是比较内存地址的，内存地址相等，就返回true，地址相等，值肯定也一样，地址不相等，即使值相等也会返回false，

字符串是对象类型，所以不能用简单的“==”判断。

而用`equals（`）方法，String中重写了`equals`，不管地址是否相等，都只对值进行比较，值相等就返回true，不相等就返回false。两个String对象相等或内容相等都返回true

## 判断是否为数字，字母
### 字符char
```java
Character.isDigit(char c)　　//判断字符c是否是数字字符，如‘1’，‘2’，是则返回true，否则返回false  

Character.isLowerCase(char c)　|| Character.isUpperCase(char c)　　//判断c是否是字母字符，前面LowerCase是小写，后面UpperCase是大写，是返回True，否则返回False

Character.isLetterOrDigit(char c)　　//判断c是否是字母或数字字符，是返回true,否则返回false
Character.isLetter(char c)可以判断这些字符：

UPPERCASE_LETTER
LOWERCASE_LETTER
TITLECASE_LETTER
MODIFIER_LETTER
OTHER_LETTER
// 这些字符除了包含字母之外还包含其他字符
```

### 字符串String

```java
import java.util.regex.Pattern;
//使用正则表达式

public static boolean isInteger(String str){
    // Pattern pattern=Pattern.compile("^[-\\+]?[\\d]*$");
            Pattern pattern = Pattern.compile("[0-9]*");

    return pattern.matcher(str).matches();
}

/**
 * 判断是否是字母
 * @param str 传入字符串
 * @return 是字母返回true，否则返回false
 */
public boolean is_alpha(String str) {
    if(str==null) return false;
    return str.matches("[a-zA-Z]+");
}


/**
 * 判断是否是字母或者数字
 * @param str 传入字符串
 * @return 是字母返回true，否则返回false
 */
public  static boolean isLetterDigit(String str) {
    String regex = "^[a-z0-9A-Z]+$";
    return str.matches(regex);
}
```




# java数据结构

- 基本数据类型8
  - 数值型
    - 整数 byte[1] short[2] int[4] long[8]
    - 浮点 float[4] double[8]
  - 字符型 char[2]
  - 布尔型 boolean[1]
- 引用数据类型
  - 类 class
  - 接口 interface
  - 数组 []

long类型之后需要加L或者l
浮点数默认为double类型
float类型之后需要加F或者f
```java
long a=2l;
long b=2L;

double c=1.1;
float d=1.2f;
double e=2.1f;
double f=.222;
```

浮点数=符号位+指数位+尾数位
尾数可能丢失，小数都是近似值
```java
Math.abs(num1-num2)<0.-000001//小数相比较

```


科学计数法
```java
5e10;//5乘以10的10次方
5e-10;//5乘以10的负数10次方

```

## 编码
ASCII表一共128个字符
unicode兼容ascII
utf-8，gbk变长编码
## 类型转换

###  基本数据类型转换
小到大会自动转换
大到小会报错
`char->int->long=>float->double`
`byte->short->int->long->float->double`


byte,short,char之间不会自动转换
byte,short,char 无论单独计算还是组合计算的时候会自动转化为int

复合运算符会进行类型转换
```java
byte a=1; T
a=a+1; F
a+=1;  T
a++;   T

```
赋值之前会判断所赋的值是否在改基本类型的范围内，不在则报错。
操作数转化为计算中最大的数据类型


### 基本类型与String

```java
int i = Integer.parseInt([String]); 
int i = Integer.parseInt([String],[int radix]);
int i = Integer.valueOf(my_str).intValue();

boolean x=Boolean.parseBoolean(s);
byte b=Byte.parseByte(s);
short sh=Short.parseShort(s);
long l=Long.parseLong(s);
float f=Float.parseFloat(s);
double d=Double.parseDouble(s);


String s=i+"";

char c='a';
String s=c+"";

float x=2f;
String s=x+"";

double x=1.2;
String s=x+"";

String s = String.valueOf(i);
String s = Integer.toString(i);

```

## 运算
### 赋值

基本类型值为传递
引用类型为地址传递/引用传递

### 取余
a%b=a-a/b*b;
```java
10%3==1;
-10%3=-1;
10 % -3=1;
-10 %-3= -1；

```

### ++
```java
int x=2;
x=x++; // 1 temp=x; 2 x=x+1  3 x=temp;
//x=2;
int y=2;
y=++y;// 1 y=y+1 2 y=y
//y=3

```

### 逻辑运算

```java
& 逻辑与
&& 短路与
| 逻辑或
|| 短路或
! 取反
^ 逻辑异或
```


对于逻辑与`&`而言，第一个条件错误，第二个仍然会判断
对于短路与`&&`而言，第一个条件错误，第二个不再会去判断

对于逻辑或`|`而言，第一个条件正确，第二个仍然会判断
对于短路或`||`而言，第一个条件正确，第二个不再会去判断


### 位运算

- java都是有符号数
- 正数 原码，反码，补码都一样
- 负数 符号位不变洽其他位置取反
- 负数补码=反码+1
- 计算机运算使用补码


```java
& 按位与
| 按位或
^ 按位异或
~ 按位取反
<< 算术左移 符号位不变，低位补0
>> 算数右移 ,符号位不变，符号位补齐高位

>>> 逻辑右移 高位补0
无<<<

```


## int
### java int最大值
```java
    int length=Integer.MAX_VALUE;
    //最小值
    int length=Integer.MIN_VALUE;
```
### 强制类型转换
```java
int a=(int)1.3;

```


### 随机数

```java
Random r = new Random();
double d1 = r.nextDouble(); // 生成[0,1.0]区间的小数
double d2 = r.nextDouble() * 7; // 生成[0,7.0]区间的小数
int i1 = r.nextInt(10); // 生成[0,10]区间的整数
int i2 = r.nextInt(18) - 3; // 生成[-3,15)区间的整数
long l1 = r.nextLong(); // 生成一个随机长整型值
boolean b1 = r.nextBoolean(); // 生成一个随机布尔型值
float f1 = r.nextFloat(); // 生成一个随机浮点型值
System.out.println("生成的[0,1.0]区间的小数是：" + d1);
System.out.println("生成的[0,7.0]区间的小数是：" + d2);
System.out.println("生成的[0,10]区间的整数是：" + i1);
System.out.println("生成的[-3,15]区间的整数是：" + i2);
System.out.println("生成一个随机长整型值：" + l1);
System.out.println("生成一个随机布尔型值：" + b1);
System.out.println("生成一个随机浮点型值：" + f1);


```


## 数组
> 数组属于引用类型，数组型数据为对象 Object


未初始化 默认值
数字 0
String null
boolean false
char \u0000
### 定义
```java

int []a={1,1,1};
int a[]={1,1,1};
int []b=new int[size];
int []c=new int[]{1,2,3};
```

### 数组长度

```java
a.length
```

### 打印数组

```java
System.out.println(Arrays.toString(array));
```

#### 打印二维数组
```java
System.out.println(Arrays.deepToString(numArray));
```
### int数组与Integer数组互转
```java

 Integer[] integers = new Integer[10];
        int[] ints;
        for (int i = 0; i < integers.length; i++) {
            integers[i] = i;
        }
       ints= Arrays.stream(integers).mapToInt(Integer::valueOf).toArray();
```

### 数组截取
```java
results = Arrays.copyOfRange(results, 0, 5);
```

### 二维数组

二维数组的各个一维数组的长度可以不一致
```java
int []a[]=new int[2][2];
int a[][]=new int[2][2];

int [][]a=new int [3][];

for(int i=0;i<a.length;i++){
    a[i]=new int[i+1];
}

```


## 列表List
### 列表定义
```java
//引入List
import java.util.ArrayList;
import java.util.List;
//定义
List<String> list = new ArrayList<>();//接受null
List<String> list = new LinkedList<>();//接受null
List<Integer> list = sLit.of(1, 2, 5);//不接受null
```

### 添加元素
```java
list.add("apple"); // size=1
list.add("pear"); // size=2
```
### 获取长度
```java
int size=list.size();
```
### 获取元素
#### 根据位置
```java
String a=list.get(1);//t推荐arraylist
//遍历列表,迭代器
for (Iterator<String> it = list.iterator(); it.hasNext(); ) {
    String s = it.next();
    System.out.println(s);
}
for (String s : list) {
            System.out.println(s);
}
```
#### 与数组互转
```java
Integer[] array = list.toArray(new Integer[3]);
```
list打印
```java
Arrays.toString(list.toArray())
```


## 字符串String
`length() `字符串的长度
`charAt()` 截取一个字符
`getChars()` 截取多个字符
`toCharArray() `转化为字符数组
`subString()` 取子字符串
```java


char chars[]={'a','b'.'c'};
String s=new String(chars);
int len=s.length();

char ch;
ch="abc".charAt(1); 返回'b'
```
### 字符串拼接
#### plus

```java
String a="";
int b=0xb;
String c=a+b;
```

#### concat

```java
//当两个量都为String类型且值不为null时，可以用concat方式。
String a="a";
String b="b";
String c= a.concat(b);
```

#### StringBuffer

```java

StringBuffer buf=new StringBuffer();
StringBuffer buf=new StringBuffer(a.length()+b.length()+c.length());//提供足够的空间
buf.append("a");
if(someCondition){
    buf.append("b");
}
buf.append("c");
String d=buf.toString();
```
#### StringBuilder的join()


## set集合
```java
import java.util.Set;

 Set<Integer> set = new HashSet<Integer>();
 add( )
//将对象添加到集合
	clear( )
// 从集合中移除所有对象
	contains( )
// 如果指定的对象是集合中的元素返回true
	isEmpty( )
// 如果集合不包含任何元素，则返回true
	iterator( )
// 返回一个Iterator对象，可用于检索对象的集合
	remove( )
// 从集合中删除指定的对象
	size( )
// 
set.toArray(myArray);
//转成Integer,String 数组无法转为int数组

//Union - 为了得到两个集合x和y的并集，我们可以使用
x.addAll(y)

// Intersection - 要获得两个集合x和y的交集，我们可以使用
x.retainAll(y)

// Subset - 要检查x是否是y的子集，我们可以使用
y.containsAll(x)

Set接口的实现
```

## map 
### 定义
```java
Map<Integer,Integer> map=new HashMap<>();
```
### 包含有某个元素
```java
map.containsKey();
```
### 获取，添加，替换元素

```java
map.get(target-nums[i]);
           
map.put(nums[i], i);
// 替换 hashMap 中是指定的 key 对应的 value。
hashmap.replace(K key, V newValue)

hashmap.replace(K key, V oldValue, V newValue)
map.getOrDefault(key,value)
```
### 常用方法
#### keyset
`keySet()`方法返回值是Map中key值的集合；entrySet()的返回值也是返回一个Set集合，此集合的类型为Map.Entry。
```java
for (String key : map.keySet()) {    
   System.out.println("key= "+ key + " and value= " + map.get(key));    
}  

```
#### Entry
`Map.Entry`是Map声明的一个内部接口，此接口为泛型，定义为Entry<K,V>。它表示Map中的一个实体（一个key-value对）。接口中有getKey(),getValue方法。
```java
Iterator<Map.Entry<String, String>> it = map.entrySet().iterator();    
while (it.hasNext()) {    
    Map.Entry<String, String> entry = it.next();    
    System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue());    
}    
//("通过Map.entrySet遍历key和value  
for (Map.Entry<String, String> entry : map.entrySet()) {    
    System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue());    
}       
  
```
#### values
```java
//通过Map.values()遍历所有的value，但不能遍历key 
for (String v : map.values()) {    
    System.out.println("value= " + v);    
}
```
### TreeMap
> 树图



## 栈 Stack
>后进先出

```java
Stack<Integer> st = new Stack<Integer>();
int a=7;
st.push(new Integer(a));
Integer b = (Integer) st.pop();

Object peek( )
// 查看堆栈顶部的对象，但不从堆栈 移除它。
boolean empty() 
// 测试堆栈是否为空。
int search(Object element)
// 返回对象在堆栈中的位置，以 1 为基数。
```

## 队列 Queue
> 先进先出

```java
Queue<String> queue = new LinkedList<String>();

offer()
// ：往队列添加元素。如果队列已满直接返回false，队列未满则直接插入并返回true；

add()
//：对offer()方法的简单封装。如果队列已满，抛出异常new IllegalStateException("Queue full")；

put()
// ：往队列里插入元素，如果队列已经满，则会一直等待直到队列为空插入新元素，或者线程被中断抛出异常.

remove()
// ：直接删除队头的元素；

peek()
// ：直接取出队头的元素，并不删除。

element()
// ：对peek方法进行简单封装，如果队头元素存在则取出并不删除，如果不存在抛出异常NoSuchElementException()；

pool()
// ：取出并删除队头的元素，当队列为空,返回null；

take()
// ：取出并删除队头的元素，当队列为空，则会一直等待直到队列有新元素可以取出，或者线程被中断抛出异常
```

### 双端队列Deque
#### 定义
```java
Deque<> deque = new LinkedList();
Deque<> que=new ArrayDeque();

```
`ArrayDeque` 大小可变的数组双端队列，不允许插入`null`。
### 常用方法

| 第一个元素 | (头部)          | 最后一个元素    | (尾部)         |
| ---------- | --------------- | --------------- | -------------- |
| 抛出异常   | 特殊值          | 抛出异常        | 特殊值         |
| 插入       | `addFirst(e)`   | `offerFirst(e)` | `addLast(e)`   | `offerLast(e)` |
| 删除       | `removeFirst()` | `pollFirst()`   | `removeLast()` | `pollLast()`   |
| 检查       | `getFirst()`    | `peekFirst()`   | `getLast()`    | `peekLast()`   |

###  PriorityQueue

> 优先级队列，同堆

#### 定义

```java
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Comparator;

Queue<String> q = new PriorityQueue<>();
//自定义比较函数
Queue<User> q = new PriorityQueue<>(new UserComparator());
class UserComparator implements Comparator<User> {
    public int compare(User u1, User u2) {
        if (u1.number.charAt(0) == u2.number.charAt(0)) {
            // 如果两人的号都是A开头或者都是V开头,比较号的大小:
            return u1.number.compareTo(u2.number);
        }
        if (u1.number.charAt(0) == 'V') {
            // u1的号码是V开头,优先级高:
            return -1;
        } else {
            return 1;
        }
    }
}

```

#### 插入元素

```java
q.offer("apple");
q.add("pear");
q.offer("banana");
     

```

`add(E e)`和`offer(E e)`的语义相同，都是向优先队列中插入元素
只是`Queue`接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回false。对于`PriorityQueue`这两个方法其实没什么差别。

#### 取出元素

`remove()`和`poll()`方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回null.

由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。

```java
System.out.println(q.poll()); // apple
System.out.println(q.poll()); // banana
System.out.println(q.poll()); // pear
System.out.println(q.poll()); 

```

#### 获取元素

`element()`和`peek()`的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素

二者唯一的区别是当方法失败时前者抛出异常，后者返回null。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，0下标处的那个元素既是堆顶元素。所以直接返回数组0下标处的那个元素即可。

#### 大小

```java
queue.size();
```

## pair配对

>配对提供了一种方便方式来处理简单的键值关联

```java
Pair<Integer, String> pair = new Pair<>(1, "One");
Integer key = pair.getKey();
String value = pair.getValue();
```

# Java基本知识
## java特性
- 解释性
- 跨平台
- 解释性语言
- 强类型
- 垃圾回收
- 面向对象
- 异常处理

jdk java开发环境集
jre jvm+java核心类库
jvm java运行虚拟机


`javap Dog.class` 反编译
### 常识
- 源文件包含有一个`public`类则文件名必须为该类名称。
- 一个类编译成为一个`.class`文件
- 可以在多个非`public`中写`main`方法
- 


\r回车 ，光标回到本行行首处

### 内存分配机制

- 栈，基本数据类型
- 堆，对象
- 方法区，常量池（常量，字符串等），类加载信息

执行到方法时，会开辟一片独立的栈空间。

#### 文档注释

`javadoc`
```java
/**
* @author andy
* @version 1.1
*/


```


```shell
javadoc  -d d:\\tamp -author -version Test.java

```


#### switch case
不加`break`会执行之后所有的语句直到有`break`

`switch`的表达式返回值必须是 `byte char string int short enum`
`case`中的语句必须是常量不能是变量



## 类与对象`oop`

- 对象的引用数据类型放在方法区域的常量区
- 基本数据类型，引用数据类型的地址放在堆里面。

属性可以不赋值，有默认值，局部变量必须赋值
```java
Car car;
car=new Car();
car.name="福田";
```

### 方法传参

- 基本类型传递值方法内值改变，外部不改变）
- 引用类型传递地址（方法内该边地址所含有的值改变，外部也改变）

### 方法重载
`Overload`
要求形参的类型或者个数不一致

### 可变参数

```java
public int sum(int... nums){
 int res=0;
 for(int i;i<nums.length;i++){
    res+=nums[i];
 }
 return res;
}
```

`...`表示可以接受多个参数 0或者任意个

- 可变参数的实参可以是数组
- 可变参数的本质是数组
- 可变参数之前可以有几个普通参数
- 只能有一个可变参数

### 构造方法
会默认一个无参构造方法
定义新的构造方法会覆盖，若再次想使用无参构造方法需要显式定义

1. 加载类信息，只会加载一次
2. 在堆中分配空间
3. 完成对象初始化
    1. 默认初始化（开辟空间，字段默认值）
    2. 显式初始化（类中赋予字段的值，基本数据类型赋值，引用数据类型null）
    3. 构造器初始化 （构造器中赋予字段的值，为引用数据类型开辟空间）
### this
```java
this.hashCode();//返回一个值，地址的映射
this("tom",23);//可以在构造器的第一句调用其他本类的构造器
```

### 包
>不同保存类的文件夹、目录
- 区分名字相同的类
- 管理类
- 控制访问范围
  
引用相同没拿工资不同包的类，第二个以及更多，类目必须包含包名
```java
package com.person;

java.lang.*;//默认引入，java基本包
java.util.*;//系统工具包
java.net.*;//系统网络包
java.awt.*;//页面开发，gui

```

### 访问修饰符

`public` 对外公开
`protected` 对子类和同一个包的类公开
默认 对同一个包的类公开
`private` 只有类本身可以访问，不对外公开

只有默认和public才可以修饰类
修饰和访问规则，方法和属性一致

非私有的属性可以有子类访问和使用

### 继承
子类构造器会默认调用父类的无参构造器，若是父类没有无参构造器，则必须指明调用的父类的构造器
```java
super();
```
`super()`只能在构造器其中使用，而且必须放在第一行。不能同时使用`super()`和`this()`.
`super`代表父类的引用

### 覆写

- 子类覆写父类的方法
- 方法名称和参数列表需要一致
- 子类的返回类型需要为父类返回类型一致或者是父类返回类型的子类
- 子类方法不能够缩小父类方法的访问权限，可以扩大

### 多态

```java
Animal animal-new Dog();//编译类型Animal,运行类型Dog
animal=new Dog();//编译类型Animal，运行类型Cat
```
- 编译类型不能改变
- 运行类型可以改变
- 运行时运行的是运行类型


#### 向上转型
父类的引用指向子类的对象
父类 xxx=new 子类();
可以调用父类的全部成员，按照访问规则
不可以调用子类的特有成员
调用依然是从子类开始向上寻找

#### 向下转型

子类 xxx=（子类）父类引用；
只能强转父类的引用，不能强转父类的对象
父类的引用必须指向当前目标类型的对象
可以调用子类类型中的所有成员



属性没有重修额之说，属性看的是编译类型
`instanceOf`判断 对象是否为某类或者某类子类的对象，实例。 判断的是对象的运行类型

### 动态绑定机制

- 当调用对象方法的时候，该方法会和该对象的内存地址/运行类型绑定一致。每次在最底层子类开始寻找
- 当调用对象属性的时候没有动态绑定机制，那里声明，那里使用，每次从当前的对象类里面开始向上寻找


