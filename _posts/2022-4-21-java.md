---
layout: post
title: Java常用以及数据结构
categories: study
tags : java
toc: true
---
# 常用
## `contains`函数
包含
`List.contains()`和`ArrayList.contains()`都是使用的`Object.equals(object)`
而`Object.equals()`使用的是`this==objecct`比较的而是地址不是值

在`Object`中`equals`和`==`没有任何的区别
`String`重写了`equals`的方法

```java
Person p1 = new Person(1, "张三", 20);
Person p2 = new Person(1, "张三", 20);
System.out.println("比较p1=p2  ：" + (p1==p2));//false
System.out.println("比较p1.equels(p2) :" + (p1.equals(p2)));//false

String s1 = "C博客";
String s2 = "C博客";//两个常量
System.out.println("比较s1=s2  ：" + (s1==s2));//true
System.out.println("比较s1.equels(s2) :" + (s1.equals(s2)));//true

String s3 = new String("C博客");
String s4 = new String("C博客");
System.out.println("比较s3=s4  ：" + (s3==s4));//false
System.out.println("比较s3.equels(s4) :" + (s3.equals(s4)));//true
```
字符串`String`会当作*常量*处理
对于s1,s2
String s1 = “C博客”;
1.JVM会首先去常量池中查找是否有”C博客”这个字符串常量，有的话就返回引用地址给s1，没有就将”C博客”字符串常量放入常量池，
2.再返回地址给s1，
3.s2也是”C博客”字符串常量，因此JVM会将常量池中的该字符串引用地址返回给s2，因此实际上s1和s2指向的是同一个字符串字面量，所以才会为true
对于s3,s4
1.JVM首先会去常量池中查找有没有一个叫“C博客”的字符串常量，如果有，就获取它的引用地址，没有就在常量池(jdk1.7好像常量池也在堆内)中创建一个再返回引用地址；
2.然后遇到了new，就会在堆内存中分配一块内存存储一个叫`new String()`的对象，该对象里就含有常量池中那个字符串的引用地址；
3.在栈内存中创建一个叫s3的变量，指向堆内存中的刚刚创建的对象；
4.对s4分配内存的时候，也会先去常量池中查找，因为s3已经在常量池中创建了”C博客”的字符串常量，因此就只会返回该字符串的引用地址；
5.在堆中又分配一块内存给一个叫`new String()`的对象，该对象里也有指向常量池中”C博客”字符串常量的地址；
6.在栈内存中创建一个叫s4的变量，指向堆内存中的刚刚创建的对象。
## 获取时间

```java
System.currentTimeMillis()
//1650093029236
```
## 文件操作

### 创建文件

```java
String path = "./a.properties";
File file = new File(path);
System.out.println(file.getParentFile());
if (!file.getParentFile().exists()) {
    boolean result = file.getParentFile().mkdirs();
    if (!result) {
        System.out.println("创建失败");
    }
}

```

### 打开文件

```java
try { // 防止文件建立或读取失败，用catch捕捉错误并打印，也可以throw
 
			/* 读入TXT文件 */
			String pathname = "./addressbook.txt"; // 绝对路径或相对路径都可以，这里是绝对路径，写入文件时演示相对路径
			File filename = new File(pathname); // 要读取以上路径的input。txt文件
			InputStreamReader reader = new InputStreamReader(
					new FileInputStream(filename)); // 建立一个输入流对象reader
			BufferedReader br = new BufferedReader(reader); // 建立一个对象，它把文件内容转成计算机能读懂的语言
			String line = "";
			line = br.readLine();
			while (line != null) {
				line = br.readLine(); // 一次读入一行数据
                System.out.println(line);
			}

 
		} catch (Exception e) {
            System.out.println(e);
			e.printStackTrace();
		}


```


### 写入文件

```java

try { // 防止文件建立或读取失败，用catch捕捉错误并打印，也可以throw
 
		
 
			/* 写入Txt文件 */
			File writename = new File("./addressbook.txt"); // 相对路径，如果没有则要建立一个新的output。txt文件
			writename.createNewFile(); // 创建新文件
			BufferedWriter out = new BufferedWriter(new FileWriter(writename));//覆写
			//BufferedWriter out = new BufferedWriter(new FileWriter(writename,true));//是否追加
			out.write("我会写入文件啦\r\n"); // \r\n即为换行
			out.flush(); // 把缓存区内容压入文件
			out.close(); // 最后记得关闭文件
 
		} catch (Exception e) {
            System.out.println(e);
			e.printStackTrace();
		}

```


## java读取屏幕输入


```java
import java.util.Scanner;
Scanner scanner = new Scanner(System.in); // 创建Scanner对象
System.out.print("Input your name: "); // 打印提示
String name = scanner.nextLine(); // 读取一行输入并获取字符串
System.out.print("Input your age: "); // 打印提示
int age = scanner.nextInt(); // 读取一行输入并获取整数
System.out.printf("Hi, %s, you are %d\n", name, age); // 格式化输出

```


## 数据结构比较
### 一.字符串


1.`equals()`：比较内容，值，推荐


```java
String a=new String("abc"); 
String b=new String("abc");

a.`equals(b)`;
```


2.`== `：比较地址

```java
String c="123";
String d="123";
System.out.println(c==d);  //true，在java中字符串的值是不可改变的，相同的字符串在内存中只会存一份，所以a和b指向的是同一个对象；
String a=new String("abc");
String b=new String("abc");
System.out.println(c==d); //false，此时a和b指向不同的对象。
```

`==`是比较内存地址的，内存地址相等，就返回true，地址相等，值肯定也一样，地址不相等，即使值相等也会返回false，

字符串是对象类型，所以不能用简单的“==”判断。

而用`equals（`）方法，String中重写了`equals`，不管地址是否相等，都只对值进行比较，值相等就返回true，不相等就返回false。两个String对象相等或内容相等都返回true

## 判断是否为数字，字母
### 字符char
```java
Character.isDigit(char c)　　//判断字符c是否是数字字符，如‘1’，‘2’，是则返回true，否则返回false  

Character.isLowerCase(char c)　|| Character.isUpperCase(char c)　　//判断c是否是字母字符，前面LowerCase是小写，后面UpperCase是大写，是返回True，否则返回False

Character.isLetterOrDigit(char c)　　//判断c是否是字母或数字字符，是返回true,否则返回false
Character.isLetter(char c)可以判断这些字符：

UPPERCASE_LETTER
LOWERCASE_LETTER
TITLECASE_LETTER
MODIFIER_LETTER
OTHER_LETTER
// 这些字符除了包含字母之外还包含其他字符
```

### 字符串String

```java
import java.util.regex.Pattern;
//使用正则表达式

public static boolean isInteger(String str){
    // Pattern pattern=Pattern.compile("^[-\\+]?[\\d]*$");
            Pattern pattern = Pattern.compile("[0-9]*");

    return pattern.matcher(str).matches();
}

/**
 * 判断是否是字母
 * @param str 传入字符串
 * @return 是字母返回true，否则返回false
 */
public boolean is_alpha(String str) {
    if(str==null) return false;
    return str.matches("[a-zA-Z]+");
}


/**
 * 判断是否是字母或者数字
 * @param str 传入字符串
 * @return 是字母返回true，否则返回false
 */
public  static boolean isLetterDigit(String str) {
    String regex = "^[a-z0-9A-Z]+$";
    return str.matches(regex);
}
```








## 基本类型数组
`set,list,map`等的`contains`判断只能判断地址
# java数据结构

- 基本数据类型8
  - 数值型
    - 整数 byte[1] short[2] int[4] long[8]
    - 浮点 float[4] double[8]
  - 字符型 char[2]
  - 布尔型 boolean[1]
- 引用数据类型
  - 类 class
  - 接口 interface
  - 数组 []

long类型之后需要加L或者l
浮点数默认为double类型
float类型之后需要加F或者f
```java
long a=2l;
long b=2L;

double c=1.1;
float d=1.2f;
double e=2.1f;
double f=.222;
```

浮点数=符号位+指数位+尾数位
尾数可能丢失，小数都是近似值
```java
Math.abs(num1-num2)<0.-000001//小数相比较

```


科学计数法
```java
5e10;//5乘以10的10次方
5e-10;//5乘以10的负数10次方

```

## 编码
ASCII表一共128个字符
unicode兼容ascII
utf-8，gbk变长编码
## 类型转换

###  基本数据类型转换
小到大会自动转换
大到小会报错
`char->int->long=>float->double`
`byte->short->int->long->float->double`


byte,short,char之间不会自动转换
byte,short,char 无论单独计算还是组合计算的时候会自动转化为int

复合运算符会进行类型转换
```java
byte a=1; T
a=a+1; F
a+=1;  T
a++;   T

```
赋值之前会判断所赋的值是否在改基本类型的范围内，不在则报错。
操作数转化为计算中最大的数据类型


### 基本类型与String

```java
int i = Integer.parseInt([String]); 
int i = Integer.parseInt([String],[int radix]);
int i = Integer.valueOf(my_str).intValue();

Integer x=new Integer("23"); 
boolean x=Boolean.parseBoolean(s);
byte b=Byte.parseByte(s);
short sh=Short.parseShort(s);
long l=Long.parseLong(s);
float f=Float.parseFloat(s);
double d=Double.parseDouble(s);


String s=i+"";

char c='a';
String s=c+"";

float x=2f;
String s=x+"";

double x=1.2;
String s=x+"";

String s = String.valueOf(i);
String s = Integer.toString(i);

```

## 运算
### 赋值

基本类型值为传递
引用类型为地址传递/引用传递

### 取余
a%b=a-a/b*b;
```java
10%3==1;
-10%3=-1;
10 % -3=1;
-10 %-3= -1；

```

### ++
```java
int x=2;
x=x++; // 1 temp=x; 2 x=x+1  3 x=temp;
//x=2;
int y=2;
y=++y;// 1 y=y+1 2 y=y
//y=3

```

### 逻辑运算

```java
& 逻辑与
&& 短路与
| 逻辑或
|| 短路或
! 取反
^ 逻辑异或
```


对于逻辑与`&`而言，第一个条件错误，第二个仍然会判断
对于短路与`&&`而言，第一个条件错误，第二个不再会去判断

对于逻辑或`|`而言，第一个条件正确，第二个仍然会判断
对于短路或`||`而言，第一个条件正确，第二个不再会去判断


### 位运算

- java都是有符号数
- 正数 原码，反码，补码都一样
- 负数 符号位不变洽其他位置取反
- 负数补码=反码+1
- 计算机运算使用补码


```java
& 按位与
| 按位或
^ 按位异或
~ 按位取反
<< 算术左移 符号位不变，低位补0
>> 算数右移 ,符号位不变，符号位补齐高位

>>> 逻辑右移 高位补0
无<<<

```

### 位操作
1. 利用或操作 `| `和**空格**将英文字符转换为小写
`('a' | ' ') = 'a'`
`('A' | ' ') = 'a'`

2. 利用与操作 `&` 和**下划线**将英文字符转换为大写
`('b' & '_') = 'B'`
`('B' & '_') = 'B'`

3. 利用异或操作 `^` 和**空格**进行英文字符大小写互换
`('d' ^ ' ') = 'D'`
`('D' ^ ' ') = 'd'`
以上操作能够产生奇特效果的原因在于 ASCII 编码。ASCII 字符其实就是数字，恰巧这些字符对应的数字通过位运算就能得到正确的结果

4. 判断两个数是否异号
   
```java
int x = -1, y = 2;
boolean f = ((x ^ y) < 0); // true

int x = 3, y = 2;
boolean f = ((x ^ y) < 0); // false
```


5. 不用临时变量交换两个数


```java
int a = 1, b = 2;
a ^= b;
b ^= a;
a ^= b;
```

6. 加一

```java
int n = 1;
n = -~n;
// 现在 n = 2
```

7. 减一

```java
int n = 2;
n = ~-n;
// 现在 n = 1
```

8. 消除1
`n & (n-1)`
这个操作是算法中常见的，作用是消除数字 n 的二进制表示中的最后一个 1。

9. 与自身**异或**为0
和 0 做异或运算的结果为它本身

```java
a ^ a = 0;
a ^ 0 = a;
```

10. 



## int
### java int最大值
```java
    int length=Integer.MAX_VALUE;
    //最小值
    int length=Integer.MIN_VALUE;
```
### 强制类型转换
```java
int a=(int)1.3;

```


### 随机数

```java
Random r = new Random();
double d1 = r.nextDouble(); // 生成[0,1.0]区间的小数
double d2 = r.nextDouble() * 7; // 生成[0,7.0]区间的小数
int i1 = r.nextInt(10); // 生成[0,10)区间的整数
int i2 = r.nextInt(18) - 3; // 生成[-3,15)区间的整数
long l1 = r.nextLong(); // 生成一个随机长整型值
boolean b1 = r.nextBoolean(); // 生成一个随机布尔型值
float f1 = r.nextFloat(); // 生成一个随机浮点型值
System.out.println("生成的[0,1.0]区间的小数是：" + d1);
System.out.println("生成的[0,7.0]区间的小数是：" + d2);
System.out.println("生成的[0,10]区间的整数是：" + i1);
System.out.println("生成的[-3,15]区间的整数是：" + i2);
System.out.println("生成一个随机长整型值：" + l1);
System.out.println("生成一个随机布尔型值：" + b1);
System.out.println("生成一个随机浮点型值：" + f1);


```


## 数组
> 数组属于引用类型，数组型数据为对象 Object


未初始化 默认值
数字 0
String null
boolean false
char \u0000
### 定义
```java

int []a={1,1,1};
int a[]={1,1,1};
int []b=new int[size];
int []c=new int[]{1,2,3};
```

### 数组长度

```java
a.length
```

### 打印数组

```java
System.out.println(Arrays.toString(array));
```

#### 打印二维数组
```java
System.out.println(Arrays.deepToString(numArray));
```
### int数组与Integer数组互转

### 数组复制



```java

 Integer[] integers = new Integer[10];
        int[] ints;
        for (int i = 0; i < integers.length; i++) {
            integers[i] = i;
        }
       ints= Arrays.stream(integers).mapToInt(Integer::valueOf).toArray();
```

### 数组截取
```java
results = Arrays.copyOfRange(results, 0, 5);
```

### 二维数组


二维数组的各个一维数组的长度可以不一致
```java
int []a[]=new int[2][2];
int a[][]=new int[2][2];

int [][]a=new int [3][];

for(int i=0;i<a.length;i++){
    a[i]=new int[i+1];
}

```


### 拷贝

- 基本类型，深拷贝和浅拷贝都是一样的，都是对原始数据的复制，修改原始数据，不会对复制数据产生影响。
- 两者的区别，在于对引用属性的复制。
  - 浅拷贝
    - 浅拷贝复制引用属性时，仅仅复制指针值，没有复制指向的对象。
  - 深拷贝
    - 深拷贝完整复制一份该属性指向的对象，


#### `System.arraycopy`（_浅拷贝_）

```java
  int[] array1 = new int[]{1,2,8,7,6};
  int[] array2 = new int[array1.length];
  System.arraycopy(array1, 0, array2, 0, array1.length);
```


#### `Arrays.copyOf`（_浅拷贝_）

```java
public static byte[] copyOfRange(byte[] original, int from, int to) 
```
> 实Arrays.copyOf()方法在底层是调用了 System.arraycopy() 方法来实现复制，即可以把Arrays.copyOf() 方法看作是 System.arraycopy() 方法的衍生方法，故它的执行机理与 System.arraycopy() 方法相同

#### 对象拷贝（ `Object.clone`）
对于**对象**而言，它是*深拷贝*，但是对于**数组**而言，它是*浅拷贝*
> 要调用这个方法，就需要我们写一个类，然后声明实现cloneable接口就好了


```java
@Override
public Object clone() throws CloneNotSupportedException {
    // TODO Auto-generated method stub
    return super.clone();
}

```

#### 数组拷贝
> 对于数组而言，它不是简单的将引用赋值为另外一个数组引用，而是创建一个新的数组。但是我们知道，对于数组本身而言，它它的元素是对象的时候，本来数组每个元素中保存的就是对象的引用，所以，拷贝过来的数组自然而言也是对象的引用，所以对于数组对象元素而言，它又是浅拷贝




### 排序

```java
Arrays.sort(arr, Collections.reverseOrder());//只能是对象类型数组
//二维数组排序
Arrays.sort(intervals, (a, b) -> {
            return a[0]==b[0]?b[1]-a[1]:a[0] - b[0];
        });
```










## 列表List
### 列表定义
```java
//引入List
import java.util.ArrayList;
import java.util.List;
//定义
List<String> list = new ArrayList<>();//接受null
List<String> list = new LinkedList<>();//接受null
List<Integer> list = sLit.of(1, 2, 5);//不接受null
```


```java
List list=new ArrayList();
List list1=new ArrayList();
list.add("jack");
list.add(10);//new Integer(10);
list.add(true);//
list.clear();//清空
list1.addAll(list);//添加多个

list1.containsAll(list);//true判断有无list
list1.removeAll(list);//删除list
```
### 添加元素
```java
list.add("apple"); // size=1
list.add("pear"); // size=2
```
### 获取长度
```java
int size=list.size();
```
### 获取元素
#### 根据位置
```java
String a=list.get(1);//t推荐arraylist
//遍历列表,迭代器
for (Iterator<String> it = list.iterator(); it.hasNext(); ) {
    String s = it.next();
    System.out.println(s);
}
for (String s : list) {
            System.out.println(s);
}
```
#### 与数组互转
```java
Integer[] array = list.toArray(new Integer[3]);
```
list打印
```java
Arrays.toString(list.toArray())
```

### 排序

1. 普通类型

```java
List<Integer>nums=new ArrayList<>();
nums.add(0);
nums.add(3);
nums.add(6);
Collectios.sort(nums);
```

2. 对象类型

```java
List<User>nums=new ArrayList<>();
nums.add(new User("李四"，78));
nums.add(new User("tom"，7));
nums.add(new User("jerry"，8));
Collectios.sort(nums);

```


```java
class User implements Comparable<User>{

　　private String name; //姓名
　　private int age; // 年龄

　　public User(String name, int age) {
　　　　this.name = name;
　　　　this.age = age;
　　}
　　// getter && setter
　　public String getName() {
　　　　return name;
　　}
　　public void setName(String name) {
　　　　this.name = name;
　　}
　　public int getAge() {
　　　　return age;
　　}
　　public void setAge(int age) {
　　this.age = age;
　　}
　　@Override
　　public String toString() {
　　　　return "User [name=" + name + ", age=" + age + "]";
　　}

　　@Override
　　public int compareTo(User user) {           
      // 重写Comparable接口的compareTo方法，根据年龄升序排列，降序修改相减顺序即可
　　　　return this.age - user.getAge();
　　}
}

```

3. 匿名内部类实现排序

```java
 Collections.sort(list, new Comparator<User>() {
　　　　    @Override
　　　　    public int compare(User u1, User u2) {
　　　　　　    int diff = u1.getAge() - u2.getAge();
　　　　　　    if (diff > 0) {
　　　　　　　　    return 1;
　　　　　　    }else if (diff < 0) {
　　　　　　　　    return -1;
　　　　　　    }
　　　　　　    return 0; //相等为0
　　　　    }
　　    }); // 按年龄排序

。

```

4. 简介方案

```java
list.sort(Comparator.comparing(User::getAge));
```

5. 降序

```java
//降序：
Collections.sort(list，Collections.reverseOrder())//list:8 7 6 5 4 2 1

```

6. 逆序

```java
//逆序；
Collections.reverse(list)//list：4 1 8 6 
```

## 字符串String
`length() `字符串的长度
`charAt()` 截取一个字符
`getChars()` 截取多个字符
`toCharArray() `转化为字符数组
`subString()` 取子字符串
```java


char chars[]={'a','b'.'c'};
String s=new String(chars);
int len=s.length();

char ch;
ch="abc".charAt(1); 返回'b'
```
### 字符串拼接
#### plus

```java
String a="";
int b=0xb;
String c=a+b;
```

#### concat

```java
//当两个量都为String类型且值不为null时，可以用concat方式。
String a="a";
String b="b";
String c= a.concat(b);
```

#### StringBuffer

```java

StringBuffer buf=new StringBuffer();
StringBuffer buf=new StringBuffer(a.length()+b.length()+c.length());//提供足够的空间
buf.append("a");
if(someCondition){
    buf.append("b");
}
buf.append("c");
String d=buf.toString();
```
#### StringBuilder的join()


## set集合
```java
import java.util.Set;

 Set<Integer> set = new HashSet<Integer>();
 add( )
//将对象添加到集合
	clear( )
// 从集合中移除所有对象
	contains( )
// 如果指定的对象是集合中的元素返回true
	isEmpty( )
// 如果集合不包含任何元素，则返回true
	iterator( )
// 返回一个Iterator对象，可用于检索对象的集合
	remove( )
// 从集合中删除指定的对象
	size( )
// 
set.toArray(myArray);
//转成Integer,String 数组无法转为int数组

//Union - 为了得到两个集合x和y的并集，我们可以使用
x.addAll(y)

// Intersection - 要获得两个集合x和y的交集，我们可以使用
x.retainAll(y)

// Subset - 要检查x是否是y的子集，我们可以使用
y.containsAll(x)

Set接口的实现
```

## map 
### 定义
```java
Map<Integer,Integer> map=new HashMap<>();
```
### 包含有某个元素
```java
map.containsKey();
```
### 获取，添加，替换元素

```java
map.get(target-nums[i]);
           
map.put(nums[i], i);
// 替换 hashMap 中是指定的 key 对应的 value。
hashmap.replace(K key, V newValue)

hashmap.replace(K key, V oldValue, V newValue)
map.getOrDefault(key,value)
```
### 常用方法
#### keyset
`keySet()`方法返回值是Map中key值的集合；entrySet()的返回值也是返回一个Set集合，此集合的类型为Map.Entry。
```java
for (String key : map.keySet()) {    
   System.out.println("key= "+ key + " and value= " + map.get(key));    
}  

```
#### Entry
`Map.Entry`是Map声明的一个内部接口，此接口为泛型，定义为Entry<K,V>。它表示Map中的一个实体（一个key-value对）。接口中有getKey(),getValue方法。
```java
Iterator<Map.Entry<String, String>> it = map.entrySet().iterator();    
while (it.hasNext()) {    
    Map.Entry<String, String> entry = it.next();    
    System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue());    
}    
//("通过Map.entrySet遍历key和value  
for (Map.Entry<String, String> entry : map.entrySet()) {    
    System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue());    
}       
  
```
#### values
```java
//通过Map.values()遍历所有的value，但不能遍历key 
for (String v : map.values()) {    
    System.out.println("value= " + v);    
}
```
### TreeMap
> 树图



## 栈 Stack
>后进先出

```java
Stack<Integer> st = new Stack<Integer>();
int a=7;
st.push(new Integer(a));
Integer b = (Integer) st.pop();

Object peek( )
// 查看堆栈顶部的对象，但不从堆栈 移除它。
boolean empty() 
// 测试堆栈是否为空。
int search(Object element)
// 返回对象在堆栈中的位置，以 1 为基数。
```

## 队列 Queue
> 先进先出

```java
Queue<String> queue = new LinkedList<String>();

offer()
// ：往队列添加元素。如果队列已满直接返回false，队列未满则直接插入并返回true；

add()
//：对offer()方法的简单封装。如果队列已满，抛出异常new IllegalStateException("Queue full")；

put()
// ：往队列里插入元素，如果队列已经满，则会一直等待直到队列为空插入新元素，或者线程被中断抛出异常.

remove()
// ：直接删除队头的元素；

peek()
// ：直接取出队头的元素，并不删除。

element()
// ：对peek方法进行简单封装，如果队头元素存在则取出并不删除，如果不存在抛出异常NoSuchElementException()；

pool()
// ：取出并删除队头的元素，当队列为空,返回null；

take()
// ：取出并删除队头的元素，当队列为空，则会一直等待直到队列有新元素可以取出，或者线程被中断抛出异常
```

### 双端队列Deque
#### 定义
```java
Deque<> deque = new LinkedList();
Deque<> que=new ArrayDeque();

```
`ArrayDeque` 大小可变的数组双端队列，不允许插入`null`。
### 常用方法

| 第一个元素 | (头部)          | 最后一个元素    | (尾部)         |
| ---------- | --------------- | --------------- | -------------- |
| 抛出异常   | 特殊值          | 抛出异常        | 特殊值         |
| 插入       | `addFirst(e)`   | `offerFirst(e)` | `addLast(e)`   | `offerLast(e)` |
| 删除       | `removeFirst()` | `pollFirst()`   | `removeLast()` | `pollLast()`   |
| 检查       | `getFirst()`    | `peekFirst()`   | `getLast()`    | `peekLast()`   |

###  PriorityQueue

> 优先级队列，同堆

#### 定义

```java
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Comparator;

Queue<String> q = new PriorityQueue<>();
//自定义比较函数
Queue<User> q = new PriorityQueue<>(new UserComparator());
class UserComparator implements Comparator<User> {
    public int compare(User u1, User u2) {
        if (u1.number.charAt(0) == u2.number.charAt(0)) {
            // 如果两人的号都是A开头或者都是V开头,比较号的大小:
            return u1.number.compareTo(u2.number);
        }
        if (u1.number.charAt(0) == 'V') {
            // u1的号码是V开头,优先级高:
            return -1;
        } else {
            return 1;
        }
    }
}

 PriorityQueue<int[]> q = new PriorityQueue<int[]>(new Comparator<int[]>() {
            public int compare(int[] m, int[] n) {
                return m[1] -n[1];
            }
        });

```

#### 插入元素

```java
q.offer("apple");
q.add("pear");
q.offer("banana");
     

```

`add(E e)`和`offer(E e)`的语义相同，都是向优先队列中插入元素
只是`Queue`接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回false。对于`PriorityQueue`这两个方法其实没什么差别。

#### 取出元素

`remove()`和`poll()`方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回null.

由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。

```java
System.out.println(q.poll()); // apple
System.out.println(q.poll()); // banana
System.out.println(q.poll()); // pear
System.out.println(q.poll()); 

```

#### 获取元素

`element()`和`peek()`的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素

二者唯一的区别是当方法失败时前者抛出异常，后者返回null。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，0下标处的那个元素既是堆顶元素。所以直接返回数组0下标处的那个元素即可。

#### 大小

```java
queue.size();
```

## pair配对

>配对提供了一种方便方式来处理简单的键值关联

```java
Pair<Integer, String> pair = new Pair<>(1, "One");
Integer key = pair.getKey();
String value = pair.getValue();
```

# Java基本知识
## java特性
- 解释性
- 跨平台
- 解释性语言
- 强类型
- 垃圾回收
- 面向对象
- 异常处理

jdk java开发环境集
jre jvm+java核心类库
jvm java运行虚拟机


`javap Dog.class` 反编译
### 常识
- 源文件包含有一个`public`类则文件名必须为该类名称。
- 一个类编译成为一个`.class`文件
- 可以在多个非`public`中写`main`方法
- 


\r回车 ，光标回到本行行首处

### 内存分配机制

- 栈，基本数据类型
- 堆，对象
- 方法区，常量池（常量，字符串等），类加载信息

执行到方法时，会开辟一片独立的栈空间。

#### 文档注释

`javadoc`
```java
/**
* @author andy
* @version 1.1
*/


```


```shell
javadoc  -d d:\\tamp -author -version Test.java

```


#### switch case
不加`break`会执行之后所有的语句直到有`break`

`switch`的表达式返回值必须是 `byte char string int short enum`
`case`中的语句必须是常量不能是变量



## 类与对象`oop`

- 对象的引用数据类型放在方法区域的常量区
- 基本数据类型，引用数据类型的地址放在堆里面。

属性可以不赋值，有默认值，局部变量必须赋值
```java
Car car;
car=new Car();
car.name="福田";
```

### 方法传参

- 基本类型传递值方法内值改变，外部不改变）
- 引用类型传递地址（方法内该边地址所含有的值改变，外部也改变）

### 方法重载
`Overload`
要求形参的类型或者个数不一致

### 可变参数

```java
public int sum(int... nums){
 int res=0;
 for(int i;i<nums.length;i++){
    res+=nums[i];
 }
 return res;
}
```

`...`表示可以接受多个参数 0或者任意个

- 可变参数的实参可以是数组
- 可变参数的本质是数组
- 可变参数之前可以有几个普通参数
- 只能有一个可变参数

### 构造方法
会默认一个无参构造方法
定义新的构造方法会覆盖，若再次想使用无参构造方法需要显式定义

1. 加载类信息，只会加载一次
2. 在堆中分配空间
3. 完成对象初始化
    1. 默认初始化（开辟空间，字段默认值）
    2. 显式初始化（类中赋予字段的值，基本数据类型赋值，引用数据类型null）
    3. 构造器初始化 （构造器中赋予字段的值，为引用数据类型开辟空间）
### this
```java
this.hashCode();//返回一个值，地址的映射
this("tom",23);//可以在构造器的第一句调用其他本类的构造器
```

### 包
>不同保存类的文件夹、目录
- 区分名字相同的类
- 管理类
- 控制访问范围
  
引用相同没拿工资不同包的类，第二个以及更多，类目必须包含包名
```java
package com.person;

java.lang.*;//默认引入，java基本包
java.util.*;//系统工具包
java.net.*;//系统网络包
java.awt.*;//页面开发，gui

```

### 访问修饰符

`public` 对外公开
`protected` 对子类和同一个包的类公开
*默认* 对同一个包的类公开
`private` 只有类本身可以访问，不对外公开

只有默认和public才可以修饰类
修饰和访问规则，方法和属性一致

非私有的属性可以有子类访问和使用

### 继承
子类构造器会默认调用父类的无参构造器，若是父类没有无参构造器，则必须指明调用的父类的构造器
```java
super();
```
`super()`只能在构造器其中使用，而且必须放在第一行。不能同时使用`super()`和`this()`.
`super`代表父类的引用

### 覆写

- 子类覆写父类的方法
- 方法名称和参数列表需要一致
- 子类的返回类型需要为父类返回类型一致或者是父类返回类型的子类
- 子类方法不能够缩小父类方法的访问权限，可以扩大

### 多态

```java
Animal animal-new Dog();//编译类型Animal,运行类型Dog
animal=new Dog();//编译类型Animal，运行类型Cat
```
- 编译类型不能改变
- 运行类型可以改变
- 运行时运行的是运行类型


#### 向上转型
父类的引用指向子类的对象
`父类 xxx=new 子类();`
可以调用父类的全部成员，按照访问规则
不可以调用子类的特有成员
调用依然是从子类开始向上寻找

#### 向下转型

`子类 xxx=（子类）父类引用；`
只能强转父类的引用，不能强转父类的对象
父类的引用必须指向当前目标类型的对象
可以调用子类类型中的所有成员



属性没有重修之说，属性看的是编译类型
`instanceOf`判断 对象是否为某类或者某类子类的对象，实例。 判断的是对象的**运行类型**

### 动态绑定机制

- 当调用对象*方法*的时候，该方法会和该对象的内存地址/运行类型绑定一致。每次在最底层子类开始寻找
- 当调用对象*属性*的时候没有动态绑定机制，那里声明，那里使用，每次从当前的编译类型的    对象类里面开始向上寻找

### static
#### 静态变量
```java
public static int count;//类静态变量 
```
可以通过对象访问，类访问，共用一个static 变量
在类加载的时候生成，存储位置不同jdk版本不同 Class实例的尾部
static变量也遵守修饰符的限定

#### 静态方法、类方法
```java
public static int sum(int []nums){
    ///
}

```

类方法中不允许使用this super
静态方法只能访问静态成员
非静态方法可以访问静态和非静态成员  


### main 方法

```shell
java Hello tom cat kack
```
```java
public void main( String []args){
    for(String s:args){
        System.out.print(s);
    }
}
//tomcatjack
```
### 代码块

初始化对象的时候隐式调用普通代码块
static修饰或者不要修饰，类代码块普通代码块
普通代码块调用优先于构造函数
**类加载时调用static静态代码块**

```java
class User{
    String name;
    String pwd;
    //每次带哦用每种构造方法之前调用代码块
    static{
        System.out.println("代码块");
    }
    User(){

    }
    User(String name){
        this.name=name;
    }
}
```

### 创建对象的调用顺序
优先级一致按照顺序执行
1. 父类静态代码和静态属性
2. 子类的静态代码和静态属性
3. 父类的普通代码和普通属性
4. 父类的构造方法
5. 子类的普通代码和普通属性
6. 子类的构造方法
### final
- 修饰类
  - 类不在被继承
- 修饰方法
    - 父类的方法不会被子类覆写
- 修饰属性
  - 类的属性不会被改变
- 修饰局部变量
  - 遍历不会被修改

`static`和`final`可怜和修饰属性，在使用时不会导致类加载
```java
public final static x=1;

System.out.println(new user.x);
```

### abstract
1. 抽象方法、就是没有方法体，没实现的方法
2. 一个类有抽象方法的时候，该类必须是抽象类
3. 抽象类不能被实例化
4. 抽象类可以没有抽象方法
5. 不能修饰属性
6. 一个类继承了抽象类，除非自己也是抽象类，否则必须实现抽象类的所有抽象方法
7. 抽象方法不能使用`pricate`，`static`，`final`修饰

```java
public abstract void cry();

```

### 接口 interface
```java
public interface Usb{
    abstract void start();
    default public void stop(){
        System.out.println("ok");
    } 
    public static void out(){
        System.out.println("out");
    }
}
class Phone implements Usb{
    @Override
    void start(){

    }

}

class Computer{
    public void work(Usb usb ){
        usb.start();
    }
    public static void main(String []args){
        Computer c=new Computer();
        c.work(new Phone());
    }
}
```
1. 类需要`implements`实现所有接口中的方法
2. 可以通过接口调用方法
3. jdk7.0之前接口都是抽象方法没有方法体，jdk8.0之后接口可以有静态方法，默认方法，可以有具体的方法实现
4. 在接口中，方法前的`abstract`可省略,所有方法都是`public`方法
5. 接口中存在方法体必须要有default修饰
6. 抽象类实现接口可以不用实现接口中的方法 
7. 一个类可以同时实现多个接口
8. 接口中可以有属性，默认是`public static final`
9. 接口不能继承类但是可以继承多个接口`extends
10. 接口的修饰符只能是默认或者`public`

#### 接口的多态
形参是接口，可用于接受实现了该接口的类的实例对象

可以使用接口板指向实现了该接口的类的实例对象
```java
Usb u=new Phone();

```

多态的传递性

```java
interface ih{}
interface ig extends ih()
class T implements ig{}
ih h=newT();//相当于T也实现了ih接口
ig g=newT();
```


### 内部类
类的五大成员 方法、属性、代码块、构造器、内部类
内部类的最大特点就是可以直接访问私有成员、


内部类的分类
根据定义位置
- 定义在外部类的局部位置上，比如方法中  
  - 局部内部类，有类名
  - 匿名内部类，无类名
- 定义在外部类的成员位置上
  - 成员内部类，没有`static`修饰
  - 静态内部类，有`static`修饰

#### 局部内部类


```java
class Outer{
    {
        class inner03{

        }
    }
    class Inner{

    }
    public void hi(){
        final class Inner01{

        }
    }

}

```

可以访问外部类的私用成员
不能添加访问修饰符们可以使用final，不能使用`static`
作用域仅限定义的方法或者类之内
外部不能访问
内外部成员重名时`Outer.this.m1;类名+this+属性名

#### 匿名内部类
没有名字，本质是类，内部类，同时是一个对象
创建匿名类之后立刻就创建了实例返还给接口，该内部类只是使用一次

可以基于类或者接口
不能添加修饰符
匿名局部类是一个局部变量
```java
interface A{}
A a=new A(){//编译类型接口A，运行类型匿名内部类
//系统给予他一个i那个字Outerxxx

}

class B{
    String name;
    B(String name){
        this.name=name;
    }
    void cry(){

    }
}
B b=new B("jack"){//编译类型B，运行类型匿名内部类，该匿名内部类继承于B
    @Override
    void cry(){

    }
};
```


匿名类当作实参传递

```java
interface A{
    void cry();
}

void fun1(A a){
    a.show();
}
public static void main(String []aargs){
    fun1(new A(){
        @Override
        void cry(){

        }
    });
}
```

#### 成员内部类

```java
class Outer{
    class Inner{
    }
   
}

```

外部其他类调用Inner类
```java
//1
Outer outer=new Outer();
Outer.Inner in=outer.new Inner();

//2
使用方法返回
Outer.Inner in=outer.getInner();


```

#### 静态内部类
```java
class Outer{
    static class Inner{

    }
}

```
可以访问外部类的所有静态成员，不能访问非静态成员
作为一个静态成员可用public等修饰
作用域为外部类
```java
//满足访问权限

Outer.Inner in=new Outer.Inner();
```

## jdk源码

### `equal`函数

`==`基本类型比较数值，引用类型比较地址
普通类默认继承`Object`的`equal`方法
`Object`的`equal`方法使用`==`比较

覆写父类的`equal`方法可以来比较内容的值

### `hashcode()`
提供对象的哈希码值提高系统提供的哈希表的性能

- 哈希值主要根据地址来的但不等于地址，返回不同的整数
- 相同对象(不同引用，相同对象)哈希值一致
- 不同对象哈希值原则上不同

### `toString`

sout时自动调用

###  `Finalize`
1. 对象被回收时候，系统自动调用，子类可重写实现一些**释放资源**的操作
2. 当某个对象没有任何引用的时候，vm就认为是可以回收的在回收之前调用
3. 系统来决定垃圾回收，也可以通过`System.gc()`来触发垃圾回收机制 

实际中不会使用

## 枚举类`enum`

```java
enum Season{
    SPRING("春天","温暖"),
    SUMMER("夏天","炎热"),
    WINTER("东天","寒冷"),
    FALL("秋天","凉爽")，
    WHAT;//需要写在最前面
    private String name;
    private String temp;
    Season(){

    }
    Season(String name,String temp){
        this.name=name;
        this.tamp=temp;
    }
    public void work(){

    }
}
System.out.println(Season.WINTER);

```
1. 默认继承`Enum`类
2. 无参构造器可以省略括号
3. 枚举对象必须放在首位
4. 默认属性都是`final static`的
5. 不能再继承其他类 

### 枚举类的方法
`name()`返回名字WINTER
`ordinal()`返回编号，按照定义的顺序
`toString()`返回当前对象名
`values`返回一个枚举类数组，包含所有的枚举类对象
`valueOf`字符串转化为枚举类对象，字符串必须为已存在的枚举类对象名称

## 注解`Annotation`
### 常见注解
```java
@Override 用于方法前，表示重写父类的方法
@Deprecated 代表已经方法，类弃用过时
@SuppressWarinings 抑制编译器警告


```

```java
@SuppressWarningd({"all"})//可适合类、方法、语句中
//all,所有警告，boxing抑制封装拆装作业相关的警告
//cast抑制强转型作业的警告。。。。

```

### 元注解
> 修饰注解的注解
```java
@Retention 指定注解的作用时间范围 SOURCE 编译器使用之后丢弃,CLASS 保留在class文件中jvm运行时不会保留,RUNTIME jvm保留注释可以通过反射获取该注释
@Tatget 指定注解的使用的范围
@Documented 指定该注解是否会在javadoc体现
@Inherited 子类会继承父类有的注解 
```

## 异常
```java
try{
    int x=10/0;
}
catch(Exception e){
    System.out.println(e.getMessage());
}

```
- `Throwable`
  - 错误 `error` 会崩溃
    - 栈溢出 `StackOverFlowError`
    - 内存不足 `OutOfMemoryError`
  - 异常 `exception`
    - 运行时异常 `RuntimeException`
      - 空指针异常 `NullPointerException`
      - 算术异常 `ArithmeticException`
      - 数组越界 `ArrayIndexOutOfBoundsException`
      - 类型转换异常 `ClassCastException`
      - 数字格式 `NumberFormatException`
      - ...
    - 编译时异常,一下统称编译异常,必须处理
    - 文件未找到异常 `FileNotFoundException`
    - `ClassNodeFoundException`
    - ...

### 异常处理
#### try catch finally

```java
try{

//代码可能有异常
}catch (Exception e){
    //有异常发生就需要执行
}finally{
    //不管有无异常发生始终需要执行代码
    //通常用于执行释放资源
}

```

可以多个catch捕捉异常，子类异常在前面父类异常在后面
finally里面的内容比强制执行，即使trycatch中有return的话return会执行但是不返回，执行finally语句之后返回
#### throws
抛出异常
遇到异常要么trycatch处理，要么抛出异常给上一级处理，可以接着向上传递异常，trycatch和throws二选一
直到main方法异常传给jvm
jvm会输出异常信息中止程序运行
系统默认是throws
```java
void fun() throws FileNotFoundException {

}

```

子类覆写父类方法抛出异常是父类的异常的子异常或者相同异常

对下一级抛出的编译异常必须处理或者抛出，而运行异常可以不做处理

`throws`和`throw`的区别
`throw`放在方法体内，用于抛出一个一个异常对象
`throws`在方法声明处，跟这个异常处理的类型

### 自定义异常


```java
class AgeException extends RuntimeException{
    public AgeException(String message){
        super(message);
    }
}


public static void main(String []args){
    int age=10;
    if(age<12){
        throw new Ageexception("太小了");
    }
}
```

## 常用类
### 包装类`Wrapper`
对八种基本类型包装成的引用类型 类
- `Serializable`,实现了`Comparable`接口
  - boolean Boolean
  - char Character
- `Serializable` -> `Number` （父类）,实现了`Comparable`接口
  - byte Byte
  - short Short
  - int Integer
  - long Long
  - float Float
  - double Double


#### 拆箱装箱
手动
```java
//装箱
int n=10;
Integer in=new Integer(n);
Integer in1=Integer.valueOf(n);

//拆箱
int x=in.intValue();

```

自动
```java
//装箱
int n=10;
Integer in=n;//底层依然是Integer.valueOf(n);
//拆箱
int m=in;//底层依然是in.intValue();
```

#### 比较
```java
Integer x=1;
Integer x=128;
//-128~127中会直接使用cache中存储,Integer的缓存机制
//超过则new Integer(128);
```

`==`比较的是地址不是值，若有基本类型就是在比对值


### String 类
1. 继承自`Object`接口，实现了`Comparable`（可以比较大小 ），`Serializable`（可以串行化，就可以在网络传输），`CharSequence`接口
2. 字符串的字符一个占零个字节，使用unicode编码
3. 不可被继承
4. 字符串最终被保留到`private final char value[]`字符数组中.value的地址不可修改，其中的部分字符可修改
构建方法
```java
String s1=new String();
String s1=new String(String original);
String s1=new String(char sc[]);
String s1=new String(char sc[],int startIndex,int count);
String s1=new String(byte bc[]);
String s1=new String(byte bc[],int startIndex,int count);
```
#### String 对象特性
```java
String s1="Tom";//字符串常量是"Tom",存放于常量池中
//new 是在堆中开辟空间，该空间指向常量池中的"Tom"
s.intern();//返回常量池中的地址
```


```java
String s="123"+"abc";//编译器优化直接生成123abc常量只有一个对象
```

```java
String a="123";
String b="abc";
String c=a+b;//一共三个对象
//1 StringBuilder sb=new StringBuilder();
//2 sb.append("123");
//3 sb.append("abc");
//4 return sb.toString();//   在堆中new 一个字符串对象指向常量池中的"123abc"
```

常量相加看池，变量相加看的是堆

#### String常用方法
```java
charAt(int x);
toCharArray();
toLowerCase();
toUpperCase();
concat(String );//连接
replace("_","=");//返回结果才是替换过的
String strs[]=s.split(" ");

s1.compareTo(String s2);//len1-len2,  return s1-s2;
//先比较字符，返回不同字符的差值。若共有长度部分的字符相同则返回长度差值
//0 两者值完全相等，>0,s1大于说s2，<0 s2大于s1

String s=String.format("我叫做%s,我的年龄是%d,我的体重是%d,我的性别是%c","tom",23,123,'f');
//占位符 ，%s.%d,%c,%.2f(保留两位小数，四舍五入)
```

#### StringBuffer
继承自`AbstactStringBuilder`,实现了`Serializable`接口即可以串行化
在父类中的`char value[]`中存放字符串内容，存放在堆中
StringBuffer为final类
```java
StringBuffer sb=new StringBuffer(int x);//默认为16,不足时候自动扩容，不用创建新对象
StringBuffer sb=new StringBuffer("hello");//"hello".length()+16
sb.append(String ,char, int);
sb.append(10).append('p').append(90.9).append(true);
sb.delete(start,end);//删除[start,end)的字符
sb.replace(start,end,String);//[start,end)替换为String
sb.indexOf(String);//第一次出现的位置
sb.insert(index,String);//在index之前插入String原index处及以后后移
sb.deleteCharAt();//删除某个位置的字符
sb.length();//sb中添加的字符总长度



String s=sb.toString();
String s=new String(sb);
```

若`append null`字符串会加入"null"字符串

#### StringBuilder
> 一个可变的字符序列，与StringBuffer兼容的Api。 被设计为StringBuffer的一个简易置换，
> 未作线程处理不是线程安全，在单线程时候可以替换，比StringBuffer要快



```java
StringBuilder sb=new StringBuilder("hello");//"hello".length()+16
sb.append(String ,char, int);
sb.delete(start,end);//删除[start,end)的字符
```




### Arrays

```java
int a[]={1,2,3,4};
System.out.println(Arrays.toString(a));//数组转字符串

Arrays.sort(a);//由小到大排序
//定制排序

Arrays.sort(a,new Comrator<Integer>(){//接口Comparator的匿名内部类
    @Override
    public int compare(Integer o1,Integer o2){
        return o2-o1;
    }
});


int index=Arrays.binarySearch(arr,3);//有序数组，可以二分查找，不存在返回-(low+1)low本该位于的位置

Integer narr[]=Arrays.copyOf(arr,arr.length);//拷贝的长度大于原数组的长度，添加多个null，负数抛出异常
boolean eauqls =Arrays.equals(arr1,arr2);//完全一样返回true
Arrays.asList(1,2,3,4,5);//转为一个List,编译类型List(接口)运行类型ArraysList


```

### System

```java
System.exit(0);//退出程序,0表示正常退出
Arrays.arrayCopy(src,0,dest,0,3);//复制数组元素  原数组 ，原数组开始拷贝索引，目标数组，目标数组接受的目的索引，拷贝的总长度
currentTimeMillens;//返回当前时间距离1970-1-1的毫秒数
System.gc();//垃圾回收机制
```

### 大数
`BigInteger`大整数
`BigDecimal`大浮点数,精度太高
```java
BigInteger bi=new NigInteger("234234242452453453");//传入字符串，不呢直接加减乘除
bi.add(new BigInteger("2342"));//+
bi.subtracet();//-
multiply();// *
divide();// /

BigDecimal bd=new BigDecimal("2342345.35635636758485");

bd.divide(new BigDecimal());//若结果i是无限循环小数会抛出异常，调用divide时候指定精度
bd.divide(new BigDecimal(),DigDecimal.ROUND_CEILING );//若结果i是无限循环小数会抛出异常，调用divide时候指定精度

```

### 日期类

#### `Date` 第一代，精确到毫秒，代表特定的是瞬间

```java
import java.util.Date;
Date d1=new Date();//获取当前系统时间默认国外格式 Thu Mar 04 17:19:58 CST 2021
Date d1=new Date();//获取指定毫秒数得到时间

SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 hh:mm:ss E");
String s1=sdf.format(d1);

Date d2=sdf.parse(s1);//格式化的字符串转为Date对象,s1需要和定义的sdf格式一致才能转换
```


#### `Calendar`
抽象类，构造器是private
不是线程安全的
不能处理闰秒
```java
Calendar c=Calendar.getInstance();//获取实例,将各种参数藏在字段里
System.out.println(c.get(Calendar.YEAR));//获取年
System.out.println(c.get(Calendar.MONTH)+1);//获取月
System.out.println(c.get(Calendar.DAY_OF_MONTH));//获取日
System.out.println(c.get(Calendar.HOUR));//获取小时
System.out.println(c.get(Calendar.HOUR_OF_DAY));//获取24小时进制
System.out.println(c.get(Calendar.MINUTE));//获取分钟
System.out.println(c.get(Calendar.SECOND));//获取秒


```

#### `LocalDate,LocalTime,LocalDateTime`
`LocalDate`(日期年月日)
`LocalTime`（时间时分秒）
`LocalDateTime`（日期时间年月日时分秒）
```java
LocalDateTime ldt=LocalDateTime.now();//返回表示当前日期时间的对象
ldt.getYear();
ldt.getMonth();//Marth
ldt.getMonthValue();//3
ldt.getDayOfMonth();//
ldt.getHour();//
ldt.getMinute();//
ldt.getSecond();//
LocalDate ld=LocalDate.now();
LocalTime ld=LocalTime.now();

DateTimeFormatter.ofPattern("yyyy年MM月dd日 hh:mm:ss");
```
#### Instant时间戳
```java
Instant now=Instant.now();
System.out.println(now);//

Date date=Date.from(now);

```

## 集合

- 集合  单列集合，双列集合
  - `Collection`(接口)，继承`Inteable`接口
    - `List`（接口）
      - `ArrayList`（类）
      - `LinkedList`（类）
      - `Vector`（类）
    - `Set`（接口）
      - `HashSet`（类
        - `LinkedHashSet`（类）
      - `TreeSet`（类）
  - `Map`
    - `HashMap`（类）
      - `LinkedHashMap`（类）
    - `HashTable`（类）
      - `Properties`（类）
    - `TreeMap`（类）
    
  - `Collections`

### 遍历
实现了`Inteable`接口的类可以使用 `Iterarot` 迭代器，用于遍历集合
```java
Collection col=new ArrayList();
//Iterator iterator=Collection.iterator();
Iterator iterator=col.iterator();
while(iterator.hasNext()){//判断还有没有若是没有继续向下会报错
    Object next=iterator.next();
    System.out.println(next);
}
//再次取值，需要重置迭代器iterator=col.iterator();

```
### `Collection`接口
```java
Collection col=new ArrayList();
col.add();
col.addAll(Collection);
col.remove();
col.removeAll();
col.contains();
col.containsAll();

```
### List接口
```java
List list=new ArrayList();
list.get(int index);
list.add(int index,Object o);在索引index处插入
list.indexOf(Object o);//返回首次出现的位置
list.lastIndexOf(Object o);//返回末次出现的位置
list.set(int index,Object element);//替换

List nlist=list.subList(int startIndex,int endIndex);//[startIndex,endIndex)
 
```

### `ArrayList`
可以加入多个null
使用数组存储
线程不安全，但是单线程下高效
`elemebtData[]` 数组存放

无参构造器默认容量为0
第一次添加容量为10，之后如果需要扩容就会按照当前容量的1.5倍扩容
构造器可传入指定容量，每次扩容按照容量的当前容量的1.5倍扩容。

### `Vector`
底层是一个对象数组
是线程安全的`synchornized`
可以添加null值

无参构造器默认容量10
满了之后按容量的两倍扩容

### `LinkedList`
双向链表和双端队列
可以添加任意元素，包括null
线程不安全
包含有`next`,`pre`,`item`三个属性
```java
```

改查多选ArrayList
删除增加多选LinkedList

### `Set`接口
最多添加一个null
可用迭代器
不能使用索引

### `HashSet`类
HashSet底层其实是HashMap
```java
set.add("jack");//返回true
set.add("jack");//返回false
```
- 扩容
  - 第一次加入扩容直接到16
  - 到了临界值16*.75=12，就会自动扩容
  - 底层数组链表--红黑树(元素多的时候转化，java8当一条链超过8个元素，table的大小超过64就自动转化)否则仍然会继续扩容
  - table表扩容按照两倍来扩容
  - 
- 添加元素
  - 添加元素的时候根据`hash()`得到一个索引值
  - 按照表的索引之下的链表进行对比，对比hash，==，equal对比，一致就退出不加入，不存在一致的项就加入
  - 底层比较元素调用添加对象的`equals`比较

### `LinkedHashSet`
继承于`HashSet`实现`Set`接口
底层是`LinkedHashMap`
底层维护了数组加双向链表
根据元素的 hashCode求得元素的存储位置（在数组的位置），用链表维护顺序
不允许添加 重复元素
第一次添加，数组table扩容到 16
数组table是`HashMap$Node []`类型，存放的元素类型是`LinkedHashMap$Entry`类
`LinkedHashMap$Entry`继承`HashMap$Node `,继承关系是在内部类完成


### `TreeSet`
可以排序
底层TreeMap
```java
TreeSet treeSet=new TreeSet();//无参创建仍然是无序的
treeSet.add("Jack");
```
`Comparator`接口的方法
`int compare(T o1,T o2);`//排序方法

### `Map`
key和value会封装到`HashMap$Node`对象中
`HashMap$Node node =new Node(hash,key,value,null);`
会创建EntrySet对象，而一个Entry对象就有一个key和value
`EntrySet<Entry<K,V>>  transient Set<Map.entry<K,V>> entrySet;`

`HashMap$Node`实现了`Map.Entry`接口

#### Map的遍历
1. keySet()

```java
Set  keys=map.keySet();
for(Object x :keys){
    System.out.println(x+"  "+  map.get(x));
}


Iterator iterator=keys.iterators();
while(iterator.hasNext()){
    Object value=iterator.next();
    System.out.println(key+"  "+map.get(value));
}
```

2. values()

```java
Collection values=map.values();
for(Object o :values){
     System.out.println(o);
}


Iterator iterator=values.iterators();
while(iterator.hasNext()){
    Object value=iterator.next();
    System.out.println(value);
}
```

3. EntrySet

```java
Set entrySet =map.entrySet();
for(Object entry: entrySet){
    Map.Entry m=(Map.Entry)entry;
    m.getKey()+"  "+m.getValue();
}
Iterator iterator=entrySet.iterator();
while(iterator.hasNext()){
    Object next=iterator.next();
    Map.Entry next1=(Map.Entry)next;
    next1.getKey();
    next1.getValue();
}
```

### `HashMap`
线程不安全的

### `ConcurrentHashMap`
线程安全的
### `HashTable`
线程安全的
键和值不能为null
使用方法和hashMap一致
底层为HashTabe$Entry内部类数组，初始化大小为11
临界值threshold为8=11*0.75
扩容机制old*2—+1=new
### `Properties`
Properties继承自于HashTable实现了MAp接口
使用键值对来保存数据
使用特点和HashTable类似
key和value不许为null
可以用于重xxx.properties文件中读取数据
.properties通常作为配置文件

```java
Properties proterties=new Properties();
properties.put("john",100);
properties.get("john");
properties.remove("john");1
properties.getProperty("john");


```
### `TreeMap`
```java
TreeMap tm=new TreeMap();//无参构造器，无序


tm.put("Jack",10);

TreeMap tm1=new TreeMap(new Comparator(){//Compartor的匿名内部类
    @Override
    public int compare(Object o1,Object o2){
        return (String)o1.compareTo((String)o2);//按照key的大小排序
    }
});
```


### `Collections`工具类
```java
List list=new LinedList();
list.add("John");
list.add("Jack");
list.add("Tom");
Collections.reverse(list);//反转列表
Collections.shuffle(list);//随机排序列表
Collections.sort(list);//排序，默认升序
Collections.sort(list,new Comparator(){
    @Override
    public int compare(Object o1,Object o2){
        return ----;
    }
});
Collections.swap(list,0,2);//索引0和2处的元素交换位置
Collections.max(list);//最大元素
Collections.max(list,new Compatrator(){//长度最大元素
    @Override
      public int compare(Object o1,Object o2){
        return ((String)o1).length()-((String)o2).length();
    }
});
//min()方法
Collections.frequency(list,"John");//某元素出现的频率

//拷贝
List dest=new LinkedList();
for(int i=0;i<list.size();i++){
    dest.add("");
}
//dest需要设置大小和list一致
Collections.copy(dest,list);
Collections.replaceAll(list,"Tom","John");//Tom ->John

```

## 泛型
> 参数化类型，声明或者实例化的时候指明具体的类型就可以
> 在编译的时候就确定是什么类型

保证编译的时候不发生的警告就不会发生 类型转换问题

1. 只能是引用类型，不能是基本数据类型

2. 传入泛型E的子类型也是可以的 
3. 没有明确的泛型E，默认是Object

自定义泛型，泛型属性不能初始化
静态方法和静态属性不能够使用泛型
可以自定义泛型类，自定义泛型接口

泛型不能继承即List<Object> x=new LinkedList<String>();// F
```java
class Person<E，T,M>{
    E s:
    T tt;
    M mm;
public E get(E s){
    return s;
}
}
public Car{
    //泛型方法
    public <T,R> void move( T t,T,r){
         
    }
}
new Car().move("plane",456);

```

```java
List<?>list;//指明任何类型都可以
<? extends A> 支持A类以及A类的子类规定上限
<? super A>支持A类以及A类的父类，规定下限

```


# 线程
线程是进程的一个实体
java中实现线程有两种方法
1. 继承`Thread`类重写`run`方法
2. 实现`Runnable`接口，重写`run`方法

## `Thread`
`Thread`实现了`Runnable`接口,`run`方法实际也是来自`Runnable`接口的
```java
class Threadtest{
    public static void main(Strig []args){
        Cat cat=new Cat();
        cat.start();//启动一个新线程执行run 方法，线程只是可以执行，处于可执行状态，是否执行具体取决于cpu
        //main线程启动一个子线程Thread-0，主线程不会阻塞会继续执行
    }
}
class Cat extends Thread{
    @Override
    public void run(){
        while(true){
            System.out.println("i am a cat");
            try{
                Thread.sleep(1000);//ms
            }catch (InterruptedException e){
                e.printStackTrace();
            }
        }
    }
} 

```
## `Runnable`


```java
class Threadtest{
    public static void main(Strig []args){
        Cat cat=new Cat();
        Thread thread=new Thread(cat);
        thread.start();//启动一个新线程执行run 方法，线程只是可以执行，处于可执行状态，是否执行具体取决于cpu
        //main线程启动一个子线程Thread-0，主线程不会阻塞会继续执行
    }
}
class Cat implements Runnable{
    @Override
    public void run(){
        while(true){
            System.out.println("i am a cat");
            try{
                Thread.sleep(1000);//ms
            }catch (InterruptedException e){
                e.printStackTrace();
            }
        }
    }
} 

```
## 线程终止
当线程完成后会自动退出
可以使用变量的方式来控制run方法停止线程即通知方式
```java
class Cat extends Thread{
    private int count=0;
    private boolean loop=true;//希望主线程控制子线程的话需要控制loop方法
    @Override
    public void run(){
        while(loop){
            System.out.println("i am a cat");
            try{
                Thread.sleep(1000);//ms
            }catch (InterruptedException e){
                e.printStackTrace();
            }
        }
    }
    public void setLoop(boolean loop){
        this.loop=loop;
    }
} 


```

## 线程常用函数
```java
setName();//设置线程名字
getName();//获取线程名字
start();//线程开始执行
run();//调用的线程的run方法
setPriority();//更改线程的优先级，1~10一般为5
getPriority();//得到线程的优先级
sleep();//在指定的毫秒数让正在执行的线程休眠即暂停执行
interrupt();//终端线程
```

1. `yield()` 线程的礼让，让出cpu，但是礼让的时间不确定，所以也不一定礼让成功
2. `join()` 线程的插队，插队的线程插队成功肯定先执行完插队的线程的所有的任务。
   


```java
class T2 extends Thread{
    //...
}
T2 t2=new T2();
t2.join();//t2线程先执行


Thread.yield();//礼让
```

```java
class DT extends Thread{

}
DT dt=new DT();
dt.setDaemon(true);//启动之前设置，主线程结束的话子线程也结束
dt.start();

```
## 线程的状态
6种或者7种状态
- new 创建
- runnanle可运行状态（内核态）
  - ready 可以运行
  - running正在运行
- timewaiting 超时等待
- waiting 等待
- blocked 块锁等等待
- terminated 终止

## 线程同步机制
> 保证一些敏感数据在任何同一时刻只能够有一个线程访问，保证数据的完整性

`synchronized`锁是加在相应的对象或者类上面
```java
synchronized (this) { //同步代码块

}
synchronized (object) { //同步代码块

}
synchronized (Thread01.class) { //同步代码块

}

public void synchronized void fun(){}//同步方法


```
### 互斥锁
每个对象可以对应一个可以成为互斥锁的标记，用于保证某一时刻最多只有一个线程访问。
会导致运行效率比较低
同步方法是静态的锁为类本身，默认当前类XXX.class
非静态的锁为对象，带代码块上加锁，锁在对象上.可以是其他对象，但是必须得是同一个对象。默认当前对象this
### 死锁
互相占用资源，互不相让


# 文件
文件流
java程序<-输入流，输出流->内存c

`File`类实现了`Serializable`和`Comparable`接口

```java
new File(String pathname);//"d:\\a.txt"
new File(File parent,String child);//new File("d:\\"); "b.txt"
new File(String parent,String child);//

try{
  file.createNewFile();//创建新文件
}catch (IOException e){
    e.printStackTrace()
}


```

## 常用方法
文件操作
```java
File f=new File("d:\\a.txt");

f.getName();//得到名字a.txt
f.getAbsolutePath();//绝对目录
f.getParent();//父级目录d:\\
f.length();//文件大小0(Byte)
f.exists();//文件\目录是否存在
f.isFile();//是否为文件
f.isDirectory();//是否为目录
```

目录操作
```java
f.delete();//删除文件/目录 boolean
f.mkdir();//新建目录d:\\b 创建以及目录
f.mkdirs();//创建多级目录d:\\a\\b\\c

```

java的IO技术通过流的方式实现

流的分类
字节流（8bit)字符流（按字符）
输入流、输出流
四个抽象基类
`InputStream`、 `Reader`
`OutputStream` 、`Writer`
## 字节输入流常用子类
`FileInputStream extends InputStream`

`ObjectInputStream extends InputStream`

`BufferedInputStream extends FilterInputStream extends InputStream`

```java
FileInputStream fis=null;
try{
    fis=new FileInputStream("d:\\a.txt");
    int x= fis.read();//读取一个字节的数据。返回-1就是读取完毕
    while((x=fis.read())!=-1){
        System.out.println((char)(x));

    }
}catch (FileNotFoundException e){
    e.printStackTrace();
}finally{
    try{
         fis.close();
    }catch(IOException e){
        e.printStackTrace();
    }
   
}


```

```java
FileInputStream fis=null;
byte[]bs=new byte[8];
try{
    fis=new FileInputStream("d:\\a.txt");
    // int x= fis.read();//读取一个字符的数据。返回-1就是读取完毕
    //返回读取的字节数，一般为8，部位8 说明读取介绍
    while((len=fis.read(bs))!=-1){
        System.out.println(new String(bs,0,len));

    }
}catch (FileNotFoundException e){
    e.printStackTrace();
}finally{
    try{
         fis.close();
    }catch(IOException e){
        e.printStackTrace();
    }
   
}

```






## 字节输出流
`FileOututStream extends OutputStream`
```java

FileOutputStream fos=null;
byte[]bs=new byte[8];
try{
    fos=new FileOutputStream("d:\\a.txt"); //每次都是覆盖原文件
    //fos=new FileOutputStream("d:\\a.txt",true);//追加到文件末尾
   
   //写入一个字节
   fos.write('#');//
   //写入多个字符
   fos.write("hellowolrd".getBytes());
   fos.write(str.getNytes(),str.length())
   fos.write(byte data[],int off,int length);
    
}catch (FileNotFoundException e){
    e.printStackTrace();
}finally{
    try{
         fos.close();
    }catch(IOException e){
        e.printStackTrace();
    }
   
}
```
## 字符输入输出流  FileReader，FileWriter
`FileReader extends InputStreamReader extends Reader`
`FileWriter extends OutputStreamWriter extends Writer`

```java
new FileReader(String path);
fr.read();//每次读取单个字符，返回该字符，文件末尾返回-1
fr.read(char[]);//读取多个字符到数组中返回读取到的字符数，如果到文件末尾返回-1

new FileWriter(String path,boolean append);//true附加模式，false覆盖模式
fw.write(int );//写入字符
fw.write(char);
fw.write(char[]);//写入多个字符
fw.write(char [],int off,int len);//偏移，长度
fw.write(String);//写入整个字符串
//使用后必须关闭或者flush,否则写入不到文件中
fw.flush();
```

## 包装流
*节点流*可以从一个特定的数据源梳理数据。直接处理数据`FileReader`
*包装流* `BufferedReader extends Reader  BufferedWriter extends Writer`,可以封装一个节点流例如BufferedReader可以封装任意Reader的子类（不能操作二进制文件）
```java
BufferedReader br=new BufferedReader(new FileReader(Path1));
BufferedWriter bw=new BufferedWriter(new FileWriter(Path2));
while((str=br.readLine())!=null){
    System.out.println(str);
    bw.write(str);
    bw.newLine();//换行，插入一个和系统相关的换行
} 
br.close();
bw.close();

```
`BufferedInputStream`
`BufferedOutputStream`
### 序列化
> 保存数据的时候保存数据的类型和数据的值

反序列化

> 恢复数据的时候恢复数据的值和类型

序列化需要实现`Serializable`接口或者`Externalizable`接口
`Serizlizable`是一个标记接口，没有任何方法
`Externalizable`有方法需要实现

序列化后保存的文件不是纯文本 按照他的格式保存
```java
ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream("x.dat"));
oos.write(10);//int->Integer
oos.writeBoolean(true);//boolean ->Boolean
oos.writeChar('a');
oos.writeDouble(7.5);
oos.writeUTF("hellowolrd");//String
oos.writeObject(new Dog("god",45));//Object
oos.close();
```
谁了提高版本兼容性序列化的内容建议添加SerialVersionUID(对Object序列化)
序列化不会修改static或者transient属性方法
每个属性必须实现序列化
序列化可以继承，父类是实现了序列化则子类都实现了序列化
读取的数据顺序要和保存的数据一致
```java
ObjectInputStream ois=new ObjectInputStream(new FileInputStream("x.dat"));
ois.readInt();
ois.readBoolean();
ois.readChar();
ois.readDouble();
ois.readUTF();
ois.readObject();
ois.close();
```

## 标准输入输出流
`System.in`编译类型`InputStream`运行类型`BufferInputStream`（标准输入，键盘）

`System.out`编译类型`PrintStream`运行类型`PrintStream`（标准输出，显示屏）


```java
System.in;

Scanner sc=new Scanner(System.in);
sc.next();
```
## 转换流/包装流

字节流->字符流
字节流可以指定编码格式，指定对应编码格式之后再转化为字符流

处理文本数据的时候建议使用字符流，可以有效解决中文编码问题（utf-8，贵宾卡，gb2312）
`InputStreamReader extends Reader`
`OutputStreamReader extends Writer`

```java
InputStreamReader isr=new InputStreamReader(new FileInputStream(path),"utf8");
OutputStreamReader osr=new OutputStreamReader(new FileOutputStream(path),"utf8");
```

## 打印流
`PrintStream extends FilterOutputStream extends OutPutStream`字节输出流
可以打印到文件或者屏幕中去
`PrintWriter extends Writer`字符输出流



System.out就是一个PrintStream对象,默认标准 屏幕

修改打印流输出的位置
```java
System.setOut(new PrintStream("e:\\a.txt"));
System.out.println("hwlloworld");
```


```java
PrintWriter pw=new PrintWriter(System.out);//屏幕
// pw.print("helloworld");
// pw.close();


PrintWriter pw=new PrintWriter("d:\\a.txt");//写入到文件
pw.print("helloworld");
pw.close();//需要关闭才会写入到文件中

```
## Properties类
常用方法
```java
load(Reader reader)//加载配置文件的键值对到Properties对象
list()//将数据显示到指定的设备/流对象
getProperty(key);//根据键获取值
setProperty(key,value);//设置键值到Property对象
store(Writer/OutputStream,comments注释);//将Properties中的键值对储存到配置文件再idea中如果又中文博爱春伟unicode码
```

```java
Properties p=new Properties();
p.load(new FileReader("d:\\mysql.properties"));
p.list(System.out);//放到标准输出，输出
p.getProperty("user");
p.setProperty("pwd","123456");
p.store(new FileOutputStream("d:\\a.properties"),null);
```


# 网络编程
`java.net`包之下提供了一系列的类和接口

网络端口0~65535   

0~1024基本被占用

mysql 3306
tomcat 8080
oracle 1521
sqlserver 1433

```java
InetAddress ina=InetAddress.getLocalHost();
System.out.println(ina);//计算机名/本地ip
InetAddres.getByName("DESKTOP-S4MP44S");//根据主机名获取InetAddress对象
InetAddres.getByName("www.baidu.com");//根据域名获取InetAddress对象

ina.getHostAddress();
ina.getHostName();//获取主机名或者域名


```

## socket

客户端
- 连接服务端，ip端口
- 生成socket输出流
- 输出流输出数据到数据通道

服务端
- 监听端口，等待连接
- 没有客户端连接的话阻塞程序
- 输入流读取客户端发来的数据
  

server
```java
ServerSocket ss=new ServerSocket(9999);//监听9999端口保证没有别的程序监听否则会报错
Socket sc=ss.accept();//没有连接的化程序会在此一致阻塞,可以有多个客户端请求连接，返回多个不同的socket
InputStream is=sc.getInputStream();
byte[]buf=new byte[1024];
int readlen=0;
while((readlen=is.read(buf))!=-1){
    System.out.println(new String(buf,0,readlen));
}
soc.shutdownOutput();//表示当前说完了
sc.close();
ss.close();
is.close();


```

client
```java
Socket cli=new Socket(InetAddress.getLocalHost(),9999);//连接本地的9999端口，连接成功的话返回socket对象
OutputStream os=cli.getOutputStream();
os.write( "hello".getBytes());
os.close();
cli.close();//客户端退出
```

写入结束标记可用`writer.newLine();`但是接受必须得用`readLine()`
若是多行就需要使用循环读取的话就需要发送端`soc.shtdownOutput()`




`netstat -an`擦好看本机网络情况，端口监听和网络连接
`netstat -an | more`可以分页显示

## DatagramSocket udp网络
`DatagramSocket`,接收端和发送端
接受和发送通过DataGramSocket对象完成，指定在某个端口接收数据
数据封装在DatagramPacket对象中发送
接收到对象需要拆包取出数据


发送端

```java
DatagramSocket datagramSocket = new DatagramSocket( 9998);
byte[]data="hello".getBytes(StandardCharsets.UTF_8);
DatagramPacket datagramPacket = new DatagramPacket(data, data.length,InetAddress.getLocalHost(),9999);
datagramSocket.send(datagramPacket);
datagramSocket.close();
```

接收端

```java
DatagramSocket datagramSocket = new DatagramSocket(9999);
byte[]data=new byte[1024];
DatagramPacket datagramPacket = new DatagramPacket(data, data.length);
datagramSocket.receive(datagramPacket);//收不到信息接收端会阻塞在这里
int len=datagramPacket.getLength();
System.out.println(new String(data,0,len));
datagramSocket.close();

```
# 反射
> 通过外部文件配置，在不修改源代码的基础上来控制程序 开闭原则：不修改源码，扩充功能
>反射机制允许程序允许通过Reflection api获取类的内部信息，并能操纵。
>加载完类之后，堆中会出现一个Class类型的对象，包含该类的全部信息

反射比较耗时


```java
//classfullpath="com.andy.Cat";
//methodName="hi";
Class cls=Class.forName(classfullpath);
Onject o=cls.newInstance();
Method method1= cls.getMethod(methodName); //反射中方法也可以看作是对象
method1.invoke(o);//反射机制 方法invoke(对象); 传统方法 对象.方法();
```
## 反射相关类

```java
java.lang.Class;
java.lang.reflect.Method;
java.lang.reflect.Field;
java.lang.reflect.Constructor;


```

```java
Field name=cls.getField("name");//不能得到私有属性
name.getFet(o);//"tom"

Constructor constructor1=cls.getConstructor();//()中指定构造器，默认无参构造器
Constructor constructor2=cls.getConstructor(String.class);//()中指定构造器，默认无参构造器,传入形参的类型的class
```

## 反射调用优化
反射调用优化，关闭访问检查
优化了一点点
```java
fun.setAccessible(true);//取消访问控制
```

## Class类
Class继承自Object，
Class对象不是new出来的而是系统创建的
Class对象只有在堆中一个
类的二进制字节码数据是存放在方法区域的
### Class常用方法
```java
Class cls=Class.forName(classfullpath);//"com.andy.cat"
System.out.println(cls);//com.andy.Cat
cls.getClass();//java.lang.Class
cls.getPackage().getName();//获取包名
cls.getName();//获取类名
cls.getInstace();//创建实例
Field fielsds[]=cls.getFields();//获取所有属性
```


### 获取Class类对象
```java
Class.forName("java.lang.Cat");//多用于配置文件
类.class;//用于参数传递
对象.getClass();//获取运行类型，获取的Class对象。有对象类型

ClassLoader classLoader=car.getClass().getClassLoader();//得到类加载器
Class cla=classLoader.loadClass("jva.lang.cat") //通过类加载器得到类对象

//基本数据得到
Class<Integer>intergerClass=int.class;
Class<Character>intergerClass=char.class;//自动拆箱装箱

//包装类通过.TYPE
Class<Integer> integerClass=Integer.TYPE;
Class<Boolean> booleanClass=Boolean.TYPE;//自动拆箱装箱
```
有Class对象的类型
- 外部类，内部类
- 接口
- 数组
- 枚举类型
- 注解
- 基本数据类型
- void
- 包装类
- Class类也有 
## 类加载的过程 

.java->.class字节码，通过类加载器->记载到内存堆中，类数据二进制加载到方法区域

*静态加载*：编译的时候加载的类，如果没有则报错

*动态加载*：运行的时候加载的类，如果没用到就不会加载

反射是动态加载,降低了依赖性

编译->运行->加载->连接（验证（文件安全校验）->准备(主要是静态数据)->解析（常量池中的符号引用转为直接引用）)->初始化（代码中的初始化，显示初始化） 

- 加载： 类的class文件，网络包，jar包等记载到内存并创建一个Class对象
- 连接：将类的二进制数据合并到jre中
  - 验证：文件安全校验，元数据校验，字节码验证，符号引用验证。
  - 准备：主要是静态数据分配内存并初始化
  - 解析：常量池中的符号引用转为直接引用
- 初始化
  
### 加载
类的class文件，网络包，jar包等记载到内存并创建一个Class对象
### 验证
可以通过-Xverify:none关闭大部分的类验证措施

### 准备
`public int n1=10;` 实例属性，不分配内存
`public static int n2=10;` 静态属性分配内存，默认初始化为0.到初始化阶段初始化为0
`public static final int n3=10;`静态属性分配内存，默认初始化为10
### 解析
常量池中的符号引用转为直接引用
例如A类到内存某地址的替换
### 初始化
静态变量的初始化和静态代码块的执行,按顺序执行
`<clinit>()`方法的过程是线程安全的 ，保证每个类在内存中最多有一份


## 通过反射获取类结构信息
```java
Cass cls=Class.forName("");
cls.XXX;
getName();//获取全类名
getSimpleName();//简单类名
Fields f[]=cls.getFields();//获取所有父类和本类的所有public属性
Fields f[]=cls.getDeclaredFields();//获取所有父类和本类的所有属性

Msthods []m=getMethods();//获取所有父类和本类的所有public方法
Msthods []m=geDeclaredtMethods();//获取所有父类和本类的所有方法
Constructors c[]=getConstructors();//获取本类的所有的public构造器
Constructors c[]=getDeclaredConstructors();//获取 本类所有的构造器
getPackage();//获取包名
getSuperClass();//获取父类的class对象
Class interfaces[]=getInterFaces();//获取接口
Annotation an[]=getAnnotaions();//获取注解，可以直接输出名字不需要getName()

field.getModefiers()//获取修饰值 默认0,public 1.private 2,protected 4,static 8,final 16 多个修饰就相加


method.getModefiers();
method.getReturnType();//获得返回类型的Class
Class cs[]=method.getParameterType();//返回形参的Class

```

## 反射爆破

拿到了私有的构造方法,方法属性等
```java
constructor.setAccessible(true);
method.setAccessible(true);
field.setAccessible(true);//爆破

method.invoke(o);//静态方法可以使用null8

field.setAccessible(true);//爆破
field.set("field的值",o);//静态属性o可以写作null 
field.get(o);//获取属性的值 
```

# 数据库
> 以mysql为例


```shell
sc delete mysql #删除已经安装的mysql，慎重
net start mysql
# 或者
net start mysqld #启动mysql服务
mysql -u root -p #输入密码

```

skip-grand-table;#注释跳过验证

root修改账户密码
```shell
use mysql;
update user set authentication_string=password('hello') where user='root' and Host = 'localhost'; 
flush privileges;#刷新权限
```

```shell
mysql -h 主机IP -P 端口 -u 用户名 -p密码;#默认主机为本地 127.0.0.1 端口为3306

```

## SQL语句
分类
DDL数据定义语句
DML数据操作语句
DQL数据查询语句
DCL数据控制语句
可以使用``规避关键字

CHARACTERSET 数据库的字符集，默认utf-8
COLLATE 指定数据库字符集的校对规则 utf8_bin 区分大小写，默认utf8_general_cli不区分大小写
```shell
show databases;#展示所有数据库
show create database db1;#展示数据库的创建信息
drop database db1;#删除数据库

```

### 备份数据库
```shell
mysqldump -u 用户名 -p -B 数据库1 数据库2 数据库n >文件名.sql # dos执行
mysqldump -u 用户名 -p 数据库 表1 表2 表n >文件名.sql # dos执行
#恢复数据库
Source 文件名.sql # mysql命令行执行

```

```shell
CREATE TABLE TABLE_NAME(
    id int unsigned,
    `name` varchar(255),
    birthday date,
    logintime timestamp 
        not null 
        default current_timestamp
        on update current_timestamp
)character set utf8 collate  utf8_bin ;

create table a like b;
```

### 修改表
```shell
# 添加列
ALTER TABLE tablename
ADD (column datatype[NOT NULL DEFAULT '' AFTER 另一列...],column datatype);

# 修改列
ALTER TABLE tablename
MODIFY  (column datatype[..],column datatype);

# 删除列
ALTER TABLE tablename
DROP (column);

# 查看表的信息
desc tablename;

Rename table 表名字 to 新表名;
# 修改表字符集
alter table 表名 character set 字符集;
```



Create Read Update Delete

### 插入
```shell
INSERT INTO 表名 (columen1name,cloumn2name...)
    values(column1,column2...),
    (...,);

```
'23'可以当做整型插入

### 修改
```shell
UPDATE  表名 SET 列名 = 5000 ,列名="123"  where 条件;
UPDATE  表名 SET salary = salary+5000 where 条件;
```

### 删除
```shell
delete from 表名 where ...;
```

### 查询
distanct去除重复数据

```shell
select [distanct] *|{column1,column2,..} from 表名;
select `name` as '名字' from user;//取别名
```

```shell
between and #闭区间
in
like
not like
is null;# 判断是否为null不能用==
and
or
not 
```
`order by column asc|desc`按某列升序、降序排序;
`group by column1,column2 having column3<100
`按照某列来分组查询，having用于限制输出

`count(*)`计算行数
`count(columns)`计算某列有多少个满足条件排除null


`sum(column)`数值和
`avg(column)`数值平均值
`max(column)`
`min(column)`


#### 符串相关函数
```shell
charset(str);#字符串的编码
concat(str1,str2..);#连接字符串
instr(string1,substring);# 返回子字符串位置没有返回0
ucase(str);#转换成大写
lcase(str);#转换成大写
left(str,length);#从左边取length个字符
right(str,length);#从右边取length个字符
length(str);# 字符串的长度
replace(str,search_str,replace_str);#替换字符串
strcmp(str1,str2);#逐个字符比较字符串大小
substring( str,position,[length]);#取字符串,从1开始计算
ltrim();rtrim();trim();# 左边，右边，两边 去空格
```


#### 数学函数
```shell
ABS(num);#绝对值
BIN(num);#转二进制
HEX(num);#转16进制
ceiling();#乡绅取整
floor();#向下取整
cony(num,from_case,tocase);#进制转换 
format(num,decimal_place);#返回小数位数
least(num1,num2,num3);#求最小值
rand([num]);#返回随机值0~1,不同的种子随机值不一样

```
#### 日期函数

```shell
current_date();#返回当前的日期
current_time();# 返回当前时间
current_timestamp();#返回当前时间戳
date(datetime1);#返回其中的日期
now();#当前的日期时间
date_add(date1,)#日期相加
date_sub(date1,);#日期相减
datediff(date1,date2)#日期相差多少天
year();#获取年份
month();
day();
unix_timestamp();#返回1970-1-1到现在的秒数
from_unixtime(1232611616,"%y-%m-%d %h:%i:%s");#转换成时间
```


#### 加密函数
```shell
select user() from ddual;#查询登录到mysql的有哪些写用户以及ip
select databases(); #当前选择的数据库
select MD5('HELLO') FROM DUAL;# 进行md5加密，32位加密
password(str);# 加密函数，mysq数据库的用户密码的加密方式

```


#### 流程控制函数

```shell
if(expr1,expr2,expr3);#express为真返回expr2否则返回expr3
ifnull(expr1,expr2);#expr1不为null发牛expr1否则返回expr2
select case when expr1 then expr2 else expr3 end;#expr1为真则返回expr2邹泽返回expr3
```
#### 查询加强

```shell
like 'd%';#以d开头的
like '__a%';# 第三个为a的
is null;# 是否为空

```

分页查询
```shell
select ... limit start,rows;#从start+1行开始取，取出rows行，start从0开始计算
```

 

#### 多表查询
```shell
select * from table1,table2;#默认条件下将表进行拼接，每一行匹配另一表的每一行即为笛卡尔积
select * from table1,table2 where table1.id=table2.id;#返回id一致的列 
```
##### 自连接
将一张表看作两张表来查询
```shell
select u1.name,u2.name from user u1,user  u2 where u1.id=u2.boss;

```

##### 子查询
将一个select当作一个表,或者数据
```shell
select * from user where id=(
    select id from boss where id="231";
);
```
`all();`所有的
`any();`其中一个


多列子查询
```shell
select * from user where (sex,age)=(
    select sex,age from user where   `name`='tom'
);

```


表的复制
```shell
insert into table1 select * from table1; 

```
##### `union all`
`union all`将两个查询结果合并，不会去重
`union`将两个查询结果合并，会去重

##### 表外连接

```shell
select * from 表1 left join 表2 on 条件;
```
- 外连接
  - 左外连接：左侧的表完全显示`left join`
  - 右外连接：右侧的表完全显示`right join`

#### 外键
```shell
create table 表名(
    col1 int,
    col2 varchar(255),
    ..,
    Foreign key (id) reference 表2(id)
);
```
外键是primary key或者unique主键
表类型得是innodb类型才支持外键，两张表的对应键必须类型一致
若外键字段没有not null那么可以用null谁都不指向代指
建立主外键的关系后就不能随便删除


## mysql的列类型，mysql的数据类型

- 数值类型，默认有符号
  - 整型
    - bit(M) M在1-64
      - 按照位显示b`11`->3,查询可以按照数字查找
    - tinyint 1个字节
    - smallint 2个字节
    - medinumint 3个字节
    - int 4个字节
    - bigint 8个字节
  - 小数类型
    - float 单精度4个字节
    - double 双精度 8个字节
    - decimal[M,D] M长度，D小数点长度
      - 存储范围最大
- 文本类型
  - char() 0~255 表示的是字符不是字节
    - 是定长，多余的字符格子会浪费，查询速度会快一点
  - varchar() 0~65535字符
    - 变长，按照实际插入的字符大小存储，但是会预留1~3个字节存储大小
  - text 0~65535（2^16-1）字符
  - longtext 0~2^32-1字符
- 二进制数据
  - blob 0~2^16-1
  - longblob 0~2^32-1
- 日期
  - date 年月日
  - time 时分秒
  - datetime 年月日时分秒 YYYY-MM-DD HH:mm:ss3
  - datestamp 时间戳可以自动更新，更新某一个类的时候也自动更新

`unique`值不能重复，若没有指定是not null的则可以有多个null
`primary key`主键不能重复不能为null

### check
mysql 8.0支持check了
之前可以写,只做语法校验但是不会生效。sqlserver等都支持
```shell
create table tab1 (
    id int ,
    `name` varchar(32),
    sex varchar(20) check (sex in ('man','woman')),
    sal Double check(sal>5000 and sal<150000 )
)

```
### 列约束

```shell
字段名 整型 primary key auto_increment #自增长一般为整型
alter  table tab1 auto_increment =100;#从100开始递增
insert into tab1 (xx);# 可以指定插入某行的数据自增长数据，但是之后自增长都要在这个基础上增长
```
## 索引
索引占据空间
```shell
create index uid_index on student(uid);#添加普通索引    
create unique index uid_index on student(uid);#添加唯一索引
alter table tab1 add index id_index (id);#创建普通索引
alter table tab1 add primary index id_index (id);#创建主键索引

drop index id_index on tab1;
alter  tab1 drop primary key;

show indexs（index，keys） form tab1;
select * from student where uid= '1011'; 
```
- 主键自动为主索引,最多一个
- 唯一索引 unique
- 普通索引 index
- 全文索引 fulltext，开发者可以使用全文搜索solr，elsticSearch（在某字段上面做的索引）

修改索引，先删除再新建
## 事务
>一组数据操作语言，要么全做要么全不做

需要底层为innodb存储引擎支持
```shell    
start transaction; #开始一个事务
savepoint a; #设置保存点
rollback to a;   # 回退到a
rollback;#默认回退到创建事务时的状态
commit;#提交事务，提交事务之后不能够再回滚
```

### 事务隔离级别
>多个连接来操作数据库的时候，数据库系统负责隔离操作，保证更改连接获取数据的准确性

问题
- 脏读 读取的数据无效（其他线程撤销操作）
- 不可重复读 前后多次读取，数据内容不一致（其他连接的修改）
- 幻读 前后多次读取，数据总量不一致（其他线程的插入，删除）
  
隔离级别
- 读未提交 read uncommited
  - 脏读，不可重复读，幻读，不加锁
- 读已提交 read commited
  - 不可重复读，幻读，不加锁
- 可重复读 repeatable read
  - 不加锁
- 可串行化 serializable
  - 加锁


我们可以不从赃读，不可重复读，幻读这些现象看事务隔离级别，而是从读一致性上来理解，如下：

- 未提交读，不解决任何读一致性问题，只保证了事务的写一致性(又称原子性)，事务提交后，要么都修改成功，要么都不成功。
- 提交读，保证其它并发事务的修改要么全可见，要么全不可见，可以理解为"写一致性读"，注意断句！"写一致性"、"读"，这是最常用的事务隔离级别，可以保证业务数据含义的一致性。
比如用户下单场景，开事务先后写了order主表订单数据与order_item子表订单中商品数据，如果在两个写中间，有一个未提交读的事务，去读取order与order_item，就会发现只读到了order而没有读到order_item，这给用户看到了，那一定会吓一跳的，我交钱了结果买了一个空单！虽然用户刷新一下又可以看到完整数据。
但如果使用提交读事务隔离级别就不会有这个问题，用户要么查不到任何数据，要么查到完整数据，这也从侧面说明了逻辑上有关联的数据修改，一定要开事务来操作。
- 可重复读，保证事务开启或第一次查询那一刻，后面所有对整个数据库所有表的读都是读那一刻的版本，当然包括重复读同一张表，也可以理解为"一致版本读"。
- 串行化，一般来说解决的是并发上的逻辑错误，因为此级别逻辑上可以认为所有事务都是串行执行的(虽然数据库实际上可能会并发执行)。
比如两个事务先判断数据有没有，没有则插入数据的场景，并发情况下两个事务同时查询，发现没有数据后插入数据，结果插入了两条数据，而使用串行化隔离级别就没有这个问题，这在并发编程中叫竞态条件，所以串行化解决了读写的竞态条件问题。
当然，这个问题也可以通过添加唯一索引，或使用外部显示加锁的方法来解决。

```shell
select @@tx_isolation; #查看隔离级别
select @@global.tx_isolation; #查看系统隔离级别
set session transaction isolation level read uncommited;#设置隔离级别读未提交
set global transaction isolation level read uncommited;#设置系统隔离级别读未提交
```
`mysql.ini`中修改配置文件修改全局事务隔离级别
`transaction-isolation = read uncommited`
然后重启mysql服务

acid特性 
- 原子性
  - 事务不可分割
- 一致性
  - 从一个状态到另一个状态
- 隔离性
  - 多个事务相互隔离
- 持久性
  - 一旦改变就是永久性的


## 表类型和 存储引擎
表类型右存储引擎决定
存储引擎
- 事务安全型
  - innodb
- 非事务安全性    
  - myisam
  - memory
  
表类型
- csv
- memory
- archive
- mrg_myisam
- myisam
- innobdb

## 视图
>虚拟表，数据来查询的真实表

通过对试图的修改可以修改真实表

```shell
create view 名字 from select语句;
alter view 视图名字 as select语句;
show create view 视图名;#展示当时是如何创建的
drop view 视图名1,视图名2;

select * from myview;
```

## 用户管理
```shell
create user '用户名' @'host' identify by '密码';# 创建用户
drop user '用户名'@'host';#删除用户
set password  = 'xxxxx';
set password for 'user'@'host' = 'xxxxx';
grant 权限列表 on 库。对象名 to 'user'@'host' [identify by '密码'];#identify 可修改密码没有该用户则创建
```
权限列表
select,update,delete,insert,create,all ,

on bookdb.*;


```shell
flush privileges;#刷新权限
```

回收用户权限
```shell
revoke 权限列表 on 库.对象名 from '用古名'@'host';  
```

# java连接数据库

## jdbc
>为访问不同的数据库提供的统一的接口

先引入jar包
- 注册驱动--加载Driver
- 获取连接的***接口***Connection
- 执行增删改查-发送sql给数据库执行
- 释放资源

1.`Driver`
```java
import com.mysql.jdbc.Driver;

import com.mysql.cj.jdbc.Driver;//最新的推荐Driver；

Driver driver=new Driver();
String url="jdbc:mysql://localhost:3306/dbname";
//将用户名和密码封装到properties对象中
Properties  proterties=new Properties();
properties.setProperty("user","root");//用户
properties.setProperty("password","123456");//密码
Connection connection=driver.connect(url,properties);
String sql="insert into student values(13,'tom','男')";
Statement statement=connect.createStatement();
int infect_rows=statement.excuteUpdate(sql);//dml语句返回受影响的行数
statement.close();
connection.close();
```
`dbc:mysql://`协议
`localhost:3306`ip:端口
`dbname`数据库名字


2.`DriverManager`
```java
Driver driver=new Driver();
String url="jdbc:mysql://localhost:3306/dbname";
DriverManager.registerDriver(driver);//注册Driver驱动
Connection connection=DriverManager.getConnection(url,"root","123456");

connection.close();
```

3.`Class.forName()`简化注册驱动
底层静态代码块在加载Driver的时候就默认注册了驱动
```java
Class.forName("com.mysql.jdbc.Driver");//在加载Driver类时，自动注册。在高于5.1.6版本之上无需本句话
String url="jdbc:mysql://localhost:3306/dbname";
Connection connection=DriverManager.getConnection(url,"root","123456");
```
4. 在5.1.6版本之上自动注册
   
META-INF/services/java.sql.Driver里面会自动加载
```java
String url="jdbc:mysql://localhost:3306/dbname";
Connection connection=DriverManager.getConnection(url,"root","123456");
```

52. 配置文件

```properties
user=root
password=123456
url=jdbc:mysql://localhost:3306/dbname
driver=com.mysql.jdbc.Driver

```


```java
Properties properties=new Properties();
properties.load(new FileInputStream("xxx.properties"));

Class.forName("com.mysql.jdbc.Driver");
Connection onnection=DriverManage.getConnection(url,properties.get("user"),properties.get("password");
```
## `ResultSet`

```java
String sql="select * from student;  ";
ResultSet rs =statemeant.excuteQuery(sql);//擦汗寻语句返回'一张表'
while(rs.next()){//rs光标向下移动，没有数据之后返回false
int id=rs.getInt(1);//第一列
String id_=rs.getInt("id");//id列可以通过列名字来获取
String name=rs.getInt(2);//第二列
Date date=rs.getDate(2);//第三列
; }
rs.close();
statement.close();

```
`previous`光标向上移动

## Statement
>用于执行静态sql语句并返回生成结果的对象

连接建立后需要对数据库进行操作，可以通过
- Statement 存在sql注入
- PreparedStatement 预处理
- CallableStatement 存储过程
  
sql注入存在sql注入风险，即为恶意sql攻击数据库

### PreparedStatement
>预处理 减少sql注入，不在拼接字符串减少拼接错误，减少编译次数

```java
String sql="selecct * from student where name= ? and id =?";//?相当于占位符,从1开始计算
PreparedStatement ps=connection.prepareStatement(sql);
ps.setString(1,"tom");//
ps.setString(2,1001);//
ps.excuteQuery();//select语句
ps.excuteUpdate();//update，delete，insert语句
ps.close();
```
`excute()`执行任意sql返回boolean

jdbc的sql执行成功会自动提交，不能够回滚

### 使用事务
```java
connect.setAutoCommit(false);//可以取消自动提交事务
connect.commit();//使用放啊提交事务
//出现异常之后，可以在回滚
connect.rollback();//默认回滚到事务开始的状态
```

### 批处理
```java
preparedstatement.addBatch();//添加需要批量处理的语句
preparedstatement.excuteBatch();//批量处理sql语句
preparedstatement.clearBatch();//清空处理的sql语句

```

`String url="jdbc:mysql://localhost:3306/dbname?rewriteBatchStatements=true";`
url中必须得加上批处理

### 数据库连接池
传统jsbc开发中的问题

- 传统jdbc需要Drivermanager获取，将Connection加载到内存中，账户密码的验证占用资源
- 出现异常不能关闭数据库，占用资源
- 不能控制连接的数量，导致内存泄漏，MySQL崩溃

Connection Pool
- 预先在连接池中放置一定数量的连接
- 数据库负责管理分配连接，允许重新使用而不是建立新的
- 请求数量超过连接池中的数量时，将新的请求加入到等待队列中
- 使用完后，连接并不断开，而是不再引用


JDBC的数据库连接池使用`javax.sql.DataSource`DataSurce只是一个接口，通常有第三方实现

- *C3P0* 速度相对较慢，稳定性不错，hibernate spring的底层
- DBCP 相对较快，但不稳定
- Proxool 可以监控连接状态稳定性比c3p0较差
- BoneCp 速度快
- *Druid*德鲁伊阿里数据连接池，集以上优点于一身
  

#### c3p0
先引入jar包
```java
ComboPooledDataSource comboPoolDataSource =new ComboPooledDataSource();
comboPoolDataSource.setDriverClass("com.jabc.Driver");
comboPoolDataSource.setUser("root");
comboPoolDataSource.setJdbcUrl("jabc:mysql://localhost:3306/dbname");
comboPoolDataSource.setPassword("123456");
comboPoolDataSource.setInitialPoolSize(10);//设置连接数量10
comboPoolDataSource.setMaxPoolSize(50);//设置最大连接数量50
Connection connection=comboPoolDataSource.getConnection();
connection.close();
```

使用配置文件
`src/c3p0-config.xml`

指定连接数据库和连接池子的参数
```xml
<!-- 自定义的c3p0-config.xml -->
<!--<?xml version="1.0" encoding="UTF-8"?>-->

<c3p0-config>
    <default-config>
        <property name="driverClass">com.mysql.cj.jdbc.Driver</property>
        <property name="jdbcUrl">jdbc:mysql://127.0.0.1:3306/bookmanage</property>
        <property name="user">boss</property>
        <property name="password">123456</property>

        <property name="initialPoolSize">10</property>
        <property name="maxIdleTime">30</property>
        <property name="maxPoolSize">100</property>
        <property name="minPoolSize">10</property>
    </default-config>

    <named-config name="mySource">
        <property name="driverClass">com.mysql.cj.jdbc.Driver</property>
        <property name="jdbcUrl">jdbc:mysql://127.0.0.1:3306/bookmanage</property>
        <property name="user">boss</property>
        <property name="password">123456</property>

        <property name="initialPoolSize">10</property>
        <property name="maxIdleTime">30</property>
        <property name="maxPoolSize">100</property>
        <property name="minPoolSize">10</property>
    </named-config>
</c3p0-config>
```

```java
DataSource ds = new  ComboPooledDataSource(" mySource ");//参数对应使用哪个config，如果不写，表示使用默认的config，即default-config里的配置，否则使用参数指定的named-config里的配置
```

#### Druid德鲁伊
先引入jar包


建立`src/druid.properties`文件
```properties
username=boss
password=123456
url=jdbc:mysql://127.0.0.1:3306/bookmanage
driver=com.mysql.cj.jdbc.Driver
```
driver或者写`driverClassName`
不能有空格


```java
properties;//加载`src/druid.properties`

//创建一个指定参数的数据源
DataSource dataSource=DruidDataSourceFactory.createDataSource(properties);
Connection connection=dataSource.getConnection();
connection.close();

```

### DBUtil类
（apache组织提供）
connection关闭后ResultSet不能够再使用
ResultSet使用返回数据也不方便

使用 apache+dbutil+druid简化jdbc开发
解决方案 将一张表映射到一个对象。JavaBean PoJO domain
```java
QueryRunner queryRunner = new QueryRunner();
List<User>list=queryRunner.query(connection,sql,new BeanListHandler<>(Actor.class),Object...params);//params是可变形参，可以就收多个在sql中的?占位符，多行多列
User user=queryRunner.query(connection,sql,new BeanHandler<>(Actor.class),Object...params);//已知查询结果就一个，单行多列
Object obj=queryRunner.query(connection,sql,new ScalarHandler<>(Actor.class),Object...params);//已知查询结果就一个，单行单列

connection.close();
```

### Dao
问题
- 之前的查询sql是单独写的
- 对Select返回类型不确定需要似乎用泛型
- 将来表很多，不可能只依赖一个java类完成


Dao data access object数据访问对象
专门对数据库操作crud

User表-User类-UserDao
#### BaseDao


# 正则表达式 regular epression
```java
String regstr="\\d\\d\\d\\d";
Pattern pattern=Pattern.compile(regstr);//模式对象
Matcher matcher=pattern.matcher(content);//匹配器
while(matcher.find()){
    System.out.print(match.group(0));
}
```
matcher将匹配到的子字符串的索引加1记录到groups数组中
grops[0] = start index
grops[1] = end index + 1 

正则表达式中有小括号的时候表示的是分组`"(\\d\\d)(\\d)"`

groups[2] 与group[3]保存着第一组匹配到的子串的位置
group[4],group[5]类似
`match.group(0)`表示匹配到的子串
`match.group(1)`表示匹配到的第一组的子串

## 基本规则
### 元字符
转义字符`\\`
需要转义的符号`+-().*?[]{}$/\`,[]里面不需要转义
- `[]`表示可接受的字符列表`[efgt]` 其中的任意一个字符

- `[^]`表示不接受的字符列表`[^abc]` 出abc之外的任意一个字符包括数字和特殊字符
- `-`连字符 `A-Z`表示A到Z
- `.`匹配除`\n`以外的任何一个字符，匹配自身`.`需要`\\.`
- `\\d`匹配单个数字字符相当于`[0-9]`
- `\\d{8}`表示有连续8个数字字符
- `\\D`匹配单个非数字字符`[^0-9]`
- `\\w`匹配单个数字大小写字母`[0-9A-Za-z]`
- `\\W`匹配单个非数字大小写字母`[^0-9A-Za-z]`
- `\s` 匹配任何空白字符，任何一个空格制表等
- `\S`匹配任何一个非空白字符

#### 大小写敏感
`(?i)abc`匹配abc字符串大小写不敏感
`a(?i)bc`bc不区分大小写
`a((?i)b)c`b不区分大小写

`Pattern pattern = Pattern.compile(regStr,Pattern.CASE_INSENSITIVE);`匹配的时候不区分大小写


### 选择匹配符号

`|`
`a|b|c`匹配a或者b或者c

### 限定符

- `*`限定字符出现0到n次
- `+`字符重复1到n次
- `?`字符重复0到1次
- `{n}`连续出现n次
- `{n,}`至少要出现n次
- `{n,m}`出现次数[n,m]次
  
默认贪婪匹配匹配最多的次数
`9+?`匹配最少的9，`?`紧跟限定符之后表示非贪婪匹配
### 正则定位符
- `^` 至少一个字符开头`^[0-9]`目标字符串至少一个数字开头
- `$` 指定结束字符`[a-z]+$` 目标字符串的收尾至少一个小写字母结尾
- `\\b` 匹配目标字符串的边界。 边界值为字符串的空格或者字符串的结尾`han\\b` 
- `\B` 匹配目标字符串的非边界

### 分组
#### 捕获分组
- (pattern)非命名捕获，编号0为整个字符串，其他捕获结果按照分组顺序编号
- (?<name>pattern)命名捕获，将捕获的字符串捕获到一个组名或编号名称当中可用单引号代替尖括号


```java
String regStr="(?<group1>\\d\\d)(<?group2>\\d)";
matcher.group("group1");
matcher.group("group2");
```

#### 非捕获分组
- `(?:pattern)` 不捕获该分组的子表达式,即不能用`group(n)`获取`indust(?:y|ies)`是比`industry|industries`更经济的表达式
- `(?=pattern)` 非捕获匹配。`windows (?=2000|xp)`只匹配带着2000，xp的windows而不匹配windows 3.1中的windows
- `(?!pattern)`非捕获匹配，取反。`windows (?=2000|xp)`只不匹配带着2000，xp的windows而匹配windows 3.1等其他类型中的windows



## 实例
```java
//汉字
String regStr="^[\u0391-\uffe5]+$";    //汉字编码范围
//邮政编码
String resStr= "^[1-9][0-9]{5}" ;//1-9开头的一个六位数
String resStr= "^[1-9]\\d{5}" ;//1-9开头的一个六位数
//qq号码
String resStr="^[1-9]\\d{4,9}$";//1-9开头的一个5到10位数字
//手机号码
String resStr="^1[3|4|5|8]\\d{9}$";//13,14,15,18开头的11位数字
//域名
String resStr="^((https?)://)([\\w-]+\\.)+([\\w-])+$";
//url
String resStr="^((https?)://)([\\w-]+\\.)+([\\w-])+(\\/[\\w-=/#?&%.]*)?$";

```
## 常用方法
`Pattern``Matcher`
 

# 补充
## Junit测试类
java语言的单元测试框架
```java
public Dog{
    @Test//可以直接run和debug选择版本5
    public void cry(){

    }
} 

```



## 绘图

```java

import javax.swing.*;
import java.awt.*;

    public class Draw extends JFrame {
        MyJpanel mp;
        public static void main(String []args){
            new myTest.Draw().draw();
        }
        public void draw(){
            mp=new MyJpanel();
            this.add(mp);
            this.setSize(400,300);
            this.setVisible(true);//可以显示
            this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//当关闭窗口时提出程序
        }
}
class MyJpanel extends Panel {
    @Override
    public void paint(Graphics g){
        super.paint(g);
        g.drawOval(10,10,100,100);//椭圆或者圆 左上角x，左下角y，宽，高
        bombImg1=Toolkit.getDefaultToolkit().getImage(Panel.class.getResource("/bomb1.jpg"));//图片显示
         //图片放置在production之下，根目录之下
        g.drawImage(bombImg3,bomb.x,bomb.y,60,60,this);
        System.out.println("运行");
    }
}

```
系统在变化的时候自动调用paint函数，比如窗口大小改变


## 事件处理机制
KeyListener是监听器可以监听键盘事件

事件监听者是一个类实现了事件监听接口
```java
class MyPanel extends Panel implements KeyLisntener{
    @Override
    public void keyPressed(keyEveny e){
        char c=(char)e.getKeyCode();    //按下的按键字符

        if(e.getKeyCode()==KeyEnent.VK_DOWN){
            //..
        }
    }
    @Override
    public void keyTyped(keyEveny e){
        
    }
    @Override
    public void keyReleased(keyEveny e){
        
    }
}
```


# 设计模式
## 单例模式
一个运行程序中一个类最多只有一个实例对象

饿汉型

可能存在资源浪费
```java
class User{
    String name="jack";
    private final User user=new User();
    private User(){}
    public User getInstance(){
        return user;
    }
}


```


懒汉型

线程可能不安全
```java
class User{
    String name="jack";
    private final User user;//=new User();
    private User(){}
    public User getInstance(){
        if(user==null){
            user=new User();
        }
        return user;
    }
}

```

## 抽象模板模式
继承父类，覆写父类里面的抽象方法

多个子类的代码相同部分保留，不同部分抽象出来覆写
```java
class A{
    abstract job();
    public long gettime(){
        long start=System.currentTimeMillis();
        job();
        long end=System.currentTimeMillis();
        return end-start;

    }
}
class B extends A{
    void job(){
        for(int i=0;i<2000;i++){
            System.out.print(i);
        }
    }
}

```

## 代理模式

```java
class ThreadProxy implements Runable{
    private Runnable target =null;//runnable接口实例
    @Override
    public void run(){
        if(target!=null){
            target.run();
        }
    }
    ThreadProxy(Runnable target){
        this.target=target;
    }
    public void start(){
        start0();
    }
    public void start0(){
        run();
    }
}


```
## 修饰器模式
例如`FileReader`与`BufferedReader`

