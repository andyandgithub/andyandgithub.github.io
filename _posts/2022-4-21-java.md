---
layout: post
title: Java常用以及数据结构
categories: study
tags : java
toc: true
---
# 常用
## 获取时间

```java
System.currentTimeMillis()
//1650093029236
```
## 文件操作

### 创建文件

```java
String path = "./a.properties";
File file = new File(path);
System.out.println(file.getParentFile());
if (!file.getParentFile().exists()) {
    boolean result = file.getParentFile().mkdirs();
    if (!result) {
        System.out.println("创建失败");
    }
}

```

### 打开文件

```java
try { // 防止文件建立或读取失败，用catch捕捉错误并打印，也可以throw
 
			/* 读入TXT文件 */
			String pathname = "./addressbook.txt"; // 绝对路径或相对路径都可以，这里是绝对路径，写入文件时演示相对路径
			File filename = new File(pathname); // 要读取以上路径的input。txt文件
			InputStreamReader reader = new InputStreamReader(
					new FileInputStream(filename)); // 建立一个输入流对象reader
			BufferedReader br = new BufferedReader(reader); // 建立一个对象，它把文件内容转成计算机能读懂的语言
			String line = "";
			line = br.readLine();
			while (line != null) {
				line = br.readLine(); // 一次读入一行数据
                System.out.println(line);
			}

 
		} catch (Exception e) {
            System.out.println(e);
			e.printStackTrace();
		}


```


### 写入文件

```java

try { // 防止文件建立或读取失败，用catch捕捉错误并打印，也可以throw
 
		
 
			/* 写入Txt文件 */
			File writename = new File("./addressbook.txt"); // 相对路径，如果没有则要建立一个新的output。txt文件
			writename.createNewFile(); // 创建新文件
			BufferedWriter out = new BufferedWriter(new FileWriter(writename));//覆写
			//BufferedWriter out = new BufferedWriter(new FileWriter(writename,true));//是否追加
			out.write("我会写入文件啦\r\n"); // \r\n即为换行
			out.flush(); // 把缓存区内容压入文件
			out.close(); // 最后记得关闭文件
 
		} catch (Exception e) {
            System.out.println(e);
			e.printStackTrace();
		}

```


## java读取屏幕输入

```java
Scanner scanner = new Scanner(System.in); // 创建Scanner对象
System.out.print("Input your name: "); // 打印提示
String name = scanner.nextLine(); // 读取一行输入并获取字符串
System.out.print("Input your age: "); // 打印提示
int age = scanner.nextInt(); // 读取一行输入并获取整数
System.out.printf("Hi, %s, you are %d\n", name, age); // 格式化输出

```
## 比较
一.字符串
1.`equals()`：比较内容，推荐
```java
String a=new String("abc"); 
String b=new String("abc");
```
a.`equals(b)`;
2.`= = `：比较地址
```java
String c="123";
String d="123";
System.out.println(c==d);  //true，在java中字符串的值是不可改变的，相同的字符串在内存中只会存一份，所以a和b指向的是同一个对象；
String a=new String("abc");
String b=new String("abc");
System.out.println(c==d); //false，此时a和b指向不同的对象。
```
`= =`是比较内存地址的，内存地址相等，就返回true，地址相等，值肯定也一样，地址不相等，即使值相等也会返回false，

字符串是对象类型，所以不能用简单的“==”判断。

而用`equals（`）方法，String中重写了`equals`，不管地址是否相等，都只对值进行比较，值相等就返回true，不相等就返回false。两个String对象相等或内容相等都返回true
## 判断是否为数字，字母
### 字符char
```java
Character.isDigit(char c)　　//判断字符c是否是数字字符，如‘1’，‘2’，是则返回true，否则返回false  

Character.isLowerCase(char c)　|| Character.isUpperCase(char c)　　//判断c是否是字母字符，前面LowerCase是小写，后面UpperCase是大写，是返回True，否则返回False

Character.isLetterOrDigit(char c)　　//判断c是否是字母或数字字符，是返回true,否则返回false
Character.isLetter(char c)可以判断这些字符：

UPPERCASE_LETTER
LOWERCASE_LETTER
TITLECASE_LETTER
MODIFIER_LETTER
OTHER_LETTER
// 这些字符除了包含字母之外还包含其他字符
```

### 字符串String
使用正则表达式
```java
import java.util.regex.Pattern;

    public static boolean isInteger(String str){
        // Pattern pattern=Pattern.compile("^[-\\+]?[\\d]*$");
                Pattern pattern = Pattern.compile("[0-9]*");

        return pattern.matcher(str).matches();
    }
/**
 * 判断是否是字母
 * @param str 传入字符串
 * @return 是字母返回true，否则返回false
 */
public boolean is_alpha(String str) {
    if(str==null) return false;
    return str.matches("[a-zA-Z]+");
}
/**
 * 判断是否是字母或者数字
 * @param str 传入字符串
 * @return 是字母返回true，否则返回false
 */
public  static boolean isLetterDigit(String str) {
    String regex = "^[a-z0-9A-Z]+$";
    return str.matches(regex);
}
```

## 类型转换
### int与String
```java
int i = Integer.parseInt([String]); 
int i = Integer.parseInt([String],[int radix]);
int i = Integer.valueOf(my_str).intValue();

String s = String.valueOf(i);
String s = Integer.toString(i);

```
# int
## java int最大值
```java

    int length=Integer.MAX_VALUE;
```

## 随机数

```java
Random r = new Random();
double d1 = r.nextDouble(); // 生成[0,1.0]区间的小数
double d2 = r.nextDouble() * 7; // 生成[0,7.0]区间的小数
int i1 = r.nextInt(10); // 生成[0,10]区间的整数
int i2 = r.nextInt(18) - 3; // 生成[-3,15)区间的整数
long l1 = r.nextLong(); // 生成一个随机长整型值
boolean b1 = r.nextBoolean(); // 生成一个随机布尔型值
float f1 = r.nextFloat(); // 生成一个随机浮点型值
System.out.println("生成的[0,1.0]区间的小数是：" + d1);
System.out.println("生成的[0,7.0]区间的小数是：" + d2);
System.out.println("生成的[0,10]区间的整数是：" + i1);
System.out.println("生成的[-3,15]区间的整数是：" + i2);
System.out.println("生成一个随机长整型值：" + l1);
System.out.println("生成一个随机布尔型值：" + b1);
System.out.println("生成一个随机浮点型值：" + f1);
System.out.print("下期七星彩开奖号码预测：");

```


# 数组
## 定义
```java

int []a={1,1,1};
int []b=new int[size];
```
## 数组长度
```java
a.length
```
## 打印数组
```java
System.out.println(Arrays.toString(array));
```
### 打印二维数组
```java
System.out.println(Arrays.deepToString(numArray));
```
## int数组与Integer数组互转
```java

 Integer[] integers = new Integer[10];
        int[] ints;
        for (int i = 0; i < integers.length; i++) {
            integers[i] = i;
        }
       ints= Arrays.stream(integers).mapToInt(Integer::valueOf).toArray();
```
## 数组截取
```java
results = Arrays.copyOfRange(results, 0, 5);
```

# 列表List
## 列表定义
```java
//引入List
import java.util.ArrayList;
import java.util.List;
//定义
List<String> list = new ArrayList<>();//接受null
List<String> list = new LinkedList<>();//接受null
List<Integer> list = sLit.of(1, 2, 5);//不接受null
```
## 添加元素
```java
list.add("apple"); // size=1
list.add("pear"); // size=2
```
## 获取长度
```java
int size=list.size();
```
## 获取元素
### 根据位置
```java
String a=list.get(1);//t推荐arraylist
//遍历列表,迭代器
for (Iterator<String> it = list.iterator(); it.hasNext(); ) {
    String s = it.next();
    System.out.println(s);
}
for (String s : list) {
            System.out.println(s);
}
```
### 与数组互转
```java
Integer[] array = list.toArray(new Integer[3]);
```
list打印
```java
Arrays.toString(list.toArray())
```


# 字符串String
`length() `字符串的长度
`charAt()` 截取一个字符
`getChars()` 截取多个字符
`toCharArray() `转化为字符数组
`subString()` 取子字符串
```java


char chars[]={'a','b'.'c'};
String s=new String(chars);
int len=s.length();

char ch;
ch="abc".charAt(1); 返回'b'
```
## 字符串拼接
### plus

```java
String a="";
int b=0xb;
String c=a+b;
```

### concat

```java
//当两个量都为String类型且值不为null时，可以用concat方式。
String a="a";
String b="b";
String c= a.concat(b);
```

### StringBuffer

```java

StringBuffer buf=new StringBuffer();
StringBuffer buf=new StringBuffer(a.length()+b.length()+c.length());//提供足够的空间
buf.append("a");
if(someCondition){
    buf.append("b");
}
buf.append("c");
String d=buf.toString();
```


# set集合
```java
import java.util.Set;

 Set<Integer> set = new HashSet<Integer>();
 add( )
//将对象添加到集合
	clear( )
// 从集合中移除所有对象
	contains( )
// 如果指定的对象是集合中的元素返回true
	isEmpty( )
// 如果集合不包含任何元素，则返回true
	iterator( )
// 返回一个Iterator对象，可用于检索对象的集合
	remove( )
// 从集合中删除指定的对象
	size( )
// 
set.toArray(myArray);
//转成Integer,String 数组无法转为int数组

//Union - 为了得到两个集合x和y的并集，我们可以使用
x.addAll(y)

// Intersection - 要获得两个集合x和y的交集，我们可以使用
x.retainAll(y)

// Subset - 要检查x是否是y的子集，我们可以使用
y.containsAll(x)

Set接口的实现
```

# map 
## 定义
```java
Map<Integer,Integer> map=new HashMap<>();
```
## 包含有某个元素
```java
map.containsKey();
```
## 获取，添加，替换元素

```java
map.get(target-nums[i]);
           
map.put(nums[i], i);
// 替换 hashMap 中是指定的 key 对应的 value。
hashmap.replace(K key, V newValue)

hashmap.replace(K key, V oldValue, V newValue)
map.getOrDefault(key,value)
```
## 常用方法
### keyset
`keySet()`方法返回值是Map中key值的集合；entrySet()的返回值也是返回一个Set集合，此集合的类型为Map.Entry。
```java
for (String key : map.keySet()) {    
   System.out.println("key= "+ key + " and value= " + map.get(key));    
}  

```
### Entry
`Map.Entry`是Map声明的一个内部接口，此接口为泛型，定义为Entry<K,V>。它表示Map中的一个实体（一个key-value对）。接口中有getKey(),getValue方法。
```java
Iterator<Map.Entry<String, String>> it = map.entrySet().iterator();    
while (it.hasNext()) {    
    Map.Entry<String, String> entry = it.next();    
    System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue());    
}    
//("通过Map.entrySet遍历key和value  
for (Map.Entry<String, String> entry : map.entrySet()) {    
    System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue());    
}       
  
```
### values
```java
//通过Map.values()遍历所有的value，但不能遍历key 
for (String v : map.values()) {    
    System.out.println("value= " + v);    
}
```
## TreeMap




# 栈 Stack
>后进先出

```java
Stack<Integer> st = new Stack<Integer>();
int a=7;
st.push(new Integer(a));
Integer b = (Integer) st.pop();

Object peek( )
// 查看堆栈顶部的对象，但不从堆栈 移除它。
boolean empty() 
// 测试堆栈是否为空。
int search(Object element)
// 返回对象在堆栈中的位置，以 1 为基数。
```

# 队列 Queue
> 先进先出

```java
Queue<String> queue = new LinkedList<String>();

offer()
// ：往队列添加元素。如果队列已满直接返回false，队列未满则直接插入并返回true；

add()
//：对offer()方法的简单封装。如果队列已满，抛出异常new IllegalStateException("Queue full")；

put()
// ：往队列里插入元素，如果队列已经满，则会一直等待直到队列为空插入新元素，或者线程被中断抛出异常.

remove()
// ：直接删除队头的元素；

peek()
// ：直接取出队头的元素，并不删除。

element()
// ：对peek方法进行简单封装，如果队头元素存在则取出并不删除，如果不存在抛出异常NoSuchElementException()；

pool()
// ：取出并删除队头的元素，当队列为空,返回null；

take()
// ：取出并删除队头的元素，当队列为空，则会一直等待直到队列有新元素可以取出，或者线程被中断抛出异常
```

## 双端队列Deque
### 定义
```java
Deque deque = new LinkedList();
```
### 常用方法

| 第一个元素 | (头部)          | 最后一个元素    | (尾部)         |
| ---------- | --------------- | --------------- | -------------- |
| 抛出异常   | 特殊值          | 抛出异常        | 特殊值         |
| 插入       | `addFirst(e)`   | `offerFirst(e)` | `addLast(e)`   | `offerLast(e)` |
| 删除       | `removeFirst()` | `pollFirst()`   | `removeLast()` | `pollLast()`   |
| 检查       | `getFirst()`    | `peekFirst()`   | `getLast()`    | `peekLast()`   |

##  PriorityQueue

> 优先级队列，同堆

### 定义

```java
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Comparator;

Queue<String> q = new PriorityQueue<>();
//自定义比较函数
Queue<User> q = new PriorityQueue<>(new UserComparator());
class UserComparator implements Comparator<User> {
    public int compare(User u1, User u2) {
        if (u1.number.charAt(0) == u2.number.charAt(0)) {
            // 如果两人的号都是A开头或者都是V开头,比较号的大小:
            return u1.number.compareTo(u2.number);
        }
        if (u1.number.charAt(0) == 'V') {
            // u1的号码是V开头,优先级高:
            return -1;
        } else {
            return 1;
        }
    }
}

```

### 插入元素

```java
q.offer("apple");
q.add("pear");
q.offer("banana");
     

```

`add(E e)`和`offer(E e)`的语义相同，都是向优先队列中插入元素
只是`Queue`接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回false。对于`PriorityQueue`这两个方法其实没什么差别。

### 取出元素

`remove()`和`poll()`方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回null.

由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。

```java
System.out.println(q.poll()); // apple
System.out.println(q.poll()); // banana
System.out.println(q.poll()); // pear
System.out.println(q.poll()); 

```

### 获取元素

`element()`和`peek()`的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素

二者唯一的区别是当方法失败时前者抛出异常，后者返回null。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，0下标处的那个元素既是堆顶元素。所以直接返回数组0下标处的那个元素即可。

### 大小

```java
queue.size();
```

# pair配对

>配对提供了一种方便方式来处理简单的键值关联

```java
Pair<Integer, String> pair = new Pair<>(1, "One");
Integer key = pair.getKey();
String value = pair.getValue();
```
